[
  {
    "id": "ar_lsat_200006_1-G_1_1",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "Which one of the following is a complete and accurate list of the children who must be among those assigned to shared lockers?",
    "answer": "E",
    "options": [
      "A) Fred, Juan",
      "B) Juan, Paul",
      "C) Juan, Marc, Paul",
      "D) Juan, Marc, Trisha",
      "E) Juan, Nita, Trisha"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFour boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.\nQuestion:\nWhich one of the following is a complete and accurate list of the children who must be among those assigned to shared lockers?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nchildren = EnumSort([Fred, Juan, Marc, Paul, Nita, Rachel, Trisha])\nlockers = EnumSort([1, 2, 3, 4, 5])\nassigned = Function([children, lockers] -> [bool])\n\n# Constraints\nForAll([c:children], Count([l:lockers], assigned(c, l)) >= 1) ::: each child is assigned to at least one locker\nAnd(assigned(Juan, 3), Count([c:children], And(c != Juan, assigned(c, 3))) == 1) ::: Juan must share a locker\nImplies(assigned(Nita, l), Not(assigned(Trisha, l))) ::: Nita's locker cannot be adjacent to Trisha's locker\nForAll([l:lockers], Implies(assigned(Fred, l), Not(assigned(Rachel, l)))) ::: Fred must be assigned to locker 3\n\n# Options\nQuestion ::: Which one of the following is a complete and accurate list of the children who must be among those assigned to shared lockers?\nis_sat(ForAll([l:lockers], assigned(Nita, l) == assigned(Rachel, l))) ::: (A)\nis_sat(ForAll([l:lockers], assigned(Rachel, l) == assigned(Trisha, l))) ::: (B)\nis_sat(ForAll([l:lockers], assigned(Nita, l) == assigned(Trisha, l))) ::: (C)\nis_sat(ForAll([l:lockers], assigned(Fred, l) == assigned(Paul, l))) ::: (D)\nis_sat(ForAll([l:lockers], assigned(Paul, l) == assigned(Marc, l))) ::: (E)\n\n------\n\nNote: The `is_sat` function is used to check whether a given formula is satisfiable (i.e., whether it is true or false). If the formula is true, then the pair of technicians can repair all and only the same types of machines as each other."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_1_2",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "If Trisha is assigned to locker 3 and Marc alone is assigned to locker 1, then which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) Juan is assigned to locker 4.",
      "B) Juan is assigned to locker 5.",
      "C) Paul is assigned to locker 2.",
      "D) Rachel is assigned to locker 2.",
      "E) Rachel is assigned to locker 5."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFour boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.\nQuestion:\nIf Trisha is assigned to locker 3 and Marc alone is assigned to locker 1, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fred, Juan, Marc, Paul, Nita, Rachel, Trisha])\nlockers = EnumSort([1, 2, 3, 4, 5])\nassigned = Function([people, lockers] -> [bool])\n\n# Constraints\nForAll([p:people], ForAll([l:lockers], assigned(p, l) == assigned(p, l + 1))) ::: Each locker must be assigned to either one or two children\nAnd(assigned(Juan, 1), assigned(Juan, 2)) ::: Juan must share a locker\nNot(assigned(Rachel, 1)) ::: Rachel cannot share a locker\nassigned(Nita, 3) ::: Nita's locker cannot be adjacent to Trisha's locker\nassigned(Fred, 3) ::: Fred must be assigned to locker 3\n\n# Options\nQuestion ::: Which one of the following must be true if Trisha is assigned to locker 3 and Marc alone is assigned to locker 1?\nis_valid(ForAll([p:people], ForAll([l:lockers], assigned(p, l) == assigned(p, l + 1) && assigned(Trisha, l) == assigned(Marc, l + 1)))) ::: (A)\nis_valid(ForAll([p:people], ForAll([l:lockers], assigned(p, l) == assigned(p, l + 1) && assigned(Trisha, l) != assigned(Marc, l + 1)))) ::: (B)\nis_valid(ForAll([p:people], ForAll([l:lockers], assigned(p, l) == assigned(p, l + 1) && assigned(Trisha, l + 1) == assigned(Marc, l)))) ::: (C)\nis_valid(ForAll([p:people], ForAll([l:lockers], assigned(p, l) == assigned(p, l + 1) && assigned(Trisha, l + 1) != assigned(Marc, l)))) ::: (D)\nis_valid(ForAll([p:people], ForAll([l:lockers], assigned(p, l) == assigned(p, l + 1) && assigned(Trisha, l) == assigned(Marc, l + 1)))) ::: (E)\n\n------\n\nPlease help me solve this problem and answer the question."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_1_3",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "If the four boys are assigned to consecutively numbered lockers and Juan is assigned to locker 5, then which one of the following is a complete and accurate list of lockers each of which CANNOT be a shared locker?",
    "answer": "D",
    "options": [
      "A) locker 2",
      "B) locker 4",
      "C) locker 1, locker 2",
      "D) locker 1, locker 4",
      "E) locker 2, locker 4"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFour boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.\nQuestion:\nIf the four boys are assigned to consecutively numbered lockers and Juan is assigned to locker 5, then which one of the following is a complete and accurate list of lockers each of which CANNOT be a shared locker?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fred, Juan, Marc, Paul, Nita, Rachel, Trisha])\nlockers = EnumSort([1, 2, 3, 4, 5])\nassigned = Function([people, lockers] -> [bool])\n\n# Constraints\nForAll([l:lockers], Count([p:people], assigned(p, l)) >= 1) ::: each locker is assigned to at least one person\nAnd(assigned(Juan, 5), Count([p:people], And(p != Juan, assigned(p, 5))) == 1) ::: Juan must share a locker, but Rachel cannot share a locker\nForAll([p:people], Implies(assigned(p, l), Not(assigned(Nita, l)))) ::: Nita's locker cannot be adjacent to Trisha's locker\nassigned(Fred, 3) ::: Fred must be assigned to locker 3\n\n# Options\nQuestion ::: Which one of the following is a complete and accurate list of lockers each of which CANNOT be a shared locker?\nis_sat(ForAll([l:lockers], assigned(Fred, l) == assigned(Paul, l))) ::: (A)\nis_sat(ForAll([l:lockers], assigned(Nita, l) == assigned(Trisha, l))) ::: (B)\nis_sat(ForAll([l:lockers], assigned(Marc, l) == assigned(Rachel, l))) ::: (C)\nis_sat(ForAll([l:lockers], assigned(Paul, l) == assigned(Trisha, l))) ::: (D)\nis_sat(ForAll([l:lockers], assigned(Juan, l) == assigned(Nita, l))) ::: (E)\n\n------\n\nNote: The problem and question statements are given in a logical form, which is a standard way of representing problems in logic programming. The task is to translate the problem and question into a logic program, which is a set of clauses in the form `h(x1, x2, ..., xn) -> b`, where `h` is a head (a goal) and `b` is a body (a conclusion). The clauses are used to represent the constraints and options in the problem, and the goal is to find a satisfying assignment of values to the variables that makes the conclusion true."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_1_4",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "Once Rachel has been assigned to a locker, what is the maximum number of different lockers each of which could be the locker to which Juan is assigned?",
    "answer": "C",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFour boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.\nQuestion:\nOnce Rachel has been assigned to a locker, what is the maximum number of different lockers each of which could be the locker to which Juan is assigned?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fred, Juan, Marc, Paul, Nita, Rachel, Trisha])\nlockers = EnumSort([1, 2, 3, 4, 5])\nassigned = Function([people, lockers] -> [bool])\n\n# Constraints\nForAll([l:lockers], Count([p:people], And(assigned(p, l), p != Rachel))) ::: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker\nForAll([p:people], And(assigned(p, l), p != Rachel)) ::: Each child must be assigned to exactly one locker\nForAll([l:lockers], Implies(assigned(Juan, l), Not(assigned(Rachel, l)))) ::: Juan must share a locker, but Rachel cannot share a locker\nForAll([l:lockers], Implies(assigned(Nita, l), Not(assigned(Trisha, l)))) ::: Nita's locker cannot be adjacent to Trisha's locker\nassigned(Fred, 3) ::: Fred must be assigned to locker 3\n\n# Options\nQuestion ::: Once Rachel has been assigned to a locker, what is the maximum number of different lockers each of which could be the locker to which Juan is assigned?\nis_valid(Exists([l:lockers], assigned(Juan, l) == 1)) ::: (A)\nis_valid(Exists([l:lockers], assigned(Juan, l) == 2)) ::: (B)\nis_valid(Exists([l:lockers], assigned(Juan, l) == 3)) ::: (C)\nis_valid(Exists([l:lockers], assigned(Juan, l) == 4)) ::: (D)\nis_valid(Exists([l:lockers], assigned(Juan, l) == 5)) ::: (E)\n\n------\n\nNote: The problem and question statements are given in a logical form, which is a standard way of representing problems in logic programming. The task is to translate the problem and question into a logic program, which is a set of clauses in the form `h(x1, x2, ..., xn) -> b`, where `h` is a head (a goal) and `b` is a body (a conclusion). The clauses are used to represent the constraints and options in the problem, and the goal is to find a satisfying assignment of values to the variables that makes the conclusion true."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_1_5",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "If the first three lockers are assigned to girls, which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) Juan is assigned to locker 1.",
      "B) Nita is assigned to locker 3.",
      "C) Trisha is assigned to locker 1.",
      "D) Juan is assigned to the same locker as Trisha.",
      "E) Paul is assigned to the same locker as Trisha."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFour boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.\nQuestion:\nIf the first three lockers are assigned to girls, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fred, Juan, Marc, Paul, Nita, Rachel, Trisha])\nlockers = EnumSort([1, 2, 3, 4, 5])\nassigned = Function([people, lockers] -> [bool])\n\n# Constraints\nForAll([l:lockers], Count([p:people], And(assigned(p, l), p != Rachel)) >= 1) ::: each locker must be assigned to either one or two children\nAnd(assigned(Juan, l), Count([p:people], And(assigned(p, l), p != Rachel)) == 1) ::: Juan must share a locker, but Rachel cannot share a locker\nForAll([l:lockers], Implies(assigned(Nita, l), Not(assigned(Trisha, l)))) ::: Nita's locker cannot be adjacent to Trisha's locker\nassigned(Fred, 3) ::: Fred must be assigned to locker 3\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(Exists([l:lockers], assigned(Nita, l) == assigned(Trisha, l))) ::: (A)\nis_valid(Exists([l:lockers], assigned(Rachel, l) == assigned(Trisha, l))) ::: (B)\nis_valid(Exists([l:lockers], assigned(Nita, l) == assigned(Paul, l))) ::: (C)\nis_valid(Exists([l:lockers], assigned(Fred, l) == assigned(Marc, l))) ::: (D)\nis_valid(Exists([l:lockers], assigned(Juan, l) == assigned(Marc, l))) ::: (E)\n\n------\n\nNote: The problem and question statements are given in a logical form, which is a standard way of representing problems in logic programming. The task is to translate the problem and question into a logic program, which can be used to solve the problem and answer the question. The logic program consists of three parts: Declarations, Constraints, and Options. The Declarations part defines the variables and functions used in the problem, the Constraints part defines the constraints that must be satisfied, and the Options part defines the options that must be true."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_1_6",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "If lockers 1 and 2 are each assigned to one boy and are not shared lockers, then locker 4 must be assigned to",
    "answer": "C",
    "options": [
      "A) Juan",
      "B) Paul",
      "C) Rachel",
      "D) Juan and Nita",
      "E) Marc and Trisha"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFour boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.\nQuestion:\nIf lockers 1 and 2 are each assigned to one boy and are not shared lockers, then locker 4 must be assigned to\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fred, Juan, Marc, Paul, Nita, Rachel, Trisha])\nlockers = EnumSort([1, 2, 3, 4, 5])\nassigned = Function([people, lockers] -> [bool])\n\n# Constraints\nForAll([l:lockers], Count([p:people], And(assigned(p, l), p != Rachel))) ::: Each locker must be assigned to either one or two children\nForAll([p:people], Count([l:lockers], assigned(p, l)) >= 1) ::: Each child must be assigned to exactly one locker\nForAll([l:lockers], And(assigned(Nita, l), assigned(Trisha, l)) == 1) ::: Each shared locker must be assigned to one girl and one boy\nForAll([l:lockers], Not(assigned(Juan, l))) ::: Juan must share a locker, but Rachel cannot share a locker\nForAll([l:lockers], assigned(Fred, l) == 3) ::: Fred must be assigned to locker 3\n\n# Options\nQuestion ::: If lockers 1 and 2 are each assigned to one boy and are not shared lockers, then locker 4 must be assigned to\nis_valid(Exists([l:lockers], assigned(Paul, l) == 4)) ::: (A)\nis_valid(Exists([l:lockers], assigned(Marc, l) == 4)) ::: (B)\nis_valid(Exists([l:lockers], assigned(Trisha, l) == 4)) ::: (C)\nis_valid(Exists([l:lockers], assigned(Nita, l) == 4)) ::: (D)\nis_valid(Exists([l:lockers], assigned(Paul, l) == 5)) ::: (E)\n\n------\n\nNote: The problem and question statements are given in a logical form, which is a standard way of representing problems in logic programming. The task is to translate the problem and question into a logic program, which is a set of clauses in the form `h(x1, x2, ..., xn) -> b`, where `h` is a head (a goal) and `b` is a body (a conclusion). The clauses are used to reason about the problem and answer the question."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_7",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "Which one of the following could be a complete and accurate list of the types of CDs that are on sale?",
    "answer": "E",
    "options": [
      "A) new jazz, used jazz, used opera, used pop, new rap",
      "B) new jazz, used pop, used rap, new soul",
      "C) used opera, used pop, new rap, used rap",
      "D) used opera, new pop, used pop, new soul",
      "E) used jazz, used pop, new soul, used soul"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.\nQuestion:\nWhich one of the following could be a complete and accurate list of the types of CDs that are on sale?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nCDs = EnumSort([new_jazz, new_opera, new_pop, used_jazz, used_opera, used_pop, new_rap, new_soul])\nsale = Function([CDs] -> [bool])\n\n# Constraints\nForAll([c:CDs], sale(c) == False) ::: no CD is on sale\nForAll([c:CDs], And(sale(c), sale(c + 1)) == False) ::: no CD is on sale\nForAll([c:CDs], Implies(sale(c), Not(sale(c + 1)))) ::: no CD is on sale\nForAll([c:CDs], sale(c) == True) ::: used pop is on sale\nForAll([c:CDs], And(sale(c), sale(c + 1)) == True) ::: new opera is not on sale\nForAll([c:CDs], Implies(sale(c), Not(sale(c + 1)))) ::: if both types of pop are on sale, then all soul is\nForAll([c:CDs], And(sale(c), sale(c + 1)) == True) ::: if neither type of jazz is on sale, then new pop is\nForAll([c:CDs], Implies(sale(c), Not(sale(c + 1)))) ::: if either type of rap is on sale, then no soul is\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the types of CDs that are on sale?\nis_sat(ForAll([c:CDs], sale(c) == True)) ::: ([[CHOICES]])\n\n------\n\nNote: The `is_sat` function is used to check if the given list of CDs is a complete and accurate list of the types of CDs that are on sale, based on the constraints given in the problem."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_8",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "If new soul is not on sale, then which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) New rap is not on sale.",
      "B) New rap is on sale.",
      "C) Used opera is not on sale.",
      "D) At least one type of jazz is not on sale.",
      "E) At least one type of pop is not on sale."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.\nQuestion:\nIf new soul is not on sale, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nCDs = EnumSort([new_pop, used_pop, new_opera, used_opera, new_rap, used_rap, new_soul, used_soul])\nsale = Function([CDs] -> [bool])\n\n# Constraints\nForAll([c:CDs], sale(c) == False) ::: none of the CDs are on sale\nForAll([c:CDs], Implies(sale(c), Not(sale(used_pop)))] ::: used pop is on sale\nForAll([c:CDs], Implies(sale(c), Not(sale(new_opera)))] ::: new opera is not on sale\nForAll([c:CDs], Implies(sale(c), Not(sale(new_rap)))] ::: new rap is not on sale\nForAll([c:CDs], Implies(sale(c), Not(sale(new_soul)))] ::: new soul is not on sale\nForAll([c:CDs], Implies(sale(c), sale(used_pop) == sale(new_pop))) ::: if new pop is on sale, then all soul is\nForAll([c:CDs], Implies(sale(c), sale(used_pop) == sale(used_soul))) ::: if used pop is on sale, then all soul is\n\n# Options\nQuestion ::: ::: If new soul is not on sale, then which one of the following must be true?\nis_sat(ForAll([c:CDs], sale(c) == sale(used_soul))) ::: (A)\nis_sat(ForAll([c:CDs], sale(c) == sale(used_pop))) ::: (B)\nis_sat(ForAll([c:CDs], sale(c) == sale(new_soul))) ::: (C)\nis_sat(ForAll([c:CDs], sale(c) == sale(new_pop))) ::: (D)\nis_sat(ForAll([c:CDs], sale(c) == sale(new_rap))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_9",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "If both types of jazz are on sale, then which one of the following is the minimum number of types of new CDs that could be included in the sale?",
    "answer": "A",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.\nQuestion:\nIf both types of jazz are on sale, then which one of the following is the minimum number of types of new CDs that could be included in the sale?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nCDs = EnumSort([new, used, jazz, opera, pop, rap, soul])\nsale = Function([CDs] -> [bool])\n\n# Constraints\nForAll([c:CDs], Count([t:CDs], And(t == c, sale(t))) >= 1) ::: each CD is included in the sale\nAnd(sale(used, pop), Count([t:CDs], And(t == pop, sale(t))) == 2) ::: used pop is on sale\nAnd(sale(jazz, jazz), Not(sale(rap, soul))) ::: if both types of jazz are on sale, then no rap is on sale\nAnd(sale(jazz, soul), Not(sale(rap, jazz))) ::: if neither type of jazz is on sale, then new pop is on sale\nAnd(sale(rap), Not(sale(soul))) ::: if either type of rap is on sale, then no soul is on sale\n\n# Options\nQuestion ::: Which one of the following is the minimum number of types of new CDs that could be included in the sale?\nis_valid(Exists([c:CDs], sale(c) == 2)) ::: (A)\nis_valid(Exists([c:CDs], sale(c) == 3)) ::: (B)\nis_valid(Exists([c:CDs], sale(c) == 4)) ::: (C)\nis_valid(Exists([c:CDs], sale(c) == 5)) ::: (D)\nis_valid(Exists([c:CDs], sale(c) == 6)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may vary."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_10",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "D",
    "options": [
      "A) Neither type of opera and neither type of rap is on sale.",
      "B) Neither type of jazz and neither type of opera is on sale.",
      "C) Neither type of opera and neither type of soul is on sale.",
      "D) Neither type of jazz and neither type of soul is on sale.",
      "E) Neither type of jazz and neither type of rap is on sale."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.\nQuestion:\nWhich one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nCDs = EnumSort([new_pop, used_pop, new_jazz, used_jazz, new_opera, used_opera, new_rap, used_rap, new_soul, used_soul])\nsale = Function([CDs] -> [bool])\n\n# Constraints\nForAll([c:CDs], sale(c) == False) ::: none of the CDs are on sale\nForAll([c:CDs], sale(c) == True) ::: used pop is on sale\nForAll([c:CDs], sale(c) == True) ::: new opera is not on sale\nForAll([c:CDs], And(sale(c), sale(c + 1))) ::: if both types of pop are on sale, then all soul is\nForAll([c:CDs], And(sale(c), sale(c + 2))) ::: if both types of jazz are on sale, then no rap is\nForAll([c:CDs], Not(And(sale(c), sale(c + 3)))) ::: neither type of jazz is on sale\nForAll([c:CDs], And(sale(c), sale(c + 4))) ::: if either type of rap is on sale, then no soul is\nForAll([c:CDs], Not(And(sale(c), sale(c + 5)))) ::: neither type of rap is on sale\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_valid(ForAll([c:CDs], sale(c) == False)) ::: (A)\nis_valid(ForAll([c:CDs], sale(c) == True)) ::: (B)\nis_valid(ForAll([c:CDs], sale(c) == True) && sale(c + 1)) ::: (C)\nis_valid(ForAll([c:CDs], sale(c) == True) && sale(c + 2)) ::: (D)\nis_valid(ForAll([c:CDs], sale(c) == True) && sale(c + 3)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may vary."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_11",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "If neither type of jazz is on sale, then each of the following must be true EXCEPT:",
    "answer": "A",
    "options": [
      "A) Used opera is on sale.",
      "B) New rap is not on sale.",
      "C) Used rap is not on sale.",
      "D) New soul is on sale.",
      "E) Used soul is on sale."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.\nQuestion:\nIf neither type of jazz is on sale, then each of the following must be true EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\nCDs = EnumSort([new_pop, used_pop, new_jazz, used_jazz, new_opera, used_opera, new_rap, used_rap, new_soul, used_soul])\nsale = Function([CDs] -> [bool])\n\n# Constraints\nForAll([c:CDs], sale(c) == False) ::: none of the CDs are on sale\nAnd(sale(used_pop), sale(new_pop)) ::: used pop is on sale if new pop is on sale\nAnd(sale(used_jazz), sale(new_jazz)) ::: used jazz is on sale if new jazz is on sale\nAnd(sale(used_rap), sale(new_rap)) ::: used rap is on sale if new rap is on sale\nAnd(sale(used_soul), sale(new_soul)) ::: used soul is on sale if new soul is on sale\n\n# Options\nQuestion ::: ::: If neither type of jazz is on sale, then each of the following must be true EXCEPT:\nis_sat(ForAll([c:CDs], sale(c) == False) == ForAll([c:CDs], sale(c) == True)) ::: (A)\nis_sat(ForAll([c:CDs], sale(c) == True) == ForAll([c:CDs], sale(c) == False)) ::: (B)\nis_sat(ForAll([c:CDs], sale(c) == True) == ForAll([c:CDs], sale(c) == True)) ::: (C)\nis_sat(ForAll([c:CDs], sale(c) == False) == ForAll([c:CDs], sale(c) == False)) ::: (D)\nis_sat(ForAll([c:CDs], sale(c) == False) == ForAll([c:CDs], sale(c) == True)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_12",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "If new soul is the only type of new CD on sale, then which one of the following CANNOT be true?",
    "answer": "A",
    "options": [
      "A) Used jazz is not on sale.",
      "B) Used opera is not on sale.",
      "C) Used rap is not on sale.",
      "D) Used soul is on sale.",
      "E) Used soul is not on sale."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.\nQuestion:\nIf new soul is the only type of new CD on sale, then which one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nCDs = EnumSort([new, used, jazz, opera, pop, rap, soul])\nsale = Function([CDs] -> [bool])\n\n# Constraints\nForAll([c:CDs], sale(c) >= 1) ::: each CD is on sale\nAnd(sale(used, pop), Count([c:CDs], And(c == pop, sale(c))) == 2) ::: used pop is on sale\nAnd(sale(jazz), Not(sale(rap))) ::: if neither type of jazz is on sale, then new pop is on sale\nAnd(sale(rap), Not(sale(soul))) ::: if either type of rap is on sale, then no soul is on sale\n\n# Options\nQuestion ::: Which one of the following CANNOT be true if new soul is the only type of new CD on sale?\nis_valid(Not(sale(jazz))) ::: (A)\nis_valid(Not(sale(rap))) ::: (B)\nis_valid(Not(sale(soul))) ::: (C)\nis_valid(sale(used, pop)) ::: (D)\nis_valid(sale(new, pop)) ::: (E)\n\n------\n\nPlease provide the code for each problem, including the declarations, constraints, and options."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_13",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "If exactly four of the five types of used CDs are the only CDs on sale, then which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) Used jazz is not on sale.",
      "B) Used opera is not on sale.",
      "C) Used rap is not on sale.",
      "D) Neither type of jazz is on sale.",
      "E) Neither type of rap and neither type of soul is on sale."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.\nQuestion:\nIf exactly four of the five types of used CDs are the only CDs on sale, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nCDs = EnumSort([new_jazz, new_opera, new_pop, used_jazz, used_pop, used_rap, used_soul])\nsale = Function([CDs] -> [bool])\n\n# Constraints\nForAll([c:CDs], Count([d:CDs], And(c == d, sale(d))) >= 1) ::: each CD is on sale\nAnd(sale(used_pop), Count([c:CDs], And(c == used_pop, sale(c))) == 2) ::: used pop is on sale\nAnd(sale(new_opera), Not(sale(used_jazz))) ::: new opera is not on sale if neither type of jazz is on sale\nAnd(sale(used_jazz), Not(sale(new_pop))) ::: neither type of jazz is on sale if new pop is on sale\nAnd(sale(used_rap), Not(sale(used_soul))) ::: neither type of rap is on sale if used soul is on sale\n\n# Options\nQuestion ::: Which one of the following could be true if exactly four of the five types of used CDs are the only CDs on sale?\nis_valid(Exists([c:CDs], And(c == used_pop, sale(c)))) ::: (A)\nis_valid(Exists([c:CDs], And(c == used_jazz, sale(c)))) ::: (B)\nis_valid(Exists([c:CDs], And(c == used_rap, sale(c)))) ::: (C)\nis_valid(Exists([c:CDs], And(c == used_soul, sale(c)))) ::: (D)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may vary."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_3_14",
    "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
    "question": "Which one of the following CANNOT be true of the week's tour schedule?",
    "answer": "C",
    "options": [
      "A) The division that is toured on Monday is also toured on Tuesday.",
      "B) The division that is toured on Monday is also toured on Friday.",
      "C) The division that is toured on Tuesday is also toured on Thursday.",
      "D) The division that is toured on Wednesday is also toured on Friday.",
      "E) The division that is toured on Thursday is also toured on Friday."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nDuring a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.\nQuestion:\nWhich one of the following CANNOT be true of the week's tour schedule?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\ndivisions = EnumSort([Operations, Production, Sales])\ntours = EnumSort([1, 2, 3, 4, 5])\nweek = Function([days] -> [divisions, tours])\n\n# Constraints\nForAll([d:days], Count([t:tours], And(t == d, d != Monday)) >= 1) ::: each day has at least one tour\nAnd(week(Monday) == [Operations, [1]]) ::: The Operations division is toured on Monday\nAnd(week(Wednesday) == [Production, [2]]) ::: The Production division is not toured on Wednesday\nAnd(week(Thursday) == [Sales, [3]]) ::: The Sales division is toured on two consecutive days\nOr(week(Thursday) == [Operations, [4]]) ::: If the Operations division is toured on Thursday, then the Production division is toured on Friday\nOr(week(Friday) == [Sales, [5]]) ::: The Sales division is toured on two consecutive days, and on no other days\n\n# Options\nQuestion ::: Which one of the following CANNOT be true of the week's tour schedule?\nis_valid(Exists([t:tours], And(t == Thursday, week(Thursday) != [Operations, [4]]))) ::: (A)\nis_valid(Exists([t:tours], And(t == Wednesday, week(Wednesday) == [Production, [2]]))) ::: (B)\nis_valid(Exists([t:tours], And(t == Friday, week(Friday) == [Sales, [5]]))) ::: (C)\nis_valid(Exists([t:tours], And(t == Thursday, week(Thursday) == [Operations, [4]]))) ::: (D)\nis_valid(Exists([t:tours], And(t == Monday, week(Monday) == [Operations, [1]]))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_3_15",
    "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
    "question": "If in addition to the Sales division one other division is toured on two consecutive days, then it could be true of the week's tour schedule both that the",
    "answer": "B",
    "options": [
      "A) Production division is toured on Monday and that the Operations division is toured on Thursday",
      "B) Production division is toured on Tuesday and that the Sales division is toured on Wednesday",
      "C) Operations division is toured on Tuesday and that the Production division is toured on Friday",
      "D) Sales division is toured on Monday and that the Operations division is toured on Friday",
      "E) Sales division is toured on Wednesday and that the Production division is toured on Friday"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nDuring a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.\nQuestion:\nIf in addition to the Sales division one other division is toured on two consecutive days, then it could be true of the week's tour schedule both that the\nChoices:\n[[CHOICES]]\n###\n# Declarations\ndivisions = EnumSort([Operations, Production, Sales])\ntours = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\ntour_days = EnumSort([day:tours | day in [Monday, Tuesday, Wednesday, Thursday, Friday]])\ntour_divisions = Function([day:tour_days] -> [divisions | [division for division in divisions if day in [division.start, division.end]]]))\n\n# Constraints\nForAll([day:tour_days], Count([division:divisions | division in tour_divisions(day)], day in [division.start, division.end])) ::: Each division is toured at least once\nAnd(tour_divisions(Monday) != [], Not(tour_divisions(Tuesday))) ::: The Operations division is not toured on Monday\nAnd(tour_divisions(Wednesday) != [], Not(tour_divisions(Thursday))) ::: The Production division is not toured on Wednesday\nAnd(tour_divisions(Thursday) != [], Not(tour_divisions(Friday))) ::: The Sales division is toured on two consecutive days, and on no other days\nIf tour_divisions(Thursday) ::: The Production division is toured on Friday\n\n# Options\nQuestion ::: If in addition to the Sales division one other division is toured on two consecutive days, then it could be true of the week's tour schedule both that the\nis_sat(ForAll([day:tour_days], tour_divisions(day) == [Sales, division]))) ::: (A)\nis_sat(ForAll([day:tour_days], tour_divisions(day) == [division, Sales])) ::: (B)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_3_16",
    "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
    "question": "If in the week's tour schedule the division that is toured on Tuesday is also toured on Friday, then for which one of the following days must a tour of the Production division be scheduled?",
    "answer": "A",
    "options": [
      "A) Monday",
      "B) Tuesday",
      "C) Wednesday",
      "D) Thursday",
      "E) Friday"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nDuring a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.\nQuestion:\nIf in the week's tour schedule the division that is toured on Tuesday is also toured on Friday, then for which one of the following days must a tour of the Production division be scheduled?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\ndivisions = EnumSort([Operations, Production, Sales])\ntours = EnumSort([1, 2, 3, 4, 5])\nschedule = Function([days, divisions] -> [tours])\n\n# Constraints\nForAll([d:days], Count([t:tours], And(t == d, rep(divisions, d)) >= 1)) ::: each day has at least one tour of each division\nImplies(tours[Monday] == 1, Not(tours[Tuesday] == 1)) ::: The Operations division is not toured on Monday\nImplies(tours[Wednesday] == 2, Not(tours[Thursday] == 1)) ::: The Production division is not toured on Wednesday\nImplies(tours[Thursday] == 3, tours[Friday] == 2) ::: If the Operations division is toured on Thursday, then the Production division is toured on Friday\n\n# Options\nQuestion ::: Which one of the following days must a tour of the Production division be scheduled?\nis_valid(Exists([t:tours], And(t == Tuesday, rep(divisions, t) == [Production]))) ::: (A)\nis_valid(Exists([t:tours], And(t == Wednesday, rep(divisions, t) == [Production]))) ::: (B)\nis_valid(Exists([t:tours], And(t == Thursday, rep(divisions, t) == [Production]))) ::: (C)\nis_valid(Exists([t:tours], And(t == Friday, rep(divisions, t) == [Production]))) ::: (D)\nis_valid(Exists([t:tours], And(t == Tuesday, rep(divisions, t) == [Sales]))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_3_17",
    "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
    "question": "If in the week's tour schedule the division that is toured on Monday is not the division that is toured on Tuesday, then which one of the following could be true of the week's schedule?",
    "answer": "E",
    "options": [
      "A) A tour of the Sales division is scheduled for some day earlier in the week than is any tour of the Production division.",
      "B) A tour of the Operations division is scheduled for some day earlier in the week than is any tour of the Production division.",
      "C) The Sales division is toured on Monday.",
      "D) The Production division is toured on Tuesday.",
      "E) The Operations division is toured on Wednesday."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nDuring a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.\nQuestion:\nIf in the week's tour schedule the division that is toured on Monday is not the division that is toured on Tuesday, then which one of the following could be true of the week's schedule?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ndivisions = EnumSort([Operations, Production, Sales])\ntours = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\ntour_schedule = Function([days:tours] -> [divisions])\n\n# Constraints\nForAll([d:days], Count([d:days], tour_schedule(d) == [divisions]) >= 1) ::: each day has at least one tour\nAnd(tour_schedule(Monday) != Operations, tour_schedule(Tuesday) != Operations) ::: The Operations division is not toured on Monday\nAnd(tour_schedule(Wednesday) != Production, tour_schedule(Thursday) != Production) ::: The Production division is not toured on Wednesday\nAnd(tour_schedule(Thursday) != Sales, tour_schedule(Friday) != Sales) ::: The Sales division is toured on two consecutive days, and on no other days\nIf tour_schedule(Thursday) == Operations, Then tour_schedule(Friday) == Production ::: If the Operations division is toured on Thursday, then the Production division is toured on Friday\n\n# Options\nQuestion ::: Which one of the following could be true of the week's schedule?\nis_valid(ForAll([d:days], tour_schedule(d) == [divisions, Operations, Production, Sales])) ::: (A)\nis_valid(ForAll([d:days], tour_schedule(d) == [divisions, Operations, Sales, Production])) ::: (B)\nis_valid(ForAll([d:days], tour_schedule(d) == [divisions, Production, Operations, Sales])) ::: (C)\nis_valid(ForAll([d:days], tour_schedule(d) == [divisions, Sales, Operations, Production])) ::: (D)\nis_valid(ForAll([d:days], tour_schedule(d) == [divisions, Production, Sales, Operations])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_3_18",
    "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
    "question": "If in the week's tour schedule the division that is toured on Tuesday is also toured on Wednesday, then which one of the following must be true of the week's tour schedule?",
    "answer": "A",
    "options": [
      "A) The Production division is toured on Monday.",
      "B) The Operations division is toured on Tuesday.",
      "C) The Sales division is toured on Wednesday.",
      "D) The Sales division is toured on Thursday.",
      "E) The Production division is toured on Friday."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nDuring a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.\nQuestion:\nIf in the week's tour schedule the division that is toured on Tuesday is also toured on Wednesday, then which one of the following must be true of the week's tour schedule?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ndivisions = EnumSort([Operations, Production, Sales])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\ntours = EnumSort([1, 2, 3, 4, 5])\nweek = Function([days] -> [tours])\n\n# Constraints\nForAll([d:days], Count([t:tours], week(d) == t) >= 5) ::: exactly five tours will be conducted that week\nAnd(week(Monday) != Operations, week(Monday) != Production) ::: The Operations division is not toured on Monday\nAnd(week(Wednesday) != Production, week(Wednesday) != Sales) ::: The Production division is not toured on Wednesday\nOr(week(Thursday) == Operations, week(Friday) == Production) ::: If the Operations division is toured on Thursday, then the Production division is toured on Friday\n\n# Options\nQuestion ::: Which one of the following must be true of the week's tour schedule?\nis_valid(Exists([t:tours], week(t) == [1, 2, 3, 4, 5])) ::: (A)\nis_valid(Exists([t:tours], week(t) == [2, 4, 5])) ::: (B)\nis_valid(Exists([t:tours], week(t) == [3, 5])) ::: (C)\nis_valid(Exists([t:tours], week(t) == [4, 5])) ::: (D)\nis_valid(Exists([t:tours], week(t) == [1, 3, 5])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_4_19",
    "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
    "question": "Which one of the following could be a complete and accurate list of the members of the crew?",
    "answer": "B",
    "options": [
      "A) George, Helena, Inga, Kelly",
      "B) George, Helena, Kelly, Leanda",
      "C) Helena, Inga, Kelly, Olaf",
      "D) Helena, Inga, Maricita, Olaf",
      "E) George, Helena, Leanda, Maricita, Olaf"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.\nQuestion:\nWhich one of the following could be a complete and accurate list of the members of the crew?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nworkers = EnumSort([George, Helena, Inga, Kelly, Leanda, Maricita, Olaf])\ntasks = EnumSort([framing, wallboarding, taping, sanding, priming])\ndays = EnumSort([1, 2, 3])\ninstallation = Function([workers, days] -> [tasks])\n\n# Constraints\nForAll([d:days], ForAll([w:workers], installation(w, d) != installation(w, d + 1))) ::: At least one task is done each day\nAnd(installation(Helena, 1), installation(Helena, 2) == priming) ::: Taping and priming are done on different days\nForAll([w:workers], Count([d:days], installation(w, d) == 1) >= 1) ::: Each crew member does at least one task during the installation, but no more than one task a day\nForAll([d:days], installation(Kelly, d) == framing) ::: Kelly does framing\nForAll([d:days], installation(Leanda, d) == wallboarding) ::: Leanda does wallboarding\nForAll([d:days], installation(Maricita, d) == sanding) ::: Maricita does sanding\nForAll([d:days], installation(Olaf, d) == priming) ::: Olaf does priming\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the members of the crew?\nis_sat(ForAll([w:workers], installation(w, 1) == [George, Helena, Inga, Kelly, Leanda, Maricita, Olaf]))) ::: (A)\nis_sat(ForAll([w:workers], installation(w, 2) == [Helena, Kelly, Leanda, Maricita, Olaf]))) ::: (B)\nis_sat(ForAll([w:workers], installation(w, 3) == [Kelly, Leanda, Maricita, Olaf]))) ::: (C)\nis_sat(ForAll([w:workers], installation(w, 1) == [George, Helena, Inga, Kelly, Leanda, Maricita, Olaf])) ::: (D)\nis_sat(ForAll([w:workers], installation(w, 2) == [Helena, Kelly, Leanda, Maricita, Olaf])) ::: (E)\n\n------\n\nNote: The above code is just an example, and it might not work as-is in your solver. You might need to adjust the constraints and options based on the specific problem you're trying to solve."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_4_20",
    "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
    "question": "If the installation takes three days, and if the same two crew members work on the first and third days, then which one of the following could be the pair of crew members who work on those two days?",
    "answer": "D",
    "options": [
      "A) Helena and Inga",
      "B) Inga and Kelly",
      "C) Inga and Leanda",
      "D) Kelly and Olaf",
      "E) Leanda and Olaf"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.\nQuestion:\nIf the installation takes three days, and if the same two crew members work on the first and third days, then which one of the following could be the pair of crew members who work on those two days?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nworkers = EnumSort([George, Helena, Inga, Kelly, Leanda, Maricita, Olaf])\ntasks = EnumSort([framing, wallboarding, taping, sanding, priming])\ndays = EnumSort([day1, day2, day3])\ninstallation = Function([workers, days] -> [tasks])\n\n# Constraints\nForAll([w:workers], ForAll([d:days], installation(w, d) != installation(w, d + 1))) ::: At least one task is done each day\nAnd(installation(Helena, day1), installation(Helena, day3) == priming) ::: Taping and priming are done on different days\nForAll([w:workers], Count([t:tasks], installation(w, t) == 1) <= 1) ::: Each crew member does at least one task during the installation, but no more than one task a day\nForAll([t:tasks], installation(w, t) == w) ::: Each task is done by exactly one worker, completed the day it is started and before the next task begins\n\n# Options\nQuestion ::: Which one of the following pairs of crew members could work on the first and third days?\nis_valid(Exists([w1:workers, w2:workers], installation(w1, day1) == framing, installation(w2, day3) == priming)) ::: (A)\nis_valid(Exists([w1:workers, w2:workers], installation(w1, day1) == wallboarding, installation(w2, day3) == priming)) ::: (B)\nis_valid(Exists([w1:workers, w2:workers], installation(w1, day1) == sanding, installation(w2, day3) == priming)) ::: (C)\nis_valid(Exists([w1:workers, w2:workers], installation(w1, day1) == taping, installation(w2, day3) == priming)) ::: (D)\nis_valid(Exists([w1:workers, w2:workers], installation(w1, day1) == framing, installation(w2, day3) == wallboarding)) ::: (E)\n\n------\n\nNote: The above code is just an example, and you may need to adjust it according to your specific problem. Also, the `is_sat` function is not a built-in function in Z3, you may need to define it yourself or use a different satisfiability checker."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_4_21",
    "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
    "question": "Each of the following could be a complete and accurate list of the members of the crew EXCEPT:",
    "answer": "A",
    "options": [
      "A) Helena, Inga, Kelly, Maricita",
      "B) Inga, Kelly, Leanda, Olaf",
      "C) George, Helena, Inga, Leanda",
      "D) Inga, Leanda, Maricita, Olaf",
      "E) Kelly, Leanda, Maricita, Olaf"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.\nQuestion:\nEach of the following could be a complete and accurate list of the members of the crew EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\nworkers = EnumSort([George, Helena, Inga, Kelly, Leanda, Maricita, Olaf])\ntasks = EnumSort([framing, wallboarding, taping, sanding, priming])\ndays = EnumSort([1, 2, 3])\ninstallation = Function([workers, days] -> [tasks])\n\n# Constraints\nForAll([w:workers], ForAll([d:days], installation(w, d) != installation(w, d + 1))) ::: At least one task is done each day\nForAll([w:workers], ForAll([d:days], installation(w, d) == installation(w, d + 1))) ::: Taping and priming are done on different days\nForAll([w:workers], Count([t:tasks], installation(w, t) == 1) <= 1) ::: Each crew member does at least one task during the installation, but no more than one task a day\nForAll([t:tasks], installation(w, t) == w) ::: Each task is done by exactly one worker, completed the day it is started and before the next task begins\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the members of the crew?\nis_sat(ForAll([w:workers], installation(w, days) == [George, Helena, Inga, Kelly, Leanda, Maricita, Olaf]))) ::: (A)\nis_sat(ForAll([w:workers], installation(w, days) == [George, Helena, Inga, Kelly, Leanda, Maricita, Olaf, Maricita])) ::: (B)\nis_sat(ForAll([w:workers], installation(w, days) == [George, Helena, Inga, Kelly, Leanda, Olaf, Maricita])) ::: (C)\nis_sat(ForAll([w:workers], installation(w, days) == [George, Helena, Inga, Kelly, Leanda, Olaf])) ::: (D)\nis_sat(ForAll([w:workers], installation(w, days) == [George, Helena, Inga, Kelly, Leanda, Maricita])) ::: (E)\n\n------\n\nNote: The above code is just an example, and you may need to adjust it to fit your specific problem. Additionally, the `is_sat` function is not a built-in function in Prolog, but you can define it yourself as a helper function."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_4_22",
    "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
    "question": "If the installation takes three days, and if the sanding is done on the third day, then which one of the following could be a list of all the crew members who work on the second day?",
    "answer": "E",
    "options": [
      "A) Inga",
      "B) Kelly",
      "C) Olaf",
      "D) George and Helena",
      "E) Leanda and Olaf"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.\nQuestion:\nIf the installation takes three days, and if the sanding is done on the third day, then which one of the following could be a list of all the crew members who work on the second day?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nworkers = EnumSort([George, Helena, Inga, Kelly, Leanda, Maricita, Olaf])\ntasks = EnumSort([framing, wallboarding, taping, sanding, priming])\ndays = EnumSort([1, 2, 3])\ninstallation = Function([days] -> [List(workers)])\n\n# Constraints\nForAll([d:days], installation(d) == [George, Helena, Inga, Kelly, Leanda]) ::: At least one task is done each day\nAnd(installation(2) == [Helena, Kelly], installation(3) == [Inga, Maricita, Olaf]) ::: Taping and priming are done on different days\nForAll([w:workers], Count([t:tasks], installation(d) == [w, t]) <= 1) ::: Each crew member does at least one task during the installation, but no more than one task a day\nForAll([t:tasks], Or(installation(d) == [t, w], installation(d) == [w, t])) ::: Each task is done by exactly one worker, completed the day it is started and before the next task begins\n\n# Options\nQuestion ::: Which one of the following could be a list of all the crew members who work on the second day?\nis_valid(ForAll([w:workers], installation(2) == [w, Helena])) ::: (A)\nis_valid(ForAll([w:workers], installation(2) == [w, Kelly])) ::: (B)\nis_valid(ForAll([w:workers], installation(2) == [w, Inga])) ::: (C)\nis_valid(ForAll([w:workers], installation(2) == [w, Maricita])) ::: (D)\nis_valid(ForAll([w:workers], installation(2) == [w, Olaf])) ::: (E)\n\n------\n\nNote: The above code is just an example, and you may need to adjust it to fit your specific problem. Additionally, the `is_valid` function is not a standard part of Z3, but you can define it yourself if you want to check the validity of a given answer."
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_4_23",
    "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
    "question": "Which one of the following could be a pair of members of the crew both of whom work on the same days as each other and each of whom perform two tasks?",
    "answer": "D",
    "options": [
      "A) George and Maricita",
      "B) Helena and Kelly",
      "C) Inga and Leanda",
      "D) Kelly and Leanda",
      "E) Leanda and Olaf"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.\nQuestion:\nWhich one of the following could be a pair of members of the crew both of whom work on the same days as each other and each of whom perform two tasks?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nworkers = EnumSort([George, Helena, Inga, Kelly, Leanda, Maricita, Olaf])\ntasks = EnumSort([framing, wallboarding, taping, sanding, priming])\ndays = EnumSort([day1, day2, day3])\ninstallation = Function([workers, days] -> [tasks])\n\n# Constraints\nForAll([w:workers], ForAll([d:days], installation(w, d) >= 1)) ::: each worker completes at least one task during the installation\nAnd(installation(Helena, day2), installation(Helena, day3)) ::: taping and priming are done on different days\nForAll([w:workers], Count([t:tasks], installation(w, t) == 2)) ::: each worker does at least one task during the installation, but no more than one task a day\nForAll([t:tasks], Implies(installation(w, t), Not(installation(w, t')))) ::: each task is done by exactly one worker, completed the day it is started and before the next task begins\n\n# Options\nQuestion ::: Which one of the following could be a pair of members of the crew both of whom work on the same days as each other and each of whom perform two tasks?\nis_sat(ForAll([w:workers], ForAll([d:days], installation(w, d) == installation(Kelly, d))))) ::: (A)\nis_sat(ForAll([w:workers], ForAll([d:days], installation(w, d) == installation(Leanda, d))))) ::: (B)\nis_sat(ForAll([w:workers], ForAll([d:days], installation(w, d) == installation(Maricita, d))))) ::: (C)\nis_sat(ForAll([w:workers], ForAll([d:days], installation(w, d) == installation(Olaf, d))))) ::: (D)\nis_sat(ForAll([w:workers], ForAll([d:days], installation(w, d) == installation(Inga, d))))) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, it returns `True` if the given formula is satisfiable (i.e., there exists an assignment of values to the variables that makes the formula true), and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_1",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "Which one of the following could be an accurate matching of the hangers to the fabrics of the dresses that hang on them?",
    "answer": "A",
    "options": [
      "A) 1: wool; 2: gauze; 3: silk; 4: linen; 5: polyester; 6: rayon",
      "B) 1: rayon; 2: wool; 3: gauze; 4: silk; 5: linen; 6: polyester",
      "C) 1: polyester; 2: gauze; 3: wool; 4: silk; 5: linen; 6: rayon",
      "D) 1: linen; 2: silk; 3: wool; 4: gauze; 5: polyester; 6: rayon",
      "E) 1: gauze; 2: rayon; 3: silk; 4: linen; 5: wool; 6: polyester"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.\nQuestion:\nWhich one of the following could be an accurate matching of the hangers to the fabrics of the dresses that hang on them?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nhangers = EnumSort([1, 2, 3, 4, 5, 6])\ndresses = EnumSort([gauze, linen, polyester, rayon, silk, wool])\nhangs = Function([h:hangers, d:dresses] -> [bool])\n\n# Constraints\nForAll([h:hangers], Count([d:dresses], hangs(h, d))) >= 1) ::: each hanger hangs at least one dress\nAnd(hangs(1, gauze), hangs(6, rayon)) ::: The gauze dress is on a lower-numbered hanger than the polyester dress\nAnd(hangs(1, rayon), hangs(6, silk)) ::: The rayon dress is on hanger 1 or hanger 6\nOr(hangs(3, wool), hangs(3, silk)) ::: Either the wool dress or the silk dress is on hanger 3\nImplies(hangs(4, linen), hangs(5, silk)) ::: The linen dress hangs immediately to the right of the silk dress\n\n# Options\nQuestion ::: Which one of the following could be an accurate matching of the hangers to the fabrics of the dresses that hang on them?\nis_sat(ForAll([h:hangers], hangs(h, gauze) == hangs(h, linen))) ::: (A)\nis_sat(ForAll([h:hangers], hangs(h, linen) == hangs(h, silk))) ::: (B)\nis_sat(ForAll([h:hangers], hangs(h, polyester) == hangs(h, wool))) ::: (C)\nis_sat(ForAll([h:hangers], hangs(h, rayon) == hangs(h, silk))) ::: (D)\nis_sat(ForAll([h:hangers], hangs(h, silk) == hangs(h, wool))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_2",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "If both the silk dress and the gauze dress are on odd-numbered hangers, then which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) The polyester dress is on hanger 1.",
      "B) The wool dress is on hanger 2.",
      "C) The polyester dress is on hanger 4.",
      "D) The linen dress is on hanger 5.",
      "E) The wool dress is on hanger 6."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.\nQuestion:\nIf both the silk dress and the gauze dress are on odd-numbered hangers, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nhangers = EnumSort([1, 2, 3, 4, 5, 6])\ndresses = EnumSort([gauze, linen, polyester, rayon, silk, wool])\nhangs = Function([h:hangers, d:dresses] -> [bool])\n\n# Constraints\nForAll([h:hangers], Count([d:dresses], hangs(h, d))) >= 1) ::: each hanger hangs at least one dress\nAnd(hangs(1, gauze), hangs(3, silk)) ::: The gauze dress is on a lower-numbered hanger than the silk dress\nAnd(hangs(6, rayon), hangs(1, linen)) ::: The rayon dress is on hanger 6 or hanger 1\nOr(hangs(2, polyester), hangs(4, wool)) ::: Either the wool dress or the polyester dress is on hanger 2 or hanger 4\nImplies(hangs(3, silk), hangs(5, rayon)) ::: The silk dress hangs immediately to the right of the rayon dress\n\n# Options\nQuestion ::: Which one of the following could be true if both the silk dress and the gauze dress are on odd-numbered hangers?\nis_valid(ForAll([h:hangers], hangs(h, silk) == hangs(h, gauze))) ::: (A)\nis_valid(ForAll([h:hangers], hangs(h, silk) == hangs(h, rayon))) ::: (B)\nis_valid(ForAll([h:hangers], hangs(h, silk) == hangs(h, wool))) ::: (C)\nis_valid(ForAll([h:hangers], hangs(h, silk) == hangs(h, polyester))) ::: (D)\nis_valid(ForAll([h:hangers], hangs(h, silk) == hangs(h, linen))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_3",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "If the silk dress is on an even-numbered hanger, which one of the following could be on the hanger immediately to its left?",
    "answer": "E",
    "options": [
      "A) the gauze dress",
      "B) the linen dress",
      "C) the polyester dress",
      "D) the rayon dress",
      "E) the wool dress"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.\nQuestion:\nIf the silk dress is on an even-numbered hanger, which one of the following could be on the hanger immediately to its left?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nhangers = EnumSort([1, 2, 3, 4, 5, 6])\ndresses = EnumSort([gauze, linen, polyester, rayon, silk, wool])\nhangs = Function([h:hangers, d:dresses] -> [bool])\n\n# Constraints\nForAll([h:hangers], Count([d:dresses], hangs(h, d))) >= 1) ::: each hanger hangs at least one dress\nAnd(hangs(1, gauze), Count([t:dresses], And(t != gauze, hangs(t, d))) == 5) ::: The gauze dress is on a lower-numbered hanger than the polyester dress\nAnd(hangs(6, rayon), Count([t:dresses], And(t != rayon, hangs(t, d))) == 1) ::: The rayon dress is on hanger 1 or hanger 6\nOr(hangs(3, wool), hangs(3, silk)) ::: Either the wool dress or the silk dress is on hanger 3\nImplies(hangs(4, silk), hangs(5, linen)) ::: The linen dress hangs immediately to the right of the silk dress\n\n# Options\nQuestion ::: Which one of the following could be on the hanger immediately to the left of the silk dress if it is on an even-numbered hanger?\nis_valid(Exists([h:hangers], hangs(h, silk) == 4)) ::: (A)\nis_valid(Exists([h:hangers], hangs(h, silk) == 5)) ::: (B)\nis_valid(Exists([h:hangers], hangs(h, silk) == 6)) ::: (C)\nis_valid(Exists([h:hangers], hangs(h, silk) == 3)) ::: (D)\nis_valid(Exists([h:hangers], hangs(h, silk) == 2)) ::: (E)\n\n------\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_4",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "If the polyester dress is on hanger 2, then which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) The silk dress is on hanger 1.",
      "B) The wool dress is on hanger 3.",
      "C) The linen dress is on hanger 4.",
      "D) The linen dress is on hanger 5.",
      "E) The rayon dress is on hanger 6."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.\nQuestion:\nIf the polyester dress is on hanger 2, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nhangers = EnumSort([1, 2, 3, 4, 5, 6])\ndresses = EnumSort([gauze, linen, polyester, rayon, silk, wool])\nhangs = Function([h:hangers, d:dresses] -> [bool])\n\n# Constraints\nForAll([h:hangers], Count([d:dresses], hangs(h, d))) >= 1) ::: each hanger hangs at least one dress\nAnd(hangs(2, polyester), Count([t:hangers], And(t != 2, hangs(t, polyester))) == 1) ::: The polyester dress is on a lower-numbered hanger than the polyester dress\nOr(hangs(1, rayon), hangs(6, rayon)) ::: The rayon dress is on hanger 1 or hanger 6\nAnd(hangs(3, wool), Or(hangs(3, silk), hangs(3, wool))) ::: Either the wool dress or the silk dress is on hanger 3\nImplies(hangs(4, linen), hangs(5, silk)) ::: The linen dress hangs immediately to the right of the silk dress\n\n# Options\nQuestion ::: Which one of the following must be true if the polyester dress is on hanger 2?\nis_valid(ForAll([h:hangers], hangs(h, polyester) == hangs(h, rayon))) ::: (A)\nis_valid(ForAll([h:hangers], hangs(h, polyester) == hangs(h, silk))) ::: (B)\nis_valid(ForAll([h:hangers], hangs(h, polyester) == hangs(h, wool))) ::: (C)\nis_valid(ForAll([h:hangers], hangs(h, polyester) == hangs(h, linen))) ::: (D)\nis_valid(ForAll([h:hangers], hangs(h, polyester) == hangs(h, silk))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_5",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "B",
    "options": [
      "A) The linen dress hangs immediately next to the gauze dress.",
      "B) The polyester dress hangs immediately to the right of the rayon dress.",
      "C) The rayon dress hangs immediately to the left of the wool dress.",
      "D) The silk dress is on a lower-numbered hanger than the gauze dress.",
      "E) The wool dress is on a higher-numbered hanger than the rayon dress."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.\nQuestion:\nWhich one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nhangers = EnumSort([1, 2, 3, 4, 5, 6])\ndresses = EnumSort([gauze, linen, polyester, rayon, silk, wool])\nhangs = Function([h:hangers, d:dresses] -> [bool])\n\n# Constraints\nForAll([h:hangers], Count([d:dresses], hangs(h, d))) >= 1) ::: each hanger hangs at least one dress\nAnd(hangs(1, gauze), hangs(6, rayon)) ::: The rayon dress is on hanger 1 or hanger 6\nOr(hangs(3, wool), hangs(3, silk)) ::: Either the wool dress or the silk dress is on hanger 3\nImplies(hangs(4, linen), hangs(5, silk)) ::: The linen dress hangs immediately to the right of the silk dress\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_valid(ForAll([h:hangers], Not(hangs(h, dresses[0])))) ::: (A)\nis_valid(ForAll([h:hangers], Not(hangs(h, dresses[5])))) ::: (B)\nis_valid(ForAll([h:hangers], Not(hangs(h, dresses[6])))) ::: (C)\nis_valid(ForAll([h:hangers], Not(hangs(h, dresses[3])))) ::: (D)\nis_valid(ForAll([h:hangers], Not(hangs(h, dresses[4])))) ::: (E)\n\n------\n\nNote: The problem and question are given in a logical form, which is a standard way of representing problems in logic programming. The task is to translate the problem and question into a logic program, consisting of three parts: Declarations, Constraints, and Options.\n\nDeclarations: This part of the program defines the variables and functions used in the problem. In this case, we have three variables (Vladimir, Wendy, and Xena) and two functions (eats and repairs).\n\nConstraints: This part of the program defines the constraints that must be satisfied by the variables and functions. In this case, we have six constraints that define the relationships between the variables and functions.\n\nOptions: This part of the program defines the options that are available in the question. In this case, we have six options, each of which is a logical formula that must be evaluated to determine whether it is valid.\n\nThe goal is to write a logic program that takes the problem and question as input and outputs the valid options."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_6",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "Which one of the following CANNOT hang immediately next to the rayon dress?",
    "answer": "D",
    "options": [
      "A) the gauze dress",
      "B) the linen dress",
      "C) the polyester dress",
      "D) the silk dress",
      "E) the wool dress"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.\nQuestion:\nWhich one of the following CANNOT hang immediately next to the rayon dress?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nhangers = EnumSort([1, 2, 3, 4, 5, 6])\ndresses = EnumSort([gauze, linen, polyester, rayon, silk, wool])\nhangs = Function([h:hangers, d:dresses] -> [bool])\n\n# Constraints\nForAll([h:hangers], Count([d:dresses], hangs(h, d))) >= 1) ::: each hanger hangs at least one dress\nAnd(hangs(1, rayon), Count([t:dresses], And(t != rayon, hangs(t, rayon))) == 1) ::: The rayon dress is on hanger 1 or hanger 6\nAnd(hangs(3, silk), Count([t:dresses], And(t != silk, hangs(t, silk))) == 1) ::: Either the wool dress or the silk dress is on hanger 3\nImplies(hangs(4, silk), hangs(5, silk)) ::: The silk dress hangs immediately to the right of the silk dress\n\n# Options\nQuestion ::: Which one of the following CANNOT hang immediately next to the rayon dress?\nis_valid(Exists([h:hangers], hangs(h, rayon) == hangs(h, silk))) ::: (A)\nis_valid(Exists([h:hangers], hangs(h, rayon) == hangs(h, wool))) ::: (B)\nis_valid(Exists([h:hangers], hangs(h, rayon) == hangs(h, linen))) ::: (C)\nis_valid(Exists([h:hangers], hangs(h, rayon) == hangs(h, gauze))) ::: (D)\nis_valid(Exists([h:hangers], hangs(h, rayon) == hangs(h, polyester))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_7",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "Assume that the original condition that the linen dress hangs immediately to the right of the silk dress is replaced by the condition that the wool dress hangs immediately to the right of the silk dress. If all the other initial conditions remain in effect, which one of the following must be false?",
    "answer": "D",
    "options": [
      "A) The linen dress is on hanger 1.",
      "B) The gauze dress is on hanger 2.",
      "C) The wool dress is on hanger 4.",
      "D) The silk dress is on hanger 5.",
      "E) The polyester dress is on hanger 6."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.\nQuestion:\nAssume that the original condition that the linen dress hangs immediately to the right of the silk dress is replaced by the condition that the wool dress hangs immediately to the right of the silk dress. If all the other initial conditions remain in effect, which one of the following must be false?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nhangers = EnumSort([1, 2, 3, 4, 5, 6])\ndresses = EnumSort([gauze, linen, polyester, rayon, silk, wool])\nhangs = Function([h:hangers, d:dresses] -> [bool])\n\n# Constraints\nForAll([h:hangers], Count([d:dresses], hangs(h, d))) >= 1) ::: each hanger hangs at least one dress\nAnd(hangs(1, gauze), hangs(6, wool)) ::: The gauze dress is on a lower-numbered hanger than the wool dress\nAnd(hangs(2, rayon), hangs(5, silk)) ::: The rayon dress is on hanger 2 or hanger 5\nOr(hangs(3, silk), hangs(4, wool)) ::: Either the wool dress or the silk dress is on hanger 3\nOr(hangs(3, silk), hangs(6, linen)) ::: The silk dress hangs immediately to the right of the linen dress\n\n# Options\nQuestion ::: Which one of the following must be false?\nis_valid(ForAll([h:hangers], hangs(h, dresses[1]) == False)) ::: (A)\nis_valid(ForAll([h:hangers], hangs(h, dresses[2]) == False)) ::: (B)\nis_valid(ForAll([h:hangers], hangs(h, dresses[3]) == False)) ::: (C)\nis_valid(ForAll([h:hangers], hangs(h, dresses[4]) == False)) ::: (D)\nis_valid(ForAll([h:hangers], hangs(h, dresses[5]) == False)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may vary."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_2_8",
    "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
    "question": "Which one of the following could be an accurate matching of the four songs performed at the festival with the instruments on which they are performed, listed in order from the first song performed to the last?",
    "answer": "B",
    "options": [
      "A) \"Night's All Right\": guitar;\" Question Man\": keyboard; \"Sammy\": guitar;\" Rhino Rock\": flute",
      "B) \"Question Man\": guitar;\" Rhino Rock\": harmonica; \"Sammy\": keyboard;\" Night's All Right\": flute",
      "C) \"Rhino Rock\": flute;\" Question Man\": keyboard; \"Night's All Right\": harmonica;\" Sammy\": guitar",
      "D) \"Sammy\": harmonica;\" Night's All Right\": guitar; \"Question Man\": keyboard;\" Rhino Rock\": flute",
      "E) \"Sammy\": harmonica;\" Rhino Rock\": guitar; \"Question Man\": flute;\" Night's All Right\": keyboard"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAt a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"\nQuestion:\nWhich one of the following could be an accurate matching of the four songs performed at the festival with the instruments on which they are performed, listed in order from the first song performed to the last?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nsongs = EnumSort([Night's All Right, Question Man, Rhino Rock, Sammy])\ninstruments = EnumSort([flute, guitar, harmonica, keyboard])\nmatch = Function([songs, instruments] -> [bool])\n\n# Constraints\nForAll([s:songs], Count([i:instruments], match(s, i)) >= 1) ::: each song is performed on at least one instrument\nImplies(match(Night's All Right, flute), Not(match(Question Man, flute))) ::: The first song performed is not performed on the flute\nImplies(match(Sammy, keyboard), Not(match(Rhino Rock, keyboard))) ::: If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica\nImplies(match(Question Man, keyboard), Not(match(Night's All Right, flute))) ::: If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute\nForAll([m:match], Implies(m, Not(m.precededBy(m.followedBy)))) ::: The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right\"\n\n# Options\nQuestion ::: Which one of the following could be an accurate matching of the four songs performed at the festival with the instruments on which they are performed, listed in order from the first song performed to the last?\nis_valid(match(Night's All Right, flute)) ::: (A)\nis_valid(match(Question Man, guitar)) ::: (B)\nis_valid(match(Rhino Rock, harmonica)) ::: (C)\nis_valid(match(Sammy, keyboard)) ::: (D)\nis_valid(match(Question Man, keyboard)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_2_9",
    "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
    "question": "Which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) \"Question Man\" immediately follows the song performed on the keyboard.",
      "B) \"Night's All Right\" immediately precedes the song performed on the keyboard.",
      "C) \"Question Man\" immediately precedes the song performed on the guitar.",
      "D) \"Rhino Rock\" immediately precedes the song performed on the harmonica.",
      "E) \"Sammy\" immediately precedes the song performed on the guitar."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAt a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"\nQuestion:\nWhich one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nsongs = EnumSort([Night's All Right, Question Man, Rhino Rock, Sammy])\ninstruments = EnumSort([flute, guitar, harmonica, keyboard])\nperformances = Function([songs, instruments] -> [bool])\n\n# Constraints\nForAll([s:songs], Count([i:instruments], s == performances(i, s))) >= 1) ::: each song is performed on at least one of the following four instruments\nAnd(performances(keyboard, Sammy), Count([t:instruments], And(t != keyboard, performances(t, Sammy))) == 1) ::: If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica\nAnd(performances(keyboard, Question Man), Count([t:instruments], And(t != keyboard, performances(t, Question Man))) == 1) ::: If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_valid(Exists([s:songs], performances(keyboard, s) == True)) ::: (A)\nis_valid(Exists([s:songs], performances(flute, s) == True)) ::: (B)\nis_valid(Exists([s:songs], performances(harmonica, s) == True)) ::: (C)\nis_valid(Exists([s:songs], performances(keyboard, s) == False)) ::: (D)\nis_valid(Exists([s:songs], performances(flute, s) == False)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may have different constraints and options."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_2_10",
    "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
    "question": "Which one of the following CANNOT be true of the song performed on the flute?",
    "answer": "C",
    "options": [
      "A) It immediately precedes \"Question Man.\"",
      "B) It immediately follows \"Question Man.\"",
      "C) It immediately precedes \"Rhino Rock.\"",
      "D) It immediately follows \"Night's All Right.\"",
      "E) It immediately follows \"Sammy.\""
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAt a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"\nQuestion:\nWhich one of the following CANNOT be true of the song performed on the flute?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nsongs = EnumSort([Night's All Right, Question Man, Rhino Rock, Sammy])\ninstruments = EnumSort([flute, guitar, harmonica, keyboard])\nperformances = Function([songs, instruments] -> [bool])\n\n# Constraints\nForAll([s:songs], Count([i:instruments], s == performances(i, s))) >= 1) ::: each song is performed on at least one of the following four instruments\nAnd(performances(keyboard, Sammy), Count([t:instruments], And(t != keyboard, performances(t, Sammy))) == 1) ::: If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica\nAnd(performances(keyboard, Question Man), Count([t:instruments], And(t != keyboard, performances(t, Question Man))) == 1) ::: If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute\n\n# Options\nQuestion ::: Which one of the following CANNOT be true of the song performed on the flute?\nis_valid(Exists([s:songs], performances(flute, s) == Night's All Right)) ::: (A)\nis_valid(Exists([s:songs], performances(flute, s) == Question Man)) ::: (B)\nis_valid(Exists([s:songs], performances(flute, s) == Rhino Rock)) ::: (C)\nis_valid(Exists([s:songs], performances(flute, s) == Sammy)) ::: (D)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may have different constraints and options."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_2_11",
    "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
    "question": "If \"Rhino Rock\" is the second song performed at the festival, then which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) The first song performed is performed on the keyboard.",
      "B) The third song performed is performed on the guitar.",
      "C) The third song performed is performed on the flute.",
      "D) \"Night's All Right\" is performed on the guitar.",
      "E) \"Rhino Rock\" is performed on the guitar."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAt a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"\nQuestion:\nIf \"Rhino Rock\" is the second song performed at the festival, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nsongs = EnumSort([Night's All Right, Question Man, Rhino Rock, Sammy])\ninstruments = EnumSort([flute, guitar, harmonica, keyboard])\nperformances = Function([songs, instruments] -> [bool])\n\n# Constraints\nForAll([s:songs], Count([i:instruments], s == performances(i, s))) >= 1) ::: each song is performed on at least one instrument\nAnd(performances(guitar, Rhino Rock), performances(harmonica, Night's All Right)) ::: If \"Rhino Rock\" is the second song performed, then \"Night's All Right\" is performed on the harmonica\nAnd(performances(keyboard, Question Man), performances(flute, Sammy)) ::: If \"Question Man\" is performed on the keyboard, then \"Sammy\" is performed on the flute\n\n# Options\nQuestion ::: If \"Rhino Rock\" is the second song performed at the festival, then which one of the following could be true?\nis_valid(ForAll([s:songs], performances(guitar, s) == performances(harmonica, s))) ::: (A)\nis_valid(ForAll([s:songs], performances(keyboard, s) == performances(flute, s))) ::: (B)\nis_valid(ForAll([s:songs], performances(harmonica, s) == performances(flute, s))) ::: (C)\nis_valid(ForAll([s:songs], performances(keyboard, s) == performances(guitar, s))) ::: (D)\nis_valid(ForAll([s:songs], performances(flute, s) == performances(harmonica, s))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may have different constraints and options."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_2_12",
    "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
    "question": "If \"Question Man\" is the third song performed at the festival, then each of the following could be true EXCEPT:",
    "answer": "A",
    "options": [
      "A) \"Question Man\" is performed on the guitar.",
      "B) \"Question Man\" is performed on the keyboard.",
      "C) \"Rhino Rock\" is performed on the guitar.",
      "D) \"Sammy\" is performed on the guitar.",
      "E) \"Sammy\" is performed on the harmonica."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAt a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"\nQuestion:\nIf \"Question Man\" is the third song performed at the festival, then each of the following could be true EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\nsongs = EnumSort([Night's All Right, Question Man, Rhino Rock, Sammy])\ninstruments = EnumSort([flute, guitar, harmonica, keyboard])\nperformances = Function([songs, instruments] -> [bool])\n\n# Constraints\nForAll([s:songs], Count([i:instruments], s == i) >= 1) ::: each song is performed on at least one instrument\nAnd(performances(Night's All Right, flute), performances(Rhino Rock, harmonica)) ::: The first song performed is not performed on the flute\nAnd(performances(Question Man, keyboard), performances(Rhino Rock, keyboard)) ::: If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica\nAnd(performances(Question Man, keyboard), performances(Night's All Right, flute)) ::: If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute\n\n# Options\nQuestion ::: If \"Question Man\" is the third song performed at the festival, then each of the following could be true EXCEPT:\nis_valid(ForAll([i:instruments], And(performances(Question Man, i), performances(Rhino Rock, i)) == 1)) ::: (A)\nis_valid(ForAll([i:instruments], And(performances(Question Man, i), performances(Night's All Right, i)) == 1)) ::: (B)\nis_valid(ForAll([i:instruments], And(performances(Question Man, i), performances(Sammy, i)) == 1)) ::: (C)\nis_valid(ForAll([i:instruments], And(performances(Question Man, i), performances(Question Man, i)) == 1)) ::: (D)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may have different constraints and options."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_3_13",
    "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
    "question": "Which one of the following could be a complete and accurate list of the members of the finance committee?",
    "answer": "E",
    "options": [
      "A) Guzman, Hawking, Miyauchi, Wharton",
      "B) Guzman, Lepp, Zhu",
      "C) Hawking, Miyauchi, Zhu",
      "D) Hawking, Upchurch, Wharton, Zhu",
      "E) Miyauchi, Upchurch, Wharton"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.\nQuestion:\nWhich one of the following could be a complete and accurate list of the members of the finance committee?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nboard_of_directors = EnumSort([Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, Zhu])\ncommittees = EnumSort([finance_committee, incentives_committee])\nmembers = Function([board_of_directors], [committee])\n\n# Constraints\nForAll([b:board_of_directors], Implies(members(b), b in finance_committee)) ::: Each of the seven members of the board of directors serves on exactly one of the two committees\nAnd(members(Guzman), members(Hawking)) ::: If Guzman serves on the finance committee, then Hawking serves on the incentives committee\nAnd(members(Lepp), members(Miyauchi), members(Upchurch)) ::: If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee\nForAll([b:board_of_directors], Implies(members(b), b != members(Zhu))) ::: Upchurch serves on a different committee from the one on which Zhu serves\nForAll([b:board_of_directors], Implies(members(b), b != members(Guzman))) ::: Wharton serves on a different committee from the one on which Guzman serves\nIf(members(Zhu), members(Hawking)) ::: If Zhu serves on the finance committee, so does Hawking\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the members of the finance committee?\nis_valid(ForAll([b:board_of_directors], members(b) == [Guzman, Hawking, Lepp])) ::: (A)\nis_valid(ForAll([b:board_of_directors], members(b) == [Hawking, Lepp, Miyauchi])) ::: (B)\nis_valid(ForAll([b:board_of_directors], members(b) == [Miyauchi, Lepp, Upchurch])) ::: (C)\nis_valid(ForAll([b:board_of_directors], members(b) == [Upchurch, Lepp, Zhu])) ::: (D)\nis_valid(ForAll([b:board_of_directors], members(b) == [Zhu, Lepp, Hawking])) ::: (E)\n\n------\n\nNote: The `is_sat` function is used to check the satisfiability of a given formula, i.e., whether the formula is valid or not."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_3_14",
    "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
    "question": "Which one of the following pairs of board members CANNOT both serve on the incentives committee?",
    "answer": "C",
    "options": [
      "A) Guzman and Hawking",
      "B) Guzman and Wharton",
      "C) Hawking and Wharton",
      "D) Miyauchi and Upchurch",
      "E) Miyauchi and Wharton"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.\nQuestion:\nWhich one of the following pairs of board members CANNOT both serve on the incentives committee?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nboard_of_directors = EnumSort([Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, Zhu])\ncommittees = EnumSort([finance, incentives])\nserves = Function([board_of_directors, committees] -> [bool])\n\n# Constraints\nForAll([b:board_of_directors], Count([c:committees], serves(b, c)) >= 1) ::: each board member serves on exactly one of the two committees\nAnd(serves(Guzman, finance), serves(Hawking, incentives)) ::: If Guzman serves on the finance committee, then Hawking serves on the incentives committee\nAnd(serves(Lepp, finance), serves(Miyauchi, incentives), serves(Upchurch, incentives)) ::: If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee\nForAll([b:board_of_directors], Implies(serves(Wharton, c), Not(serves(Guzman, c)))) ::: Wharton serves on a different committee from the one on which Guzman serves\nForAll([b:board_of_directors], Implies(serves(Upchurch, c), Not(serves(Guzman, c))))) ::: Upchurch serves on a different committee from the one on which Guzman serves\nIf(serves(Zhu, finance), serves(Hawking, incentives)) ::: If Zhu serves on the finance committee, so does Hawking\n\n# Options\nQuestion ::: Which one of the following pairs of board members CANNOT both serve on the incentives committee?\nis_sat(ForAll([b:board_of_directors], Not(serves(b, incentives))))) ::: (A)\nis_sat(ForAll([b:board_of_directors], Not(serves(b, finance))))) ::: (B)\nis_sat(ForAll([b:board_of_directors], Not(serves(b, incentives))))) ::: (C)\nis_sat(ForAll([b:board_of_directors], Not(serves(b, finance))))) ::: (D)\nis_sat(ForAll([b:board_of_directors], Not(serves(b, incentives))))) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, it returns `True` if the given formula is satisfiable (i.e., there exists an assignment of values to the variables that makes the formula true), and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_3_15",
    "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
    "question": "What is the maximum number of members on the finance committee?",
    "answer": "C",
    "options": [
      "A) two",
      "B) three",
      "C) four",
      "D) five",
      "E) six"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.\nQuestion:\nWhat is the maximum number of members on the finance committee?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nboard_of_directors = EnumSort([Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, Zhu])\ncommittees = EnumSort([finance_committee, incentives_committee])\nserves = Function([board_of_directors, committees] -> [bool])\n\n# Constraints\nForAll([b:board_of_directors], Count([c:committees], serves(b, c))) >= 1) ::: each board member serves on exactly one of the two committees\nAnd(serves(Guzman, finance_committee), serves(Hawking, incentives_committee)) ::: If Guzman serves on the finance committee, then Hawking serves on the incentives committee\nAnd(serves(Lepp, finance_committee), serves(Miyauchi, incentives_committee), serves(Upchurch, incentives_committee)) ::: If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee\nForAll([b:board_of_directors], Implies(serves(b, finance_committee), Not(serves(b, incentives_committee)))) ::: Wharton serves on a different committee from the one on which Zhu serves\nForAll([b:board_of_directors], Implies(serves(b, finance_committee), Not(serves(b, committees[1])))) ::: Upchurch serves on a different committee from the one on which Guzman serves\nCount([c:committees], serves(Zhu, c)) == 1 ::: If Zhu serves on the finance committee, so does Hawking\n\n# Options\nQuestion ::: What is the maximum number of members on the finance committee?\nis_valid(Max(Count([b:board_of_directors], serves(b, finance_committee)))) ::: (A)\nis_valid(Max(Count([b:board_of_directors], serves(b, incentives_committee)))) ::: (B)\nis_valid(Max(Count([b:board_of_directors], serves(b, finance_committee) == 2))) ::: (C)\nis_valid(Max(Count([b:board_of_directors], serves(b, incentives_committee) == 2))) ::: (D)\nis_valid(Max(Count([b:board_of_directors], serves(b, finance_committee) > 1))) ::: (E)\n\n------\n\nPlease provide the code for each part of the problem, including the declarations, constraints, and options."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_3_16",
    "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
    "question": "If Miyauchi and Wharton both serve on the finance committee, then which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Guzman and Lepp both serve on the finance committee.",
      "B) Guzman and Upchurch both serve on the incentives committee.",
      "C) Hawking and Zhu both serve on the finance committee.",
      "D) Lepp and Upchurch both serve on the incentives committee.",
      "E) Zhu and Upchurch both serve on the finance committee."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.\nQuestion:\nIf Miyauchi and Wharton both serve on the finance committee, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nboard_of_directors = EnumSort([Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, Zhu])\ncommittees = EnumSort([finance, incentives])\nserves = Function([people:board_of_directors, committees:committees] -> [bool])\n\n# Constraints\nForAll([p:people], Count([c:committees], serves(p, c))) >= 1) ::: each board member serves on exactly one of the two committees\nAnd(serves(Guzman, finance), serves(Hawking, incentives)) ::: If Guzman serves on the finance committee, then Hawking serves on the incentives committee\nAnd(serves(Lepp, finance), serves(Miyauchi, incentives), serves(Upchurch, incentives)) ::: If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee\nForAll([p:people], Implies(serves(p, finance), Not(serves(p, incentives)))) ::: Wharton serves on a different committee from the one on which Zhu serves\nForAll([p:people], Implies(serves(p, finance), Not(serves(p, committees[1])))) ::: Upchurch serves on a different committee from the one on which Guzman serves\nIf(serves(Zhu, finance), serves(Hawking, incentives)) ::: If Zhu serves on the finance committee, so does Hawking\n\n# Options\nQuestion ::: ::: If Miyauchi and Wharton both serve on the finance committee, then which one of the following could be true?\nis_sat(ForAll([p:people], serves(p, finance) == serves(Miyauchi, finance))) ::: (A)\nis_sat(ForAll([p:people], serves(p, finance) == serves(Wharton, finance))) ::: (B)\nis_sat(ForAll([p:people], serves(p, finance) == serves(Upchurch, finance))) ::: (C)\nis_sat(ForAll([p:people], serves(p, finance) == serves(Zhu, finance))) ::: (D)\nis_sat(ForAll([p:people], serves(p, finance) == serves(Hawking, incentives))) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, which checks whether the given formula is satisfiable (i.e., whether it is possible to assign values to the variables such that the formula evaluates to `True`)."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_3_17",
    "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
    "question": "If Guzman serves on the incentives committee, then which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) Hawking serves on the finance committee.",
      "B) Lepp serves on the incentives committee.",
      "C) Miyauchi serves on the finance committee.",
      "D) Wharton serves on the incentives committee.",
      "E) Zhu serves on the finance committee."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.\nQuestion:\nIf Guzman serves on the incentives committee, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nboard_of_directors = EnumSort([Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, Zhu])\ncommittees = EnumSort([finance, incentives])\nserves = Function([people:board_of_directors, committees:committees] -> [bool])\n\n# Constraints\nForAll([p:people], Count([c:committees], serves(p, c))) >= 1) ::: each board member serves on exactly one of the two committees\nAnd(serves(Guzman, finance), serves(Hawking, incentives)) ::: If Guzman serves on the incentives committee, then Hawking serves on the finance committee\nAnd(serves(Lepp, finance), serves(Miyauchi, incentives), serves(Upchurch, incentives)) ::: If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee\nForAll([p:people], Implies(serves(p, committees[0]), Not(serves(p, committees[1])))) ::: Each board member serves on exactly one of the two committees\nCount([p:people], serves(Wharton, committees[0])) > Count([p:people], serves(Wharton, committees[1])) ::: Wharton serves on a different committee from the one on which Zhu serves\nForAll([p:people], Implies(serves(p, committees[0]), Not(serves(p, committees[1])))) ::: Upchurch serves on a different committee from the one on which Guzman serves\nIf serves(Zhu, finance), then serves(Hawking, incentives) ::: If Zhu serves on the finance committee, then Hawking serves on the incentives committee\n\n# Options\nQuestion ::: Which one of the following must be true if Guzman serves on the incentives committee?\nis_valid(ForAll([p:people], And(serves(p, finance), serves(Hawking, incentives)))) ::: (A)\nis_valid(ForAll([p:people], And(serves(p, incentives), serves(Hawking, finance)))) ::: (B)\nis_valid(ForAll([p:people], And(serves(p, finance), serves(Zhu, incentives)))) ::: (C)\nis_valid(ForAll([p:people], And(serves(p, incentives), serves(Zhu, finance)))) ::: (D)\nis_valid(ForAll([p:people], And(serves(p, finance), serves(Upchurch, incentives)))) ::: (E)\n\n------\n\nNote: The `is_sat` function is used to check satisfiability of the given constraints. If the constraints are satisfiable, then the `is_sat` function returns `True`, otherwise it returns `False`."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_18",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "Which one of the following could be the order in which four of the people are seated, with no one else seated between them, counting clockwise around the table?",
    "answer": "C",
    "options": [
      "A) George, Peter, Karl, Fiona",
      "B) Harriet, Olivia, Ingrid, Karl",
      "C) Ingrid, Fiona, Peter, Manuel",
      "D) Olivia, Manuel, Karl, George",
      "E) Peter, Harriet, Karl, Fiona"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.\nQuestion:\nWhich one of the following could be the order in which four of the people are seated, with no one else seated between them, counting clockwise around the table?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, Peter])\nseat = Function([people] -> [int])\n\n# Constraints\nForAll([p:people], seat(p) >= 1) ::: each person sits at a unique seat\nAnd(seat(Fiona) == seat(George), seat(Fiona) == 1) ::: Fiona sits directly across from George\nForAll([p:people], Implies(seat(p), Not(seat(Harriet))), seat(p) == 2) ::: Harriet sits immediately next to neither Fiona nor Karl\nForAll([p:people], Implies(seat(p), Not(seat(Ingrid))), seat(p) == 3) ::: Ingrid sits immediately next to, and immediately clockwise from, Olivia\nForAll([p:people], Implies(seat(p), Not(seat(Karl))), seat(p) == 4) ::: Karl sits immediately next to neither Ingrid nor Manuel\nForAll([p:people], Implies(seat(p), Not(seat(Manuel))), seat(p) == 5) ::: Manuel sits immediately next to neither Karl nor Olivia\nForAll([p:people], Implies(seat(p), Not(seat(Olivia))), seat(p) == 6) ::: Olivia sits immediately next to, and immediately clockwise from, Peter\n\n# Options\nQuestion ::: Which one of the following could be the order in which four of the people are seated, with no one else seated between them, counting clockwise around the table?\nis_valid(ForAll([p:people], seat(p) == 1)) ::: (A)\nis_valid(ForAll([p:people], seat(p) == 2)) ::: (B)\nis_valid(ForAll([p:people], seat(p) == 3)) ::: (C)\nis_valid(ForAll([p:people], seat(p) == 4)) ::: (D)\nis_valid(ForAll([p:people], seat(p) == 5)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_19",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "If Harriet and Olivia each sits immediately next to George, then which one of the following could be the two people each of whom sits immediately next to Peter?",
    "answer": "D",
    "options": [
      "A) Fiona and Karl",
      "B) Fiona and Olivia",
      "C) Harriet and Ingrid",
      "D) Harriet and Karl",
      "E) Karl and Manuel"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.\nQuestion:\nIf Harriet and Olivia each sits immediately next to George, then which one of the following could be the two people each of whom sits immediately next to Peter?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, Peter])\nseats = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])\nsit = Function([people, seats] -> [bool])\n\n# Constraints\nForAll([s:seats], Count([p:people], And(sit(p, s), sit(p, s + 1))) >= 1) ::: each person sits in at least one of the seats\nAnd(sit(Fiona, 1), sit(George, 2)) ::: Fiona sits directly across from George\nAnd(sit(Harriet, 3), Not(sit(Harriet, 4))) ::: Harriet sits immediately next to neither Fiona nor Karl\nAnd(sit(Ingrid, 5), sit(Olivia, 6)) ::: Ingrid sits immediately next to, and immediately clockwise from, Olivia\nForAll([s:seats], Implies(sit(Olivia, s), sit(Peter, s + 1))) ::: Olivia and Peter sit in adjacent seats\n\n# Options\nQuestion ::: Which one of the following could be the two people each of whom sits immediately next to Peter?\nis_valid(Exists([s:seats], sit(Olivia, s) == sit(Peter, s + 1))) ::: (A)\nis_valid(Exists([s:seats], sit(Harriet, s) == sit(Peter, s + 1))) ::: (B)\nis_valid(Exists([s:seats], sit(Ingrid, s) == sit(Peter, s + 1))) ::: (C)\nis_valid(Exists([s:seats], sit(Manuel, s) == sit(Peter, s + 1))) ::: (D)\nis_valid(Exists([s:seats], sit(Karl, s) == sit(Peter, s + 1))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_20",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "If George does not sit immediately next to Harriet, then which one of the following could be the two people each of whom sits immediately next to Manuel?",
    "answer": "A",
    "options": [
      "A) Fiona and Harriet",
      "B) Fiona and Peter",
      "C) George and Karl",
      "D) George and Peter",
      "E) Harriet and Peter"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.\nQuestion:\nIf George does not sit immediately next to Harriet, then which one of the following could be the two people each of whom sits immediately next to Manuel?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, Peter])\nseats = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])\ndirectly_across = Function([p1:people, p2:people], [seats | p1 != p2]) ::: Any two of them are said to be sitting directly across from one another\n\n# Constraints\nForAll([p:people], Count([s:seats], directly_across(p, s)) >= 1) ::: each person sits in at least one seat\nAnd(directly_across(Fiona, 1), directly_across(George, 2)) ::: Fiona sits directly across from George\nAnd(directly_across(Harriet, 3), directly_across(Ingrid, 4)) ::: Harriet sits immediately next to neither Fiona nor Karl\nAnd(directly_across(Olivia, 5), directly_across(Ingrid, 6)) ::: Ingrid sits immediately next to, and immediately clockwise from, Olivia\n\n# Options\nQuestion ::: Which one of the following could be the two people each of whom sits immediately next to Manuel?\nis_valid(Exists([s:seats], directly_across(Manuel, s) == [Olivia, Peter]))) ::: (A)\nis_valid(Exists([s:seats], directly_across(Manuel, s) == [Harriet, Karl]))) ::: (B)\nis_valid(Exists([s:seats], directly_across(Manuel, s) == [Ingrid, Peter]))) ::: (C)\nis_valid(Exists([s:seats], directly_across(Manuel, s) == [Olivia, George]))) ::: (D)\nis_valid(Exists([s:seats], directly_across(Manuel, s) == [Harriet, Karl]))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_21",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "If Manuel sits immediately next to Olivia, then which one of the following people must sit immediately next to Fiona?",
    "answer": "C",
    "options": [
      "A) Harriet",
      "B) Ingrid",
      "C) Karl",
      "D) Manuel",
      "E) Peter"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.\nQuestion:\nIf Manuel sits immediately next to Olivia, then which one of the following people must sit immediately next to Fiona?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, Peter])\nseats = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])\nsit = Function([people, seats] -> [bool])\n\n# Constraints\nForAll([s:seats], Count([p:people], And(sit(p, s), sit(p, s + 1))) >= 1) ::: each person sits in at least one of the seats\nAnd(sit(Fiona, 1), sit(George, 2)) ::: Fiona sits directly across from George\nForAll([p:people], Implies(sit(p, 3), Not(sit(p, 4)))) ::: Harriet sits immediately next to neither Fiona nor Karl\nForAll([p:people], Implies(sit(p, 5), Not(sit(p, 6)))) ::: Ingrid sits immediately next to, and immediately clockwise from, Olivia\nForAll([p:people], Implies(sit(p, 7), Not(sit(p, 8)))) ::: Manuel sits immediately next to Olivia\n\n# Options\nQuestion ::: Which one of the following people must sit immediately next to Fiona?\nis_valid(Exists([s:seats], sit(Fiona, s) == sit(Olivia, s))) ::: (A)\nis_valid(Exists([s:seats], sit(Fiona, s) == sit(Peter, s))) ::: (B)\nis_valid(Exists([s:seats], sit(Fiona, s) == sit(Harriet, s))) ::: (C)\nis_valid(Exists([s:seats], sit(Fiona, s) == sit(Ingrid, s))) ::: (D)\nis_valid(Exists([s:seats], sit(Fiona, s) == sit(Karl, s))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_22",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "What is the minimum possible number of people sitting between Ingrid and Manuel, counting clockwise from Ingrid around the table?",
    "answer": "A",
    "options": [
      "A) zero",
      "B) one",
      "C) two",
      "D) three",
      "E) four"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.\nQuestion:\nWhat is the minimum possible number of people sitting between Ingrid and Manuel, counting clockwise from Ingrid around the table?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, Peter])\nseats = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])\ndirectly_across = Function([p1:people, p2:people] -> [Count([s:seats], p1 == s[1] && p2 == s[3])])\n\n# Constraints\nForAll([p:people], Count([s:seats], directly_across(p, p[1])) == 1) ::: each person sits directly across from exactly one other person\nForAll([p:people], Implies(directly_across(Fiona, p), Not(directly_across(George, p)))) ::: Fiona sits directly across from George\nForAll([p:people], Implies(directly_across(Harriet, p), Not(directly_across(Karl, p)))) ::: Harriet sits immediately next to neither Fiona nor Karl\nForAll([p:people], Implies(directly_across(Ingrid, p), Not(directly_across(Olivia, p)))) ::: Ingrid sits immediately next to, and immediately clockwise from, Olivia\n\n# Options\nQuestion ::: What is the minimum possible number of people sitting between Ingrid and Manuel, counting clockwise from Ingrid around the table?\nis_valid(Exists([s:seats], Count([p:people], directly_across(p, s)) == 1)) ::: (A)\nis_valid(Exists([s:seats], Count([p:people], directly_across(p, s)) == 2)) ::: (B)\nis_valid(Exists([s:seats], Count([p:people], directly_across(p, s)) == 3)) ::: (C)\nis_valid(Exists([s:seats], Count([p:people], directly_across(p, s)) == 4)) ::: (D)\nis_valid(Exists([s:seats], Count([p:people], directly_across(p, s)) == 5)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_23",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "If Karl sits directly across from Ingrid, then each of the following people could sit immediately next to Olivia EXCEPT:",
    "answer": "B",
    "options": [
      "A) Fiona",
      "B) George",
      "C) Harriet",
      "D) Manuel",
      "E) Peter"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.\nQuestion:\nIf Karl sits directly across from Ingrid, then each of the following people could sit immediately next to Olivia EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, Peter])\nseats = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])\nsit = Function([people, seats] -> [bool])\n\n# Constraints\nForAll([s:seats], Count([p:people], sit(p, s)) >= 1) ::: each person sits in at least one seat\nAnd(sit(Fiona, 1), sit(George, 2)) ::: Fiona sits directly across from George\nForAll([p:people], Implies(sit(p, 3), Not(sit(p, 4)))) ::: Harriet sits immediately next to neither Fiona nor Karl\nForAll([p:people], Implies(sit(p, 5), Not(sit(p, 6)))) ::: Ingrid sits immediately next to, and immediately clockwise from, Olivia\nForAll([p:people], Implies(sit(p, 7), Not(sit(p, 8)))) ::: Karl sits directly across from Ingrid\n\n# Options\nQuestion ::: If Karl sits directly across from Ingrid, then each of the following people could sit immediately next to Olivia EXCEPT:\nis_valid(ForAll([p:people], sit(p, 3) == sit(Olivia, 7))) ::: (A)\nis_valid(ForAll([p:people], sit(p, 4) == sit(Olivia, 6))) ::: (B)\nis_valid(ForAll([p:people], sit(p, 5) == sit(Olivia, 5))) ::: (C)\nis_valid(ForAll([p:people], sit(p, 6) == sit(Olivia, 4))) ::: (D)\nis_valid(ForAll([p:people], sit(p, 7) == sit(Olivia, 3))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_24",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "If Karl sits directly across from Harriet, then what is the minimum possible number of people sitting between George and Karl, counting clockwise from George to Karl?",
    "answer": "C",
    "options": [
      "A) zero",
      "B) one",
      "C) two",
      "D) three",
      "E) four"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.\nQuestion:\nIf Karl sits directly across from Harriet, then what is the minimum possible number of people sitting between George and Karl, counting clockwise from George to Karl?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, Peter])\nseats = EnumSort([1, 2, 3, 4, 5, 6, 7, 8])\ndirectly_across = Function([p1:people, p2:people] -> [Count([s:seats], p1 == s && p2 == s + 3)])\n\n# Constraints\nForAll([p:people], Count([s:seats], p == s) >= 1) ::: each person sits in at least one seat\nAnd(directly_across(Fiona, George), Count([s:seats], directly_across(s, Fiona, George)) == 1) ::: Fiona sits directly across from George\nAnd(directly_across(Harriet, Ingrid), Count([s:seats], directly_across(s, Harriet, Ingrid)) == 1) ::: Harriet sits directly across from Ingrid\nAnd(directly_across(Ingrid, Olivia), Count([s:seats], directly_across(s, Ingrid, Olivia)) == 1) ::: Ingrid sits directly across from Olivia\nForAll([s:seats], Implies(directly_across(Karl, s), Not(directly_across(George, s)))) ::: Karl sits directly across from Harriet\n\n# Options\nQuestion ::: What is the minimum possible number of people sitting between George and Karl, counting clockwise from George to Karl?\nis_valid(Exists([s:seats], directly_across(George, s) == 2)) ::: (A)\nis_valid(Exists([s:seats], directly_across(George, s) == 3)) ::: (B)\nis_valid(Exists([s:seats], directly_across(George, s) == 4)) ::: (C)\nis_valid(Exists([s:seats], directly_across(George, s) == 5)) ::: (D)\nis_valid(Exists([s:seats], directly_across(George, s) == 6)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_1_1",
    "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
    "question": "Which one of the following is an acceptable set of appointments of candidates to courts?",
    "answer": "E",
    "options": [
      "A) appellate: Hamadi, Ortiz trial: Jefferson, Kurtz, Li, McDonnell, Perkins",
      "B) appellate: Hamadi, Li, Perkins trial: Jefferson, Kurtz, McDonnell, Ortiz",
      "C) appellate: Kurtz, Li, Perkins trial: Hamadi, Jefferson, McDonnell, Ortiz",
      "D) appellate: Li, McDonnell, Ortiz trial: Hamadi, Jefferson, Kurtz, Perkins",
      "E) appellate: Li, Perkins trial: Hamadi, Jefferson, Kurtz, McDonnell, Ortiz"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.\nQuestion:\nWhich one of the following is an acceptable set of appointments of candidates to courts?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ncandidates = EnumSort([Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, Perkins])\ncourts = EnumSort([appellate_court, trial_court])\nappointments = Function([candidates, courts] -> [bool])\n\n# Constraints\nForAll([c:candidates], Count([c:courts], appointments(c, c)) >= 1) ::: each candidate is appointed to at least one court\nAnd(appointments(Li, appellate_court), Count([c:candidates], And(c != Li, appointments(c, appellate_court))) == 3) ::: Li must be appointed to the appellate court\nAnd(appointments(Kurtz, trial_court), appointments(Kurtz, trial_court)) ::: Kurtz must be appointed to the trial court\nForAll([c:candidates], Implies(appointments(c, c), Not(appointments(Perkins, c)))) ::: Hamadi cannot be appointed to the same court as Perkins\n\n# Options\nQuestion ::: Which one of the following is an acceptable set of appointments of candidates to courts?\nis_sat(ForAll([c:candidates], appointments(c, appellate_court) == appointments(c, trial_court))) ::: (A)\nis_sat(ForAll([c:candidates], appointments(c, appellate_court) == appointments(c, trial_court))) ::: (B)\nis_sat(ForAll([c:candidates], appointments(c, appellate_court) == appointments(Hamadi, trial_court))) ::: (C)\nis_sat(ForAll([c:candidates], appointments(c, trial_court) == appointments(Perkins, appellate_court))) ::: (D)\nis_sat(ForAll([c:candidates], appointments(c, trial_court) == appointments(Kurtz, appellate_court))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_1_2",
    "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "B",
    "options": [
      "A) Hamadi and McDonnell are both appointed to the appellate court.",
      "B) McDonnell and Ortiz are both appointed to the appellate court.",
      "C) Ortiz and Perkins are both appointed to the appellate court.",
      "D) Hamadi and Jefferson are both appointed to the trial court.",
      "E) Ortiz and Perkins are both appointed to the trial court."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.\nQuestion:\nWhich one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ncandidates = EnumSort([Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, Perkins])\ncourts = EnumSort([appellate, trial])\nappointments = Function([candidates, courts] -> [bool])\n\n# Constraints\nForAll([c:candidates], Count([c:courts], appointments(c, c)) >= 1) ::: each candidate is appointed to at least one court\nAnd(appointments(Li, appellate), Count([c:candidates], And(c != Li, appointments(c, appellate))) == 3) ::: Li must be appointed to the appellate court\nAnd(appointments(Kurtz, trial), appointments(Kurtz, trial)) ::: Kurtz must be appointed to the trial court\nForAll([c:candidates], Implies(appointments(c, c), Not(appointments(Perkins, c)))) ::: Hamadi cannot be appointed to the same court as Perkins\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_valid(Exists([c:candidates], appointments(c, appellate) == true)) ::: (A)\nis_valid(Exists([c:candidates], appointments(c, trial) == true)) ::: (B)\nis_valid(Exists([c:candidates], appointments(c, appellate) == false)) ::: (C)\nis_valid(Exists([c:candidates], appointments(c, trial) == false)) ::: (D)\nis_valid(Exists([c:candidates], appointments(Hamadi, c) == true)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem description and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_1_3",
    "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "A",
    "options": [
      "A) Jefferson and McDonnell are both appointed to the appellate court.",
      "B) Jefferson and McDonnell are both appointed to the trial court.",
      "C) McDonnell and Ortiz are both appointed to the trial court.",
      "D) McDonnell and Perkins are both appointed to the appellate court.",
      "E) McDonnell and Perkins are both appointed to the trial court."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.\nQuestion:\nWhich one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ncandidates = EnumSort([Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, Perkins])\ncourts = EnumSort([appellate, trial])\nappointments = Function([candidates, courts] -> [bool])\n\n# Constraints\nForAll([c:candidates], Count([c:courts], appointments(c, c)) >= 1) ::: each candidate is appointed to at least one court\nAnd(appointments(Li, appellate), Count([c:candidates], And(c != Li, appointments(c, appellate))) == 3) ::: Li must be appointed to the appellate court\nAnd(appointments(Kurtz, trial), appointments(Kurtz, trial)) ::: Kurtz must be appointed to the trial court\nForAll([c:candidates], Implies(appointments(c, c), Not(appointments(Perkins, c)))) ::: Hamadi cannot be appointed to the same court as Perkins\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_valid(Exists([c:candidates], appointments(c, appellate) == true)) ::: (A)\nis_valid(Exists([c:candidates], appointments(c, trial) == true)) ::: (B)\nis_valid(Exists([c:candidates], appointments(c, appellate) == false)) ::: (C)\nis_valid(Exists([c:candidates], appointments(c, trial) == false)) ::: (D)\nis_valid(Exists([c:candidates], appointments(Hamadi, c) == true)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_1_4",
    "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
    "question": "If Ortiz is appointed to the appellate court, which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) Hamadi is appointed to the appellate court.",
      "B) Jefferson is appointed to the appellate court.",
      "C) Jefferson is appointed to the trial court.",
      "D) Perkins is appointed to the appellate court.",
      "E) Perkins is appointed to the trial court."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.\nQuestion:\nIf Ortiz is appointed to the appellate court, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ncandidates = EnumSort([Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, Perkins])\ncourts = EnumSort([appellate_court, trial_court])\nposition = EnumSort([open_position])\nappoint = Function([candidates, courts] -> [bool])\n\n# Constraints\nForAll([c:candidates], Count([p:positions], appoint(c, p)) >= 1) ::: each candidate is eligible for at least one position\nAnd(appoint(Li, appellate_court), Count([c:candidates], And(c != Li, appoint(c, appellate_court))) == 3) ::: Li must be appointed to the appellate court\nAnd(appoint(Kurtz, trial_court), Count([c:candidates], And(c != Kurtz, appoint(c, trial_court))) == 2) ::: Kurtz must be appointed to the trial court\nForAll([c:candidates], Implies(appoint(c, appellate_court), Not(appoint(Perkins, appellate_court)))) ::: Hamadi cannot be appointed to the same court as Perkins\nCount([p:positions], appoint(Ortiz, p)) > Count([p:positions], appoint(Kurtz, p)) ::: Ortiz must be appointed to the appellate court if Kurtz is appointed to the trial court\n\n# Options\nQuestion ::: Which one of the following must be true if Ortiz is appointed to the appellate court?\nis_valid(ForAll([p:positions], appoint(Ortiz, p) == appoint(Kurtz, p))) ::: (A)\nis_valid(ForAll([p:positions], appoint(Ortiz, p) == appoint(Perkins, p))) ::: (B)\nis_valid(ForAll([p:positions], appoint(Ortiz, p) == appoint(McDonnell, p))) ::: (C)\nis_valid(ForAll([p:positions], appoint(Ortiz, p) == appoint(Li, p))) ::: (D)\nis_valid(ForAll([p:positions], appoint(Ortiz, p) == appoint(Jefferson, p))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem description and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_1_5",
    "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
    "question": "Which one of the following, if substituted for the condition that Hamadi cannot be appointed to the same court as Perkins, would have the same effect on the appointments of the seven candidates?",
    "answer": "E",
    "options": [
      "A) Hamadi and Perkins cannot both be appointed to the appellate court.",
      "B) If Hamadi is not appointed to the trial court, then Perkins must be.",
      "C) If Perkins is appointed to the same court as Jefferson, then Hamadi cannot be.",
      "D) If Hamadi is appointed to the same court as Li, then Perkins must be appointed to the same court as Kurtz.",
      "E) No three of Hamadi, Kurtz, Li, and Perkins can be appointed to the same court as each other."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.\nQuestion:\nWhich one of the following, if substituted for the condition that Hamadi cannot be appointed to the same court as Perkins, would have the same effect on the appointments of the seven candidates?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ncandidates = EnumSort([Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, Perkins])\ncourts = EnumSort([appellate, trial])\nappointments = Function([candidates, courts] -> [bool])\n\n# Constraints\nForAll([c:candidates], Count([c:courts], appointments(c, c)) >= 1) ::: each candidate is appointed to at least one court\nAnd(appointments(Li, appellate), Count([c:candidates], And(c != Li, appointments(c, appellate))) == 3) ::: Li must be appointed to the appellate court\nAnd(appointments(Kurtz, trial), appointments(Kurtz, trial)) ::: Kurtz must be appointed to the trial court\nForAll([c:candidates], Implies(appointments(Hamadi, c), Not(appointments(Perkins, c)))) ::: Hamadi cannot be appointed to the same court as Perkins\n\n# Options\nQuestion ::: Which one of the following, if substituted for the condition that Hamadi cannot be appointed to the same court as Perkins, would have the same effect on the appointments of the seven candidates?\nis_sat(ForAll([c:candidates], appointments(Hamadi, c) == appointments(Perkins, c))) ::: (A)\nis_sat(ForAll([c:candidates], appointments(Perkins, c) == appointments(Hamadi, c))) ::: (B)\nis_sat(ForAll([c:candidates], appointments(Hamadi, c) == appointments(Kurtz, c))) ::: (C)\nis_sat(ForAll([c:candidates], appointments(Perkins, c) == appointments(Kurtz, c))) ::: (D)\nis_sat(ForAll([c:candidates], appointments(Kurtz, c) == appointments(Hamadi, c))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_2_6",
    "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
    "question": "Which one of the following could be an accurate list of the members in the order in which they dive from the plane, from first to last?",
    "answer": "B",
    "options": [
      "A) Larue, Trevino, Ohba, Zacny, Pei, Weiss",
      "B) Larue, Trevino, Pei, Zacny, Weiss, Ohba",
      "C) Weiss, Ohba, Trevino, Zacny, Pei, Larue",
      "D) Trevino, Weiss, Pei, Ohba, Zacny, Larue",
      "E) Trevino, Weiss, Zacny, Larue, Pei, Ohba"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.\nQuestion:\nWhich one of the following could be an accurate list of the members in the order in which they dive from the plane, from first to last?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Larue, Ohba, Pei, Trevino, Weiss, Zacny])\ndives = EnumSort([plane])\ntimes = EnumSort([time])\norder = Function([people, times] -> [people])\n\n# Constraints\nForAll([t:times], Count([p:people], And(p == t, dives(p, t))) >= 1) ::: each person dives from the plane at some time\nAnd(dives(Trevino, times(1)), Count([p:people], And(p != Trevino, dives(p, times(1)))) == 1) ::: Trevino dives from the plane at some time before Weiss does\nForAll([p:people], Or(dives(p, times(1)), dives(p, times(2)))) ::: Larue dives from the plane either first or last\nForAll([p:people], Or(dives(p, times(2)), dives(p, times(3)))) ::: Pei dives from the plane at some time after either Ohba or Larue but not both\nForAll([p:people], Implies(dives(p, times(3)), Not(dives(p, times(2))))) ::: Zacny does not dive from the plane last\n\n# Options\nQuestion ::: Which one of the following could be an accurate list of the members in the order in which they dive from the plane, from first to last?\nis_valid(ForAll([t:times], order(people, t) == [[CHOICES]])) ::: (A)\nis_valid(ForAll([t:times], order(people, t) == [[B, C, D, E, F, G]])) ::: (B)\nis_valid(ForAll([t:times], order(people, t) == [[C, D, E, F, G, H]])) ::: (C)\nis_valid(ForAll([t:times], order(people, t) == [[D, E, F, G, H, I]])) ::: (D)\nis_valid(ForAll([t:times], order(people, t) == [[E, F, G, H, I, J]])) ::: (E)\nis_valid(ForAll([t:times], order(people, t) == [[F, G, H, I, J, K]])) ::: (F)\nis_valid(ForAll([t:times], order(people, t) == [[G, H, I, J, K, L]])) ::: (G)\nis_valid(ForAll([t:times], order(people, t) == [[H, I, J, K, L, M]])) ::: (H)\nis_valid(ForAll([t:times], order(people, t) == [[I, J, K, L, M, N]])) ::: (I)\nis_valid(ForAll([t:times], order(people, t) == [[J, K, L, M, N, O]])) ::: (J)\nis_valid(ForAll([t:times], order(people, t) == [[K, L, M, N, O, P]])) ::: (K)\nis_valid(ForAll([t:times], order(people, t) == [[L, M, N, O, P, Q]])) ::: (L)\nis_valid(ForAll([t:times], order(people, t) == [[M, N, O, P, Q, R]])) ::: (M)\nis_valid(ForAll([t:times], order(people, t) == [[N, O, P, Q, R, S]])) ::: (N)\nis_valid(ForAll([t:times], order(people, t) == [[O, P, Q, R, S, T]])) ::: (O)\nis_valid(ForAll([t:times], order(people, t) == [[P, Q, R, S, T, U]])) ::: (P)\nis_valid(ForAll([t:times], order(people, t) == [[Q, R, S, T, U, V]])) ::: (Q)\nis_valid(ForAll([t:times], order(people, t) == [[R, S, T, U, V, W]])) ::: (R)\nis_valid(ForAll([t:times], order(people, t) == [[S, T, U, V, W, X]])) ::: (S)\nis_valid(ForAll([t:times], order(people, t) == [[T, U, V, W, X, Y]])) ::: (T)\nis_valid(ForAll([t:times], order(people, t) == [[U, V, W, X, Y, Z]])) ::: (U)\nis_valid(ForAll([t:times], order(people, t) == [[V, W, X, Y, Z, A]])) ::: (V)\nis_valid(ForAll([t:times], order(people, t) == [[W, X, Y, Z, A, B]])) ::: (W)\nis_valid(ForAll([t:times], order(people, t) == [[X, Y, Z, A, B, C]])) ::: (X)\nis_valid(ForAll([t:times], order(people, t) == [[Y, Z, A, B, C, D]])) ::: (Y)\nis_valid(ForAll([t:times], order(people, t) == [[Z, A, B, C, D, E]])) ::: (Z)\n\n------\n\nNote: The `is_valid` function returns `True` if the given list of people in the order they dive from the plane is valid, and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_2_7",
    "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
    "question": "Which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) At least two of the members dive from the plane after Larue.",
      "B) At least two of the members dive from the plane after Ohba.",
      "C) At least two of the members dive from the plane after Pei.",
      "D) At least two of the members dive from the plane after Trevino.",
      "E) At least two of the members dive from the plane after Weiss."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.\nQuestion:\nWhich one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Larue, Ohba, Pei, Trevino, Weiss, Zacny])\ndives = EnumSort([plane])\ntimes = EnumSort([time])\n\n# Constraints\nForAll([p:plane], ForAll([t:times], dives(p, t) == people)) ::: each person dives from the plane exactly once\nAnd(dives(Trevino, times) < dives(Weiss, times)) ::: Trevino dives from the plane at some time before Weiss does\nOr(dives(Larue, times) == first, dives(Larue, times) == last) ::: Larue dives from the plane either first or last\nAnd(dives(Pei, times) > dives(Ohba, times)) ::: Pei dives from the plane at some time after either Ohba or Larue but not both\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(ForAll([p:plane], ForAll([t:times], dives(p, t) == Larue))) ::: (A)\nis_valid(ForAll([p:plane], ForAll([t:times], dives(p, t) == Pei))) ::: (B)\nis_valid(ForAll([p:plane], ForAll([t:times], dives(p, t) == Weiss))) ::: (C)\nis_valid(ForAll([p:plane], ForAll([t:times], dives(p, t) == Zacny))) ::: (D)\nis_valid(ForAll([p:plane], ForAll([t:times], dives(p, t) == Ohba))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_2_8",
    "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
    "question": "If Larue dives from the plane last, then each of the following could be true EXCEPT:",
    "answer": "C",
    "options": [
      "A) Trevino dives from the plane fourth.",
      "B) Weiss dives from the plane fourth.",
      "C) Ohba dives from the plane fifth.",
      "D) Pei dives from the plane fifth.",
      "E) Zacny dives from the plane fifth."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.\nQuestion:\nIf Larue dives from the plane last, then each of the following could be true EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Larue, Ohba, Pei, Trevino, Weiss, Zacny])\ndives = EnumSort([plane])\ntimes = EnumSort([time])\n\n# Constraints\nForAll([p:plane], ForAll([t:times], dives(p, t) >= 1)) ::: each person dives from the plane at least once\nAnd(dives(Trevino, times([1, 2, 3, 4, 5])) == 1) ::: Trevino dives from the plane at some time before Weiss does\nForAll([p:plane], Implies(dives(p, times([6, 7, 8, 9, 10])) == 1, Not(dives(Larue, times([6, 7, 8, 9, 10]))))) ::: Larue dives from the plane last\nForAll([p:plane], Implies(dives(p, times([1, 2, 3, 4, 5])) == 1, Not(dives(Pei, times([1, 2, 3, 4, 5]))))) ::: Pei dives from the plane at some time after either Ohba or Larue but not both\n\n# Options\nQuestion ::: If Larue dives from the plane last, then each of the following could be true EXCEPT:\nis_valid(ForAll([p:plane], dives(p, times([6, 7, 8, 9, 10])) == 1)) ::: (A)\nis_valid(ForAll([p:plane], dives(p, times([1, 2, 3, 4, 5])) == 1)) ::: (B)\nis_valid(ForAll([p:plane], dives(p, times([1, 2, 3, 4, 5])) == 2)) ::: (C)\nis_valid(ForAll([p:plane], dives(p, times([1, 2, 3, 4, 5])) == 3)) ::: (D)\nis_valid(ForAll([p:plane], dives(p, times([1, 2, 3, 4, 5])) == 4)) ::: (E)\n\n------\n\nNote: The problem and question are given in a logical form, which means that the variables and functions are declared using logical quantifiers (e.g., ForAll, ThereExists). The constraints are written as logical formulas, and the options are written as logical formulas as well."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_2_9",
    "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
    "question": "If Zacny dives from the plane immediately after Weiss, then which one of the following must be false?",
    "answer": "D",
    "options": [
      "A) Larue dives from the plane first.",
      "B) Trevino dives from the plane third.",
      "C) Zacny dives from the plane third.",
      "D) Pei dives from the plane fourth.",
      "E) Zacny dives from the plane fourth."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.\nQuestion:\nIf Zacny dives from the plane immediately after Weiss, then which one of the following must be false?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Larue, Ohba, Pei, Trevino, Weiss, Zacny])\ndives = EnumSort([plane])\ntimes = EnumSort([time])\n\n# Constraints\nForAll([p:plane], ForAll([t:times], dives(p, t) == dives(p, times))) ::: each person dives from the plane exactly once\nAnd(dives(Trevino, times) <= dives(Weiss, times)) ::: Trevino dives from the plane at some time before Weiss\nOr(dives(Larue, times) == first, dives(Larue, times) == last) ::: Larue dives from the plane either first or last\nAnd(dives(Pei, times) == after(Ohba, Larue)) ::: Pei dives from the plane at some time after either Ohba or Larue but not both\nForAll([p:plane], ForAll([t:times], dives(p, t) == dives(p, times))) ::: each person dives from the plane exactly once\n\n# Options\nQuestion ::: Which one of the following must be false if Zacny dives from the plane immediately after Weiss?\nis_valid(ForAll([p:plane], ForAll([t:times], dives(p, t) == dives(p, times))))) ::: (A)\nis_valid(ForAll([p:plane], ForAll([t:times], dives(p, t) == dives(p, times))))) ::: (B)\nis_valid(ForAll([p:plane], ForAll([t:times], dives(p, t) == dives(p, times))))) ::: (C)\nis_valid(ForAll([p:plane], ForAll([t:times], dives(p, t) == dives(p, times))))) ::: (D)\nis_valid(ForAll([p:plane], ForAll([t:times], dives(p, t) == dives(p, times))))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_2_10",
    "context": "Exactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.",
    "question": "If Trevino dives from the plane immediately after Larue, then each of the following could be true EXCEPT:",
    "answer": "A",
    "options": [
      "A) Ohba dives from the plane third.",
      "B) Weiss dives from the plane third.",
      "C) Zacny dives from the plane third.",
      "D) Pei dives from the plane fourth.",
      "E) Weiss dives from the plane fourth."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six members of a skydiving team—Larue, Ohba, Pei, Trevino, Weiss, and Zacny—each dive exactly once, one at a time, from a plane, consistent with the following conditions: Trevino dives from the plane at some time before Weiss does. Larue dives from the plane either first or last. Neither Weiss nor Zacny dives from the plane last. Pei dives from the plane at some time after either Ohba or Larue but not both.\nQuestion:\nIf Trevino dives from the plane immediately after Larue, then each of the following could be true EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Larue, Ohba, Pei, Trevino, Weiss, Zacny])\ndives = EnumSort([plane])\ntimes = EnumSort([time])\n\n# Constraints\nForAll([p:plane], ForAll([t:times], dives(p, t) >= 1)) ::: each person dives from the plane at least once\nAnd(dives(plane, time), Count([p:people], dives(p, time)) >= 1) ::: each person dives from the plane at most once\nForAll([p:plane], Implies(dives(p, time), Not(dives(plane, time)))) ::: Trevino dives from the plane immediately after Larue\nForAll([p:plane], Implies(dives(p, time), Not(dives(plane, time + 1)))) ::: Pei dives from the plane at some time after either Ohba or Larue but not both\nForAll([p:plane], Implies(dives(p, time), Not(dives(plane, time + 2)))) ::: Weiss dives from the plane at some time after either Pei or Zacny but not both\n\n# Options\nQuestion ::: If Trevino dives from the plane immediately after Larue, then each of the following could be true EXCEPT:\nis_valid(Exists([p:plane], dives(p, time) == Weiss)) ::: (A)\nis_valid(Exists([p:plane], dives(p, time) == Zacny)) ::: (B)\nis_valid(Exists([p:plane], dives(p, time) == Ohba)) ::: (C)\nis_valid(Exists([p:plane], dives(p, time) == Larue)) ::: (D)\nis_valid(Exists([p:plane], dives(p, time) == Pei)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_3_11",
    "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
    "question": "Which one of the following could be the order in which the vehicles are serviced, from Monday through Saturday?",
    "answer": "B",
    "options": [
      "A) the hatchback, the pickup, the sedan, the limousine, the van, the roadster",
      "B) the pickup, the sedan, the van, the roadster, the hatchback, the limousine",
      "C) the pickup, the van, the sedan, the roadster, the limousine, the hatchback",
      "D) the van, the roadster, the pickup, the hatchback, the sedan, the limousine",
      "E) the van, the sedan, the pickup, the roadster, the hatchback, the limousine"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.\nQuestion:\nWhich one of the following could be the order in which the vehicles are serviced, from Monday through Saturday?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvehicles = EnumSort([hatchback, limousine, pickup, roadster, sedan, van])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\nservice_order = Function([days] -> [vehicles])\n\n# Constraints\nForAll([d:days], Count([v:vehicles], service_order(d) == v) >= 1) ::: each vehicle is serviced on at least one day\nAnd(service_order(Monday) == hatchback, service_order(Tuesday) == roadster) ::: At least one of the vehicles is serviced later in the week than the hatchback\nAnd(service_order(Wednesday) == van, service_order(Thursday) == pickup) ::: Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both\nAnd(service_order(Friday) == sedan, service_order(Saturday) == limousine) ::: The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both\n\n# Options\nQuestion ::: Which one of the following could be the order in which the vehicles are serviced, from Monday through Saturday?\nis_valid(service_order(Monday) == hatchback) ::: (A)\nis_valid(service_order(Tuesday) == roadster) ::: (B)\nis_valid(service_order(Wednesday) == van) ::: (C)\nis_valid(service_order(Thursday) == pickup) ::: (D)\nis_valid(service_order(Friday) == sedan) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_3_12",
    "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
    "question": "Which one of the following CANNOT be the vehicle serviced on Thursday?",
    "answer": "E",
    "options": [
      "A) the hatchback",
      "B) the limousine",
      "C) the pickup",
      "D) the sedan",
      "E) the van"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.\nQuestion:\nWhich one of the following CANNOT be the vehicle serviced on Thursday?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvehicles = EnumSort([hatchback, limousine, pickup, roadster, sedan, van])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\nservice = Function([days, vehicles] -> [bool])\n\n# Constraints\nForAll([d:days], Count([v:vehicles], service(d, v)) >= 1) ::: each vehicle is serviced on at least one day\nAnd(service(Monday, hatchback), Count([t:vehicles], And(t != hatchback, service(t, Monday))) == 1) ::: At least one of the vehicles is serviced later in the week than the hatchback\nAnd(service(Wednesday, roadster), service(Thursday, roadster) == False) ::: The roadster is serviced later in the week than the van and earlier in the week than the hatchback\nOr(service(Tuesday, pickup), service(Wednesday, pickup) == False) ::: Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both\nAnd(service(Thursday, sedan), service(Friday, sedan) == False) ::: The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both\n\n# Options\nQuestion ::: Which one of the following CANNOT be the vehicle serviced on Thursday?\nis_valid(service(Thursday, pickup)) ::: (A)\nis_valid(service(Thursday, sedan)) ::: (B)\nis_valid(service(Thursday, van)) ::: (C)\nis_valid(service(Thursday, limousine)) ::: (D)\nis_valid(service(Thursday, roadster)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_3_13",
    "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
    "question": "If neither the pickup nor the limousine is serviced on Monday, then which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) The hatchback and the limousine are serviced on consecutive days.",
      "B) The hatchback and the sedan are serviced on consecutive days.",
      "C) The van is serviced on Monday.",
      "D) The limousine is serviced on Saturday.",
      "E) The pickup is serviced on Saturday."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.\nQuestion:\nIf neither the pickup nor the limousine is serviced on Monday, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvehicles = EnumSort([hatchback, limousine, pickup, roadster, sedan, van])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\nserviced = Function([vehicles, days] -> [bool])\n\n# Constraints\nForAll([v:vehicles], Count([d:days], serviced(v, d)) >= 1) ::: each vehicle is serviced on at least one day\nAnd(serviced(roadster, Wednesday), serviced(van, Thursday)) ::: the roadster is serviced later in the week than the van\nOr(serviced(pickup, Tuesday), serviced(sedan, Wednesday)) ::: either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days\nForAll([v:vehicles], Implies(serviced(sedan, v), Not(serviced(pickup, v)))) ::: the sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both\n\n# Options\nQuestion ::: ::: If neither the pickup nor the limousine is serviced on Monday, then which one of the following must be true?\nis_sat(ForAll([v:vehicles], serviced(v, Tuesday) == serviced(v, Wednesday))) ::: (A)\nis_sat(ForAll([v:vehicles], serviced(v, Wednesday) == serviced(v, Thursday))) ::: (B)\nis_sat(ForAll([v:vehicles], serviced(v, Wednesday) == serviced(v, Friday))) ::: (C)\nis_sat(ForAll([v:vehicles], serviced(v, Thursday) == serviced(v, Friday))) ::: (D)\nis_sat(ForAll([v:vehicles], serviced(v, Friday) == serviced(v, Saturday))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_3_14",
    "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
    "question": "If the limousine is not serviced on Saturday, then each of the following could be true EXCEPT:",
    "answer": "E",
    "options": [
      "A) The limousine is serviced on Monday.",
      "B) The roadster is serviced on Tuesday.",
      "C) The hatchback is serviced on Wednesday.",
      "D) The roadster is serviced on Wednesday.",
      "E) The sedan is serviced on Wednesday."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.\nQuestion:\nIf the limousine is not serviced on Saturday, then each of the following could be true EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvehicles = EnumSort([hatchback, limousine, pickup, roadster, sedan, van])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\nserviced = Function([vehicles, days] -> [bool])\n\n# Constraints\nForAll([v:vehicles], Count([d:days], serviced(v, d)) >= 1) ::: each vehicle is serviced on at least one day\nAnd(serviced(roadster, Wednesday), serviced(van, Thursday)) ::: the roadster is serviced later in the week than the van\nOr(serviced(pickup, Monday), serviced(sedan, Tuesday)) ::: either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days\nForAll([v:vehicles], Implies(serviced(sedan, v), Not(serviced(pickup, v)))) ::: the sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both\n\n# Options\nQuestion ::: If the limousine is not serviced on Saturday, then each of the following could be true EXCEPT:\nis_sat(ForAll([v:vehicles], serviced(v, Saturday) == False)) ::: (A)\nis_sat(ForAll([v:vehicles], serviced(v, Monday) == True)) ::: (B)\nis_sat(ForAll([v:vehicles], serviced(v, Tuesday) == True)) ::: (C)\nis_sat(ForAll([v:vehicles], serviced(v, Wednesday) == True)) ::: (D)\nis_sat(ForAll([v:vehicles], serviced(v, Thursday) == True)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_3_15",
    "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
    "question": "If the sedan is serviced earlier in the week than the pickup, then which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) The limousine is serviced on Wednesday.",
      "B) The sedan is serviced on Wednesday.",
      "C) The van is serviced on Wednesday.",
      "D) The hatchback is serviced on Friday.",
      "E) The limousine is serviced on Saturday."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.\nQuestion:\nIf the sedan is serviced earlier in the week than the pickup, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvehicles = EnumSort([hatchback, limousine, pickup, roadster, sedan, van])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\nserviced = Function([vehicles, days] -> [bool])\n\n# Constraints\nForAll([v:vehicles], Count([d:days], serviced(v, d)) >= 1) ::: each vehicle is serviced on at least one day\nAnd(serviced(roadster, Wednesday), serviced(van, Thursday)) ::: the roadster is serviced later in the week than the van\nOr(serviced(pickup, Monday), serviced(sedan, Tuesday)) ::: either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days\nForAll([v:vehicles], Implies(serviced(sedan, v), Not(serviced(pickup, v)))) ::: the sedan is serviced earlier in the week than the pickup\n\n# Options\nQuestion ::: ::: If the sedan is serviced earlier in the week than the pickup, then which one of the following could be true?\nis_sat(ForAll([v:vehicles], serviced(sedan, v) == serviced(pickup, v))) ::: (A)\nis_sat(ForAll([v:vehicles], serviced(sedan, v) == serviced(roadster, v))) ::: (B)\nis_sat(ForAll([v:vehicles], serviced(sedan, v) == serviced(van, v))) ::: (C)\nis_sat(ForAll([v:vehicles], serviced(pickup, v) == serviced(roadster, v))) ::: (D)\nis_sat(ForAll([v:vehicles], serviced(pickup, v) == serviced(van, v))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_3_16",
    "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
    "question": "If the limousine is serviced on Saturday, then which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) The pickup is serviced earlier in the week than the roadster.",
      "B) The pickup is serviced earlier in the week than the sedan.",
      "C) The sedan is serviced earlier in the week than the roadster.",
      "D) The hatchback and the limousine are serviced on consecutive days.",
      "E) The roadster and the hatchback are serviced on consecutive days."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.\nQuestion:\nIf the limousine is serviced on Saturday, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvehicles = EnumSort([hatchback, limousine, pickup, roadster, sedan, van])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\nservice = Function([vehicles, days] -> [bool])\n\n# Constraints\nForAll([v:vehicles], Count([d:days], service(v, d)) >= 1) ::: each vehicle is serviced on at least one day\nAnd(service(roadster, Wednesday), service(hatchback, Thursday)) ::: The roadster is serviced later in the week than the hatchback\nOr(service(pickup, Monday), service(van, Tuesday)) ::: Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days\nForAll([v:vehicles], Implies(service(v, Friday), Not(service(sedan, Friday)))) ::: The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both\n\n# Options\nQuestion ::: If the limousine is serviced on Saturday, then which one of the following must be true?\nis_valid(service(limousine, Saturday) == service(sedan, Friday)) ::: (A)\nis_valid(service(limousine, Saturday) == service(roadster, Thursday)) ::: (B)\nis_valid(service(limousine, Saturday) == service(pickup, Monday)) ::: (C)\nis_valid(service(limousine, Saturday) == service(van, Tuesday)) ::: (D)\nis_valid(service(limousine, Saturday) == service(sedan, Wednesday)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_3_17",
    "context": "A company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.",
    "question": "Which one of the following could be the list of the vehicles serviced on Tuesday, Wednesday, and Friday, listed in that order?",
    "answer": "B",
    "options": [
      "A) the pickup, the hatchback, the limousine",
      "B) the pickup, the roadster, the hatchback",
      "C) the sedan, the limousine, the hatchback",
      "D) the van, the limousine, the hatchback",
      "E) the van, the roadster, the limousine"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company's six vehicles—a hatchback, a limousine, a pickup, a roadster, a sedan, and a van—are serviced during a certain week—Monday through Saturday—one vehicle per day. The following conditions must apply: At least one of the vehicles is serviced later in the week than the hatchback. The roadster is serviced later in the week than the van and earlier in the week than the hatchback. Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days, but not both. The sedan is serviced earlier in the week than the pickup or earlier in the week than the limousine, but not both.\nQuestion:\nWhich one of the following could be the list of the vehicles serviced on Tuesday, Wednesday, and Friday, listed in that order?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvehicles = EnumSort([hatchback, limousine, pickup, roadster, sedan, van])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\nservice = Function([days, vehicles] -> [bool])\n\n# Constraints\nForAll([d:days], ForAll([v:vehicles], service(d, v))) ::: each vehicle is serviced on exactly one day\nAnd(service(Tuesday, pickup), service(Wednesday, van)) ::: At least one of the vehicles is serviced later in the week than the hatchback\nOr(service(Tuesday, pickup), service(Wednesday, sedan)) ::: Either the pickup and the van are serviced on consecutive days, or the pickup and the sedan are serviced on consecutive days\nImplies(service(Thursday, pickup), Not(service(Friday, van))) ::: The pickup is serviced earlier in the week than the van\nImplies(service(Thursday, sedan), Not(service(Friday, limousine))) ::: The sedan is serviced earlier in the week than the limousine\n\n# Options\nQuestion ::: Which one of the following could be the list of the vehicles serviced on Tuesday, Wednesday, and Friday, listed in that order?\nis_sat(ForAll([d:days], ForAll([v:vehicles], service(d, v) == [hatchback, roadster, van]))) ::: (A)\nis_sat(ForAll([d:days], ForAll([v:vehicles], service(d, v) == [roadster, sedan, van]))) ::: (B)\nis_sat(ForAll([d:days], ForAll([v:vehicles], service(d, v) == [van, sedan, limousine]))) ::: (C)\nis_sat(ForAll([d:days], ForAll([v:vehicles], service(d, v) == [hatchback, pickup, sedan]))) ::: (D)\nis_sat(ForAll([d:days], ForAll([v:vehicles], service(d, v) == [sedan, limousine, van]))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_4_18",
    "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
    "question": "If there are exactly two white balls, then which one of the following boxes could contain a green ball?",
    "answer": "B",
    "options": [
      "A) box 1",
      "B) box 3",
      "C) box 4",
      "D) box 5",
      "E) box 6"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.\nQuestion:\nIf there are exactly two white balls, then which one of the following boxes could contain a green ball?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nboxes = EnumSort([1, 2, 3, 4, 5, 6])\nballs = EnumSort([green, red, white])\ncolors = EnumSort([green, red, white])\nbox_colors = Function([boxes] -> [colors])\n\n# Constraints\nForAll([b:boxes], Count([b:balls], b == green) >= 1) ::: there are more green balls than red balls\nForAll([b:boxes], Implies(b == 4, And(Count([b:balls], red) >= 2, Count([b:balls], white) >= 2))) ::: there is a box containing a green ball that is lower in the stack than any box that contains a red ball\nForAll([b:boxes], Implies(b == 5, And(Count([b:balls], white) >= 2, Count([b:balls], green) >= 1))) ::: there is a white ball in a box that is immediately below a box that contains a green ball\n\n# Options\nQuestion ::: Which one of the following boxes could contain a green ball?\nis_valid(Exists([b:boxes], box_colors(b) == [green, green, white])) ::: (A)\nis_valid(Exists([b:boxes], box_colors(b) == [white, white, green])) ::: (B)\nis_valid(Exists([b:boxes], box_colors(b) == [green, white, white])) ::: (C)\nis_valid(Exists([b:boxes], box_colors(b) == [red, red, green])) ::: (D)\nis_valid(Exists([b:boxes], box_colors(b) == [white, red, green])) ::: (E)\n\n------\n\nNote: The `is_valid` function is used to check whether the given answer is valid according to the constraints and options provided. If the answer is valid, then the corresponding choice is correct. Otherwise, the answer is incorrect."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_4_19",
    "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
    "question": "If there are green balls in boxes 5 and 6, then which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) There are red balls in boxes 1 and 4.",
      "B) There are red balls in boxes 2 and 4.",
      "C) There is a white ball in box 1.",
      "D) There is a white ball in box 2.",
      "E) There is a white ball in box 3."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.\nQuestion:\nIf there are green balls in boxes 5 and 6, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nboxes = EnumSort([1, 2, 3, 4, 5, 6])\nballs = EnumSort([green, red, white])\ncolors = EnumSort([green, red, white])\n\n# Constraints\nForAll([b:boxes], Count([b:balls], b == green) >= 2) ::: There are more red balls than white balls\nAnd(ForAll([b:boxes], b == 5, Count([b:balls], b == green) > Count([b:balls], b == red))) ::: There is a box containing a green ball that is lower in the stack than any box that contains a red ball\nAnd(ForAll([b:boxes], b == 4, Count([b:balls], b == white) > Count([b:balls], b == green))) ::: There is a white ball in a box that is immediately below a box that contains a green ball\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_valid(ForAll([b:boxes], b == 5, b == 6, colors(b) == green)) ::: (A)\nis_valid(ForAll([b:boxes], b == 4, b == 5, colors(b) == green)) ::: (B)\nis_valid(ForAll([b:boxes], b == 4, b == 6, colors(b) == green)) ::: (C)\nis_valid(ForAll([b:boxes], b == 5, b == 6, colors(b) == red)) ::: (D)\nis_valid(ForAll([b:boxes], b == 4, b == 5, colors(b) == red)) ::: (E)\n\n------\n\nNote: The `is_valid` function is a built-in function in the logic programming language Prolog, which returns `true` if the given formula is valid (i.e., satisfies the constraints), and `false` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_4_20",
    "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
    "question": "The ball in which one of the following boxes must be the same color as at least one of the other balls?",
    "answer": "E",
    "options": [
      "A) box 2",
      "B) box 3",
      "C) box 4",
      "D) box 5",
      "E) box 6"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.\nQuestion:\nThe ball in which one of the following boxes must be the same color as at least one of the other balls?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nboxes = EnumSort([1, 2, 3, 4, 5, 6])\nballs = EnumSort([green, red, white])\ncolor = Function([boxes] -> [balls])\n\n# Constraints\nForAll([b:boxes], Count([b:balls], b == green) > Count([b:balls], b == red)) ::: There are more red balls than white balls\nForAll([b:boxes], Implies(b == 4, And(b == 5, b == 6))) ::: There is a box containing a green ball that is lower in the stack than any box that contains a red ball\nForAll([b:boxes], Implies(b == 3, And(b == 4, b == 5))) ::: There is a white ball in a box that is immediately below a box that contains a green ball\n\n# Options\nQuestion ::: Which one of the following boxes must contain a ball of the same color as at least one of the other balls?\nis_valid(Exists([b:boxes], color(b) == red)) ::: (A)\nis_valid(Exists([b:boxes], color(b) == green)) ::: (B)\nis_valid(Exists([b:boxes], color(b) == white)) ::: (C)\nis_valid(Exists([b:boxes], color(b) == red, And(b == 4))) ::: (D)\nis_valid(Exists([b:boxes], color(b) == green, And(b == 5))) ::: (E)\n\n------\n\nPlease provide the code for each problem, including the declarations, constraints, and options."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_4_21",
    "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
    "question": "Which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) There is a green ball in a box that is lower than box 4.",
      "B) There is a green ball in a box that is higher than box 4.",
      "C) There is a red ball in a box that is lower than box 4.",
      "D) There is a red ball in a box that is higher than box 4.",
      "E) There is a white ball in a box that is lower than box 4."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.\nQuestion:\nWhich one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nboxes = EnumSort([1, 2, 3, 4, 5, 6])\nballs = EnumSort([green, red, white])\ncolors = EnumSort([green, red, white])\n\n# Constraints\nForAll([b:boxes], Count([b:balls], b == green) > Count([b:balls], b == white)) ::: There are more red balls than white balls\nForAll([b:boxes], Implies(b == 4, b == 6)) ::: There is a box containing a green ball that is lower in the stack than any box that contains a red ball\nForAll([b:boxes], Implies(b == 3, b == 5)) ::: There is a white ball in a box that is immediately below a box that contains a green ball\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(ForAll([b:boxes], b == 2 && b == 4)) ::: (A)\nis_valid(ForAll([b:boxes], b == 3 && b == 5)) ::: (B)\nis_valid(ForAll([b:boxes], b == 4 && b == 6)) ::: (C)\nis_valid(ForAll([b:boxes], b == 5 && b == 6)) ::: (D)\nis_valid(ForAll([b:boxes], b == 6 && b == 1)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may vary."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_4_22",
    "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
    "question": "If there are red balls in boxes 2 and 3, then which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) There is a red ball in box 1.",
      "B) There is a white ball in box 1.",
      "C) There is a green ball in box 4.",
      "D) There is a red ball in box 5.",
      "E) There is a white ball in box 6."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.\nQuestion:\nIf there are red balls in boxes 2 and 3, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nboxes = EnumSort([1, 2, 3, 4, 5, 6])\nballs = EnumSort([green, red, white])\ncolors = EnumSort([green, red, white])\n\n# Constraints\nForAll([b:boxes], Count([b:balls], b == red) > Count([b:balls], b == white)) ::: There are more red balls than white balls\nForAll([b:boxes], Implies(b == 4, And(b == 2, b == 3))) ::: There is a box containing a green ball that is lower in the stack than any box that contains a red ball\nForAll([b:boxes], Implies(b == 5, And(b == 3, b == 6))) ::: There is a white ball in a box that is immediately below a box that contains a green ball\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_valid(Exists([b:boxes], And(b == 2, b == red))) ::: (A)\nis_valid(Exists([b:boxes], And(b == 3, b == red))) ::: (B)\nis_valid(Exists([b:boxes], And(b == 5, b == white))) ::: (C)\nis_valid(Exists([b:boxes], And(b == 6, b == white))) ::: (D)\nis_valid(Exists([b:boxes], And(b == 4, b == green))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may vary."
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_4_23",
    "context": "A street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.",
    "question": "If boxes 2, 3, and 4 all contain balls that are the same color as each other, then which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Exactly two of the boxes contain a green ball.",
      "B) Exactly three of the boxes contain a green ball.",
      "C) Exactly three of the boxes contain a red ball.",
      "D) Exactly one of the boxes contains a white ball.",
      "E) Exactly two of the boxes contain a white ball."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA street entertainer has six boxes stacked one on top of the other and numbered consecutively 1 through 6, from the lowest box up to the highest. Each box contains a single ball, and each ball is one of three colors—green, red, or white. Onlookers are to guess the color of each ball in each box, given that the following conditions hold: There are more red balls than white balls. There is a box containing a green ball that is lower in the stack than any box that contains a red ball. There is a white ball in a box that is immediately below a box that contains a green ball.\nQuestion:\nIf boxes 2, 3, and 4 all contain balls that are the same color as each other, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nboxes = EnumSort([1, 2, 3, 4, 5, 6])\nballs = EnumSort([green, red, white])\ncolors = EnumSort([green, red, white])\n\n# Constraints\nForAll([b:balls], Count([b:boxes], b == colors(b)) >= 1) ::: each ball is in a box of the same color\nAnd(Count([b:boxes], b == 2) >= Count([b:boxes], b == 3), Count([b:boxes], b == 4) >= Count([b:boxes], b == 5)) ::: There are more red balls than white balls\nExists([b:boxes], b == 2, colors(b) == green) ::: There is a box containing a green ball that is lower in the stack than any box that contains a red ball\nExists([b:boxes], b == 4, colors(b) == white) ::: There is a white ball in a box that is immediately below a box that contains a green ball\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(ForAll([b:boxes], colors(b) == red)) ::: (A)\nis_valid(ForAll([b:boxes], colors(b) == green)) ::: (B)\nis_valid(ForAll([b:boxes], colors(b) == white)) ::: (C)\nis_valid(ForAll([b:boxes], colors(b) == red, colors(b) != red)) ::: (D)\nis_valid(ForAll([b:boxes], colors(b) == green, colors(b) != green)) ::: (E)\n\n------\n\nNote: The `is_valid` function is a built-in function in the logic programming language Prolog, which returns `true` if the given formula is valid (i.e., if it can be made true by assigning values to the variables), and `false` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_1_1",
    "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
    "question": "Which one of the following could be the order, from first to last, in which the students perform?",
    "answer": "D",
    "options": [
      "A) Ginny, Fernando, Hakim, Kevin, Juanita",
      "B) Ginny, Juanita, Kevin, Hakim, Fernando",
      "C) Ginny, Kevin, Hakim, Juanita, Fernando",
      "D) Kevin, Ginny, Juanita, Fernando, Hakim",
      "E) Kevin, Juanita, Fernando, Hakim, Ginny"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.\nQuestion:\nWhich one of the following could be the order, from first to last, in which the students perform?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nstudents = EnumSort([Fernando, Ginny, Hakim, Juanita, Kevin])\npieces = EnumSort([])\norder = EnumSort([])\n\n# Constraints\nForAll([s:students], Count([p:pieces], s.piece == p) >= 1) ::: each student performs one piece\nAnd(Ginny.piece < Fernando.piece) ::: Ginny must perform earlier than Fernando\nAnd(Kevin.piece < Hakim.piece) ::: Kevin must perform earlier than Hakim\nAnd(Hakim.piece < Fernando.piece) ::: Hakim must perform either immediately before or immediately after Fernando\n\n# Options\nQuestion ::: Which one of the following could be the order, from first to last, in which the students perform?\nis_valid(ForAll([p:pieces], order(p) == [Ginny, Fernando, Kevin, Hakim, Juanita]))) ::: (A)\nis_valid(ForAll([p:pieces], order(p) == [Ginny, Fernando, Juanita, Kevin, Hakim]))) ::: (B)\nis_valid(ForAll([p:pieces], order(p) == [Ginny, Fernando, Kevin, Juanita, Hakim]))) ::: (C)\nis_valid(ForAll([p:pieces], order(p) == [Ginny, Fernando, Kevin, Hakim, Juanita]))) ::: (D)\nis_valid(ForAll([p:pieces], order(p) == [Ginny, Fernando, Juanita, Kevin, Hakim]))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_1_2",
    "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
    "question": "If Juanita performs earlier than Ginny, then which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) Fernando performs fourth.",
      "B) Ginny performs second.",
      "C) Hakim performs third.",
      "D) Juanita performs third.",
      "E) Kevin performs second."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.\nQuestion:\nIf Juanita performs earlier than Ginny, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nstudents = EnumSort([Fernando, Ginny, Hakim, Juanita, Kevin])\npieces = EnumSort([])\norder = EnumSort([])\n\n# Constraints\nForAll([s:students], Count([p:pieces], s.piece == p) >= 1) ::: each student performs one piece\nAnd(repairs(Ginny, Fernando), Count([t:students], And(t != Ginny, repairs(t, Fernando))) == 1) ::: Ginny must perform earlier than Fernando\nAnd(repairs(Kevin, Hakim), Count([t:students], And(t != Kevin, repairs(t, Hakim))) == 1) ::: Kevin must perform earlier than Hakim and Juanita\nAnd(repairs(Hakim, Fernando), Or(repairs(Hakim, Fernando), repairs(Hakim, Juanita))) ::: Hakim must perform either immediately before or immediately after Fernando\n\n# Options\nQuestion ::: Which one of the following could be true if Juanita performs earlier than Ginny?\nis_valid(Exists([p:pieces], And(order(p) == 1, repairs(Juanita, p) == repairs(Ginny, p)))) ::: (A)\nis_valid(Exists([p:pieces], And(order(p) == 2, repairs(Juanita, p) == repairs(Ginny, p)))) ::: (B)\nis_valid(Exists([p:pieces], And(order(p) == 3, repairs(Juanita, p) == repairs(Ginny, p)))) ::: (C)\nis_valid(Exists([p:pieces], And(order(p) == 4, repairs(Juanita, p) == repairs(Ginny, p)))) ::: (D)\nis_valid(Exists([p:pieces], And(order(p) == 5, repairs(Juanita, p) == repairs(Ginny, p)))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_1_3",
    "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "C",
    "options": [
      "A) Fernando performs immediately before Juanita.",
      "B) Ginny performs immediately before Hakim.",
      "C) Hakim performs immediately before Ginny.",
      "D) Juanita performs immediately before Ginny.",
      "E) Kevin performs immediately before Hakim."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.\nQuestion:\nWhich one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nstudents = EnumSort([Fernando, Ginny, Hakim, Juanita, Kevin])\npieces = EnumSort([piano_piece_1, piano_piece_2, piano_piece_3, piano_piece_4, piano_piece_5])\norder = Function([students] -> [pieces])\n\n# Constraints\nForAll([s:students], Count([p:pieces], order(s) == p) >= 1) ::: each student performs one piece\nAnd(order(Ginny) < order(Fernando)) ::: Ginny must perform earlier than Fernando\nAnd(order(Kevin) < order(Hakim) < order(Juanita)) ::: Kevin must perform earlier than Hakim and Juanita\nImplies(order(Hakim) == order(Fernando) + 1, order(Hakim) == order(Fernando) + 2) ::: Hakim must perform either immediately before or immediately after Fernando\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_valid(ForAll([s:students], order(s) == [piano_piece_1, piano_piece_2, piano_piece_3, piano_piece_4, piano_piece_5])) ::: (A)\nis_valid(ForAll([s:students], order(s) == [piano_piece_1, piano_piece_2, piano_piece_4, piano_piece_5, piano_piece_3])) ::: (B)\nis_valid(ForAll([s:students], order(s) == [piano_piece_2, piano_piece_3, piano_piece_4, piano_piece_5, piano_piece_1])) ::: (C)\nis_valid(ForAll([s:students], order(s) == [piano_piece_3, piano_piece_4, piano_piece_5, piano_piece_1, piano_piece_2])) ::: (D)\nis_valid(ForAll([s:students], order(s) == [piano_piece_4, piano_piece_5, piano_piece_1, piano_piece_2, piano_piece_3])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_1_4",
    "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
    "question": "The order in which the students perform is fully determined if which one of the following is true?",
    "answer": "E",
    "options": [
      "A) Fernando performs immediately before Hakim.",
      "B) Ginny performs immediately before Fernando.",
      "C) Hakim performs immediately before Juanita.",
      "D) Juanita performs immediately before Hakim.",
      "E) Kevin performs immediately before Fernando."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.\nQuestion:\nThe order in which the students perform is fully determined if which one of the following is true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nstudents = EnumSort([Fernando, Ginny, Hakim, Juanita, Kevin])\npieces = EnumSort([])\norder = EnumSort([])\n\n# Constraints\nForAll([s:students], Count([p:pieces], s.piece == p) >= 1) ::: each student performs one piece\nAnd(Ginny.piece < Fernando.piece) ::: Ginny must perform earlier than Fernando\nAnd(Kevin.piece < Hakim.piece) ::: Kevin must perform earlier than Hakim\nAnd(Hakim.piece < Fernando.piece) ::: Hakim must perform either immediately before or immediately after Fernando\n\n# Options\nQuestion ::: The order in which the students perform is fully determined if which one of the following is true?\nis_sat(ForAll([s:students], order(s) == [Ginny, Fernando, Kevin, Hakim, Juanita]))) ::: (A)\nis_sat(ForAll([s:students], order(s) == [Ginny, Fernando, Juanita, Kevin, Hakim]))) ::: (B)\nis_sat(ForAll([s:students], order(s) == [Ginny, Fernando, Kevin, Juanita, Hakim]))) ::: (C)\nis_sat(ForAll([s:students], order(s) == [Ginny, Fernando, Kevin, Hakim, Juanita]))) ::: (D)\nis_sat(ForAll([s:students], order(s) == [Ginny, Fernando, Juanita, Kevin, Hakim]))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_1_5",
    "context": "A professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.",
    "question": "How many of the students are there any one of whom could perform fourth?",
    "answer": "B",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA professor must determine the order in which five of her students—Fernando, Ginny, Hakim, Juanita, and Kevin—will perform in an upcoming piano recital. Each student performs one piece, and no two performances overlap. The following constraints apply: Ginny must perform earlier than Fernando. Kevin must perform earlier than Hakim and Juanita. Hakim must perform either immediately before or immediately after Fernando.\nQuestion:\nHow many of the students are there any one of whom could perform fourth?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nstudents = EnumSort([Fernando, Ginny, Hakim, Juanita, Kevin])\npieces = EnumSort([])\norder = EnumSort([])\n\n# Constraints\nForAll([s:students], Count([p:pieces], s.piece == p) >= 1) ::: each student performs one piece\nAnd(repairs(Ginny, Fernando), Count([t:students], And(t != Ginny, repairs(t, Fernando))) == 1) ::: Ginny must perform earlier than Fernando\nAnd(repairs(Kevin, Hakim), Count([t:students], And(t != Kevin, repairs(t, Hakim))) == 1) ::: Kevin must perform earlier than Hakim and Juanita\nOr(repairs(Hakim, Fernando), repairs(Hakim, Juanita)) ::: Hakim must perform either immediately before or immediately after Fernando\n\n# Options\nQuestion ::: ::: How many of the students are there any one of whom could perform fourth?\nis_valid(Exists([s:students], s.piece == fourth)) ::: (A)\nis_valid(Exists([s:students], s.piece == third)) ::: (B)\nis_valid(Exists([s:students], s.piece == fifth)) ::: (C)\nis_valid(Exists([s:students], s.piece == second)) ::: (D)\nis_valid(Exists([s:students], s.piece == sixth)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_2_6",
    "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
    "question": "Which one of the following could be the order of the presentations, from first to sixth?",
    "answer": "C",
    "options": [
      "A) stenciling, origami, needlework, textile making, pottery, woodworking",
      "B) stenciling, origami, pottery, woodworking, needlework, textile making",
      "C) stenciling, origami, textile making, woodworking, needlework, pottery",
      "D) textile making, origami, stenciling, woodworking, needlework, pottery",
      "E) textile making, stenciling, woodworking, needlework, pottery, origami"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAs part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.\nQuestion:\nWhich one of the following could be the order of the presentations, from first to sixth?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nteachers = EnumSort([Jiang, Kudrow, Lanning])\nsubjects = EnumSort([needlework, origami, pottery, stenciling, textile_making, woodworking])\npresentations = EnumSort([1, 2, 3, 4, 5, 6])\norder = Function([teachers, subjects], [presentations])\n\n# Constraints\nForAll([t:teachers], Count([s:subjects], order(t, s) >= 1)) ::: each teacher gives a presentation on at least one subject\nAnd(order(Kudrow, pottery), Count([t:teachers], And(t != Kudrow, order(t, stenciling))) == 1) ::: Kudrow cannot give two presentations in a row\nAnd(order(Kudrow, stenciling), Count([t:teachers], And(t != Kudrow, order(t, textile_making))) == 1) ::: the presentation on stenciling must be given earlier than the one on origami\nAnd(order(Lanning, woodworking), Count([t:teachers], And(t != Lanning, order(t, textile_making))) == 1) ::: the presentation on textile making must be given earlier than the one on woodworking\n\n# Options\nQuestion ::: Which one of the following could be the order of the presentations, from first to sixth?\nis_valid(ForAll([p:presentations], order(Jiang, p) == [1, 2, 3, 4, 5, 6])) ::: (A)\nis_valid(ForAll([p:presentations], order(Kudrow, p) == [2, 4, 5, 6])) ::: (B)\nis_valid(ForAll([p:presentations], order(Lanning, p) == [3, 5, 6])) ::: (C)\nis_valid(ForAll([p:presentations], order(Kudrow, p) == [1, 3, 5, 6])) ::: (D)\nis_valid(ForAll([p:presentations], order(Lanning, p) == [1, 2, 4, 6])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem description and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_2_7",
    "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
    "question": "If textile making is presented fifth, which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Needlework is presented sixth.",
      "B) Pottery is presented fourth.",
      "C) Stenciling is presented second.",
      "D) Stenciling is presented third.",
      "E) Woodworking is presented second."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAs part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.\nQuestion:\nIf textile making is presented fifth, which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nteachers = EnumSort([Jiang, Kudrow, Lanning])\nsubjects = EnumSort([needlework, origami, pottery, stenciling, textile_making, woodworking])\npresentations = EnumSort([1, 2, 3, 4, 5, 6])\ngives = Function([teachers, subjects, presentations] -> [bool])\n\n# Constraints\nForAll([t:teachers], Count([s:subjects], gives(t, s, presentations[s])) >= 1) ::: each teacher gives at least one subject\nAnd(gives(Kudrow, pottery, presentations[2]), Count([t:teachers], And(t != Kudrow, gives(t, pottery, presentations[2]))) == 1) ::: Kudrow cannot give two presentations in a row\nAnd(gives(Kudrow, stenciling, presentations[3]), Count([t:teachers], And(t != Kudrow, gives(t, stenciling, presentations[3]))) == 1) ::: the presentation on stenciling must be given earlier than the one on origami\nAnd(gives(Lanning, woodworking, presentations[5]), Count([t:teachers], And(t != Lanning, gives(t, woodworking, presentations[5]))) == 1) ::: the presentation on textile making must be given earlier than the one on woodworking\n\n# Options\nQuestion ::: Which one of the following could be true if textile making is presented fifth?\nis_valid(ForAll([p:presentations], gives(Lanning, p, presentations[p]) == True)) ::: (A)\nis_valid(ForAll([p:presentations], gives(Kudrow, p, presentations[p]) == True)) ::: (B)\nis_valid(ForAll([p:presentations], gives(Jiang, p, presentations[p]) == True)) ::: (C)\nis_valid(ForAll([p:presentations], gives(X, p, presentations[p]) == True)) ::: (D)\nis_valid(ForAll([p:presentations], gives(Y, p, presentations[p]) == True)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem description and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_2_8",
    "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
    "question": "If needlework is presented first, which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Origami is presented sixth.",
      "B) Pottery is presented second.",
      "C) Stenciling is presented third.",
      "D) Textile making is presented fifth.",
      "E) Woodworking is presented third."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAs part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.\nQuestion:\nIf needlework is presented first, which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nteachers = EnumSort([Jiang, Kudrow, Lanning])\nsubjects = EnumSort([needlework, origami, pottery, stenciling, textile_making, woodworking])\npresentations = EnumSort([1, 2, 3, 4, 5, 6])\ngives = Function([teachers, subjects, presentations] -> [bool])\n\n# Constraints\nForAll([t:teachers], Count([s:subjects], gives(t, s, presentations[s])) >= 1) ::: each teacher gives at least one subject\nAnd(gives(Kudrow, pottery, presentations[2]), Count([t:teachers], And(t != Kudrow, gives(t, pottery, presentations[2]))) == 1) ::: Kudrow cannot give two presentations in a row\nAnd(gives(Kudrow, stenciling, presentations[3]), Count([t:teachers], And(t != Kudrow, gives(t, stenciling, presentations[3]))) == 1) ::: the presentation on stenciling must be given earlier than the one on origami\nAnd(gives(Lanning, woodworking, presentations[5]), Count([t:teachers], And(t != Lanning, gives(t, woodworking, presentations[5]))) == 1) ::: the presentation on textile making must be given earlier than the one on woodworking\n\n# Options\nQuestion ::: Which one of the following could be true if needlework is presented first?\nis_valid(ForAll([p:presentations], gives(Jiang, needlework, p) == True)) ::: (A)\nis_valid(ForAll([p:presentations], gives(Kudrow, stenciling, p) == True)) ::: (B)\nis_valid(ForAll([p:presentations], gives(Lanning, woodworking, p) == True)) ::: (C)\nis_valid(ForAll([p:presentations], gives(Xena, origami, p) == True)) ::: (D)\nis_valid(ForAll([p:presentations], gives(Yolanda, textile_making, p) == True)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem description and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_2_9",
    "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
    "question": "Jiang CANNOT give both",
    "answer": "B",
    "options": [
      "A) the first and third presentations",
      "B) the first and fourth presentations",
      "C) the first and fifth presentations",
      "D) the second and third presentations",
      "E) the second and fourth presentations"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAs part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.\nQuestion:\nJiang CANNOT give both\nChoices:\n[[CHOICES]]\n###\n# Declarations\nteachers = EnumSort([Jiang, Kudrow, Lanning])\nsubjects = EnumSort([needlework, origami, pottery, stenciling, textile_making, woodworking])\npresentations = EnumSort([1, 2, 3, 4, 5, 6])\ngives = Function([teachers, subjects, presentations] -> [bool])\n\n# Constraints\nForAll([t:teachers], Count([s:subjects], gives(t, s, presentations)) >= 1) ::: each teacher gives at least one presentation\nAnd(gives(Kudrow, pottery, presentations[2]) == False, gives(Kudrow, stenciling, presentations[3]) == False) ::: Kudrow cannot give two presentations in a row\nAnd(gives(Lanning, woodworking, presentations[5]) == False, gives(Lanning, textile_making, presentations[6]) == False) ::: Lanning cannot give two presentations in a row\n\n# Options\nQuestion ::: Jiang CANNOT give both\nis_valid(Exists([p:presentations], gives(Jiang, needlework, p) == gives(Jiang, origami, p))) ::: (A)\nis_valid(Exists([p:presentations], gives(Jiang, pottery, p) == gives(Jiang, origami, p))) ::: (B)\nis_valid(Exists([p:presentations], gives(Jiang, textile_making, p) == gives(Jiang, origami, p))) ::: (C)\nis_valid(Exists([p:presentations], gives(Jiang, woodworking, p) == gives(Jiang, origami, p))) ::: (D)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may have different constraints and options."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_2_10",
    "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
    "question": "If needlework is presented sixth, which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) Origami is presented fourth.",
      "B) Pottery is presented fifth.",
      "C) Stenciling is presented third.",
      "D) Textile making is presented first.",
      "E) Woodworking is presented fourth."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAs part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.\nQuestion:\nIf needlework is presented sixth, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nteachers = EnumSort([Jiang, Kudrow, Lanning])\nsubjects = EnumSort([needlework, origami, pottery, stenciling, textile_making, woodworking])\npresentations = EnumSort([1, 2, 3, 4, 5, 6])\ngives = Function([teachers, subjects, presentations] -> [bool])\n\n# Constraints\nForAll([t:teachers], Count([s:subjects], gives(t, s, presentations[s])) >= 1) ::: each teacher gives at least one subject\nAnd(gives(Kudrow, pottery, presentations[2]), Count([t:teachers], And(t != Kudrow, gives(t, pottery, presentations[2]))) == 1) ::: Kudrow cannot give two presentations in a row\nAnd(gives(Kudrow, stenciling, presentations[3]), Count([t:teachers], And(t != Kudrow, gives(t, stenciling, presentations[3]))) == 1) ::: the presentation on stenciling must be given earlier than the one on origami\nAnd(gives(Lanning, woodworking, presentations[5]), Count([t:teachers], And(t != Lanning, gives(t, woodworking, presentations[5]))) == 1) ::: the presentation on textile making must be given earlier than the one on woodworking\n\n# Options\nQuestion ::: Which one of the following must be true if needlework is presented sixth?\nis_valid(ForAll([p:presentations], gives(Jiang, needlework, p) == True)) ::: (A)\nis_valid(ForAll([p:presentations], gives(Kudrow, stenciling, p) == True)) ::: (B)\nis_valid(ForAll([p:presentations], gives(Lanning, woodworking, p) == True)) ::: (C)\nis_valid(ForAll([p:presentations], gives(Xena, origami, p) == True)) ::: (D)\nis_valid(ForAll([p:presentations], gives(Yolanda, textile_making, p) == True)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem description and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_2_11",
    "context": "As part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.",
    "question": "Which one of the following CANNOT be the subject of the second presentation?",
    "answer": "C",
    "options": [
      "A) needlework",
      "B) origami",
      "C) pottery",
      "D) textile making",
      "E) woodworking"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAs part of an open house at a crafts studio, three teachers—Jiang, Kudrow, and Lanning—will give six consecutive presentations on six different subjects. Jiang will present on needlework and origami; Kudrow on pottery, stenciling, and textile making; and Lanning on woodworking. The order of their presentations will meet the following conditions: Kudrow cannot give two presentations in a row. The presentation on stenciling must be given earlier than the one on origami. The presentation on textile making must be given earlier than the one on woodworking.\nQuestion:\nWhich one of the following CANNOT be the subject of the second presentation?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nteachers = EnumSort([Jiang, Kudrow, Lanning])\nsubjects = EnumSort([needlework, origami, pottery, stenciling, textile_making, woodworking])\npresentations = EnumSort([1, 2, 3, 4, 5, 6])\ngives = Function([teachers, subjects, presentations] -> [bool])\n\n# Constraints\nForAll([t:teachers], Count([s:subjects], gives(t, s, presentations[s])) >= 1) ::: each teacher gives at least one subject\nAnd(gives(Kudrow, pottery, presentations[2]), Count([t:teachers], And(t != Kudrow, gives(t, pottery, presentations[2]))) == 1) ::: Kudrow cannot give two presentations in a row\nAnd(gives(Kudrow, stenciling, presentations[3]), Count([t:teachers], And(t != Kudrow, gives(t, stenciling, presentations[3]))) == 1) ::: the presentation on stenciling must be given earlier than the one on origami\nAnd(gives(Lanning, woodworking, presentations[5]), Count([t:teachers], And(t != Lanning, gives(t, woodworking, presentations[5]))) == 1) ::: the presentation on textile making must be given earlier than the one on woodworking\n\n# Options\nQuestion ::: Which one of the following CANNOT be the subject of the second presentation?\nis_valid(ForAll([s:subjects], gives(Jiang, s, presentations[s]) == gives(Kudrow, s, presentations[s]))) ::: (A)\nis_valid(ForAll([s:subjects], gives(Kudrow, s, presentations[s]) == gives(Lanning, s, presentations[s]))) ::: (B)\nis_valid(ForAll([s:subjects], gives(Lanning, s, presentations[s]) == gives(Jiang, s, presentations[s]))) ::: (C)\nis_valid(ForAll([s:subjects], gives(Kudrow, s, presentations[s]) == gives(Lanning, s, presentations[s]))) ::: (D)\nis_valid(ForAll([s:subjects], gives(Lanning, s, presentations[s]) == gives(Kudrow, s, presentations[s]))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_3_12",
    "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
    "question": "Which one of the following is a list of foods that could be the foods selected?",
    "answer": "B",
    "options": [
      "A) F, N, O, T, V",
      "B) F, O, P, T, W",
      "C) G, N, P, T, W",
      "D) G, O, P, T, V",
      "E) G, O, P, V, W"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nThe organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.\nQuestion:\nWhich one of the following is a list of foods that could be the foods selected?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfoods = EnumSort([F, G, N, O, P, T, V, W])\n\n# Constraints\nForAll([f:foods], Count([f:foods], f == F) >= 1) ::: at least one dessert must be selected\nForAll([f:foods], Count([f:foods], f == N) >= 1) ::: at least one main course must be selected\nForAll([f:foods], Count([f:foods], f == T) >= 1) ::: at least one side dish must be selected\nForAll([f:foods], Implies(f == P, f == W)) ::: if either P or W is selected, both must be selected\nForAll([f:foods], Implies(f == G, f == O)) ::: if G is selected, O must be selected\nForAll([f:foods], Implies(f == N, f != V)) ::: if N is selected, V cannot be selected\n\n# Options\nQuestion ::: Which one of the following is a list of foods that could be the foods selected?\nis_valid(Exists([f:foods], [f == F, f == N, f == T, f == P, f == W])) ::: (A)\nis_valid(Exists([f:foods], [f == G, f == O, f == T, f == P, f == W])) ::: (B)\nis_valid(Exists([f:foods], [f == F, f == N, f == T, f == P, f == V])) ::: (C)\nis_valid(Exists([f:foods], [f == G, f == O, f == T, f == P, f == V])) ::: (D)\nis_valid(Exists([f:foods], [f == F, f == N, f == T, f == W, f == V])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_3_13",
    "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
    "question": "Which one of the following is a pair of foods of which the organizer of the luncheon must select at least one?",
    "answer": "D",
    "options": [
      "A) F, T",
      "B) G, O",
      "C) N, T",
      "D) O, P",
      "E) V, W"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nThe organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.\nQuestion:\nWhich one of the following is a pair of foods of which the organizer of the luncheon must select at least one?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfoods = EnumSort([F, G, N, O, P, T, V, W])\n\n# Constraints\nForAll([f:foods], Count([m:foods], f in [main_courses, side_dishes]) >= 1) ::: at least one dessert, at least one main course, and at least one side dish must be selected\nForAll([f:foods], Count([m:foods], f in [hot_foods]) >= 1) ::: at least one hot food must be selected\nForAll([p:foods], Implies(p == P, p == W)) ::: if either P or W is selected, both must be selected\nForAll([p:foods], Implies(p == G, p == O)) ::: if G is selected, O must be selected\nForAll([p:foods], Implies(p == N, p != V)) ::: if N is selected, V cannot be selected\n\n# Options\nQuestion ::: Which one of the following is a pair of foods of which the organizer of the luncheon must select at least one?\nis_valid(Exists([f:foods], f in [main_courses, side_dishes] -> f == N)) ::: (A)\nis_valid(Exists([f:foods], f in [main_courses, side_dishes] -> f == T)) ::: (B)\nis_valid(Exists([f:foods], f in [hot_foods] -> f == F)) ::: (C)\nis_valid(Exists([f:foods], f in [hot_foods] -> f == W)) ::: (D)\nis_valid(Exists([f:foods], f in [main_courses, side_dishes] -> f == O)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_3_14",
    "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
    "question": "If O is the only main course selected, then which one of the following CANNOT be selected?",
    "answer": "E",
    "options": [
      "A) F",
      "B) G",
      "C) T",
      "D) V",
      "E) W"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nThe organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.\nQuestion:\nIf O is the only main course selected, then which one of the following CANNOT be selected?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfoods = EnumSort([F, G, N, O, P, T, V, W])\nmain_courses = EnumSort([N, O, P])\ndesserts = EnumSort([F, G])\nside_dishes = EnumSort([T, V, W])\n\n# Constraints\nForAll([m:main_courses], Count([f:foods], m in [f, G])) ::: At least one main course must be selected\nForAll([f:foods], Count([m:main_courses], m in [f, G]) >= 1) ::: At least one main course must be selected\nForAll([m:main_courses], Implies(m == P, Not(m == W))) ::: If either P or W is selected, both must be selected\nForAll([m:main_courses], Implies(m == G, m == O)) ::: If G is selected, O must be selected\nForAll([m:main_courses], Implies(m == N, Not(m == V))) ::: If N is selected, V cannot be selected\n\n# Options\nQuestion ::: If O is the only main course selected, then which one of the following CANNOT be selected?\nis_valid(Exists([f:foods], f in [T, V, W] -> Not(f == O))) ::: (A)\nis_valid(Exists([m:main_courses], m in [N, P] -> Not(m == O))) ::: (B)\nis_valid(Exists([f:foods], f in [F, G] -> Not(f == O))) ::: (C)\nis_valid(Exists([m:main_courses], m in [O, P] -> Not(m == W))) ::: (D)\nis_valid(Exists([m:main_courses], m in [O, N] -> Not(m == V))) ::: (E)\n\n------\n\nNote: The problem and question are given in a propositional logic form, where the variables are represented by capital letters (e.g., Vladimir, Wendy, Stacy, Urma, etc.), and the constraints and options are represented by logical formulas. To solve the problem, we need to translate the given information into a logic program, which can be used to compute the answer to the question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_3_15",
    "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
    "question": "If F is not selected, which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) P is the only main course selected.",
      "B) T is the only side dish selected.",
      "C) Exactly two hot foods are selected.",
      "D) Exactly three main courses are selected.",
      "E) Exactly three side dishes are selected."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nThe organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.\nQuestion:\nIf F is not selected, which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfoods = EnumSort([F, G, N, O, P, T, V, W])\nmain_courses = EnumSort([N, O, P])\nside_dishes = EnumSort([T, V, W])\nhot_foods = EnumSort([F, T])\n\n# Constraints\nForAll([f:foods], Count([m:main_courses, s:side_dishes], f in m or f in s)) ::: At least one dessert, at least one main course, and at least one side dish must be selected\nForAll([m:main_courses], Count([s:side_dishes], m in s) >= 1) ::: At least one main course must be selected\nForAll([s:side_dishes], Count([m:main_courses], s in m) >= 1) ::: At least one side dish must be selected\nForAll([f:hot_foods], Count([m:main_courses, s:side_dishes], f in m or f in s) >= 1) ::: At least one hot food must be selected\nExists([m:main_courses], m == P and m == W) ::: If P is selected, W must be selected\nExists([s:side_dishes], s == G and s == O) ::: If G is selected, O must be selected\nExists([m:main_courses], m == N and not m == W) ::: If N is selected, V cannot be selected\n\n# Options\nQuestion ::: If F is not selected, which one of the following could be true?\nis_valid(ForAll([m:main_courses], m == N)) ::: (A)\nis_valid(ForAll([s:side_dishes], s == G)) ::: (B)\nis_valid(ForAll([m:main_courses], m == O)) ::: (C)\nis_valid(ForAll([s:side_dishes], s == V)) ::: (D)\nis_valid(ForAll([m:main_courses], m == P)) ::: (E)\n\n------\n\nNote: The `is_sat` function is used to check satisfiability of a formula, and `is_valid` is used to check validity of a formula."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_3_16",
    "context": "The organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.",
    "question": "If T and V are the only side dishes selected, then which one of the following is a pair of foods each of which must be selected?",
    "answer": "A",
    "options": [
      "A) F and G",
      "B) F and N",
      "C) F and P",
      "D) N and O",
      "E) O and P"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nThe organizer of a luncheon will select exactly five foods to be served from among exactly eight foods: two desserts—F and G; three main courses—N, O, and P; three side dishes—T, V, and W. Only F, N, and T are hot foods. The following requirements will be satisfied: At least one dessert, at least one main course, and at least one side dish must be selected. At least one hot food must be selected. If either P or W is selected, both must be selected. If G is selected, O must be selected. If N is selected, V cannot be selected.\nQuestion:\nIf T and V are the only side dishes selected, then which one of the following is a pair of foods each of which must be selected?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfoods = EnumSort([F, G, N, O, P, T, V, W])\nselections = EnumSort([desserts, main_courses, side_dishes])\n\n# Constraints\nForAll([s:selections], Count([f:foods], s == f) >= 1) ::: each selection is a food\nAnd(Count([f:foods], s == F) >= 1, Count([f:foods], s == G) >= 1) ::: at least one dessert and at least one hot food must be selected\nAnd(Count([f:foods], s == N) >= 1, Count([f:foods], s == O) >= 1) ::: at least one main course and at least one hot food must be selected\nAnd(Count([f:foods], s == P) >= 1, Count([f:foods], s == W) >= 1) ::: at least one main course and at least one hot food must be selected\nImplies(s == T, s == V) ::: T and V are the only side dishes selected\nImplies(s == N, s == V) ::: N and V are not selected\nImplies(s == O, s == W) ::: O and W are not selected\n\n# Options\nQuestion ::: Which one of the following is a pair of foods each of which must be selected?\nis_valid(Exists([s:selections], s == T, s == V)) ::: (A)\nis_valid(Exists([s:selections], s == T, s == W)) ::: (B)\nis_valid(Exists([s:selections], s == V, s == W)) ::: (C)\nis_valid(Exists([s:selections], s == T, s == O)) ::: (D)\nis_valid(Exists([s:selections], s == V, s == N)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_4_17",
    "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
    "question": "Which one of the following could be the order in which the programs are shown, from earliest to latest?",
    "answer": "B",
    "options": [
      "A) Generations, Roamin', Waterloo, Terry, Sundown",
      "B) Roamin', Sundown, Waterloo, Terry, Generations",
      "C) Roamin', Terry, Waterloo, Generations, Sundown",
      "D) Waterloo, Roamin', Sundown, Terry, Generations",
      "E) Waterloo, Terry, Sundown, Roamin', Generations"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.\nQuestion:\nWhich one of the following could be the order in which the programs are shown, from earliest to latest?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprograms = EnumSort([Generations, Roamin', Sundown, Terry, Waterloo])\nschedule = Function([hours:time] -> [programs])\n\n# Constraints\nForAll([h:time], Schedule(h) == [programs]) ::: The schedule must be a function that takes a time as input and returns a list of programs\nImplies(Schedule(1), [Generations]) ::: Generations starts on the hour rather than the half hour\nImplies(Schedule(1), [Terry]) ::: Terry starts on the half hour rather than the hour\nImplies(Schedule(1), [Roamin']) ::: Roamin' is shown earlier than Sundown\nImplies(Schedule(2), [Sundown]) ::: Sundown is shown later than Roamin'\nImplies(Schedule(3), [Terry]) ::: If Waterloo is shown earlier than Terry, it is shown immediately before Terry\n\n# Options\nQuestion ::: Which one of the following could be the order in which the programs are shown, from earliest to latest?\nis_valid(Schedule([Generations, Roamin', Sundown, Terry, Waterloo])) ::: (A)\nis_valid(Schedule([Generations, Terry, Roamin', Sundown, Waterloo])) ::: (B)\nis_valid(Schedule([Terry, Roamin', Sundown, Generations, Waterloo])) ::: (C)\nis_valid(Schedule([Waterloo, Terry, Roamin', Sundown, Generations])) ::: (D)\nis_valid(Schedule([Sundown, Roamin', Terry, Generations, Waterloo])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_4_18",
    "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
    "question": "If Waterloo is the first program, then how many orders are there in which the remaining programs could be shown?",
    "answer": "B",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.\nQuestion:\nIf Waterloo is the first program, then how many orders are there in which the remaining programs could be shown?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprograms = EnumSort([Generations, Roamin', Sundown, Terry, Waterloo])\ntime = EnumSort([1, 2, 3, 4])\norders = EnumSort([[time, program] -> [bool]])\n\n# Constraints\nForAll([t:time], Count([p:programs], And(p != Generations, orders(t, p)))) == 3) ::: Generations starts on the hour rather than the half hour\nForAll([t:time], Implies(orders(t, Terry), orders(t + 1, Waterloo))) ::: Terry starts on the half hour rather than the hour\nForAll([t:time], Implies(orders(t, Roamin'), orders(t + 1, Sundown))) ::: Roamin' is shown earlier than Sundown\nForAll([t:time], Implies(orders(t, Waterloo), orders(t + 1, Terry))) ::: If Waterloo is shown earlier than Terry, it is shown immediately before Terry\n\n# Options\nQuestion ::: ::: If Waterloo is the first program, then how many orders are there in which the remaining programs could be shown?\nis_sat(ForAll([t:time], orders(t, Waterloo) == orders(t + 1, Terry))) ::: (A)\nis_sat(ForAll([t:time], orders(t, Waterloo) == orders(t + 1, Roamin'))) ::: (B)\nis_sat(ForAll([t:time], orders(t, Waterloo) == orders(t + 1, Sundown))) ::: (C)\nis_sat(ForAll([t:time], orders(t, Waterloo) == orders(t + 1, Terry))) ::: (D)\nis_sat(ForAll([t:time], orders(t, Waterloo) == orders(t + 1, Roamin'))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_4_19",
    "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
    "question": "If Roamin' is the second program, then each of the following could be true EXCEPT:",
    "answer": "D",
    "options": [
      "A) Sundown is the third program.",
      "B) Sundown is the fourth program.",
      "C) Terry is the fifth program.",
      "D) Waterloo is the third program.",
      "E) Waterloo is the fifth program."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.\nQuestion:\nIf Roamin' is the second program, then each of the following could be true EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprograms = EnumSort([Generations, Roamin', Sundown, Terry, Waterloo])\nschedule = Function([hours:time] -> [programs])\n\n# Constraints\nForAll([h:time], schedule(h) == [programs]) ::: The schedule must be a list of programs\nAnd(schedule(1) == [Roamin', Generations], schedule(2) == [Sundown, Terry]) ::: Roamin' is the second program\nOr(schedule(3) == [Waterloo, Terry], schedule(4) == [Terry, Waterloo]) ::: Terry is shown earlier than Waterloo\n\n# Options\nQuestion ::: If Roamin' is the second program, then each of the following could be true EXCEPT:\nis_valid(ForAll([h:time], schedule(h) == [Roamin', Sundown, Terry, Waterloo]))) ::: (A)\nis_valid(ForAll([h:time], schedule(h) == [Roamin', Terry, Sundown, Waterloo]))) ::: (B)\nis_valid(ForAll([h:time], schedule(h) == [Roamin', Terry, Waterloo, Sundown]))) ::: (C)\nis_valid(ForAll([h:time], schedule(h) == [Roamin', Sundown, Terry, Waterloo]))) ::: (D)\nis_valid(ForAll([h:time], schedule(h) == [Roamin', Waterloo, Terry, Sundown]))) ::: (E)\n\n------\n\nNote: The above code is just an example, and you may need to modify it to fit your specific problem."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_4_20",
    "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
    "question": "If Sundown is the third program, then which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) Generations is the first program.",
      "B) Roamin' is the first program.",
      "C) Roamin' is the second program.",
      "D) Terry is the fifth program.",
      "E) Waterloo is the fourth program."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.\nQuestion:\nIf Sundown is the third program, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprograms = EnumSort([Generations, Roamin', Sundown, Terry, Waterloo])\nschedule = Function([hours:time] -> [programs])\n\n# Constraints\nForAll([h:time], schedule(h) == [programs]) ::: The schedule must be a function that takes a time as input and returns a list of programs\nAnd(schedule(1) == [Generations], schedule(2) == [Roamin', Sundown]) ::: Generations starts on the hour rather than the half hour\nAnd(schedule(3) == [Terry], schedule(4) == [Waterloo]) ::: Terry starts on the half hour rather than the hour\nAnd(schedule(4) == [Waterloo], schedule(5) == [Terry]) ::: If Waterloo is shown earlier than Terry, it is shown immediately before Terry\n\n# Options\nQuestion ::: Which one of the following must be true if Sundown is the third program?\nis_valid(ForAll([h:time], schedule(h) == [Generations, Roamin', Sundown, Terry, Waterloo]))) ::: (A)\nis_valid(ForAll([h:time], schedule(h) == [Generations, Roamin', Terry, Waterloo, Sundown]))) ::: (B)\nis_valid(ForAll([h:time], schedule(h) == [Generations, Roamin', Terry, Sundown, Waterloo]))) ::: (C)\nis_valid(ForAll([h:time], schedule(h) == [Terry, Waterloo, Generations, Roamin', Sundown]))) ::: (D)\nis_valid(ForAll([h:time], schedule(h) == [Waterloo, Terry, Generations, Roamin', Sundown]))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_4_21",
    "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
    "question": "If Generations is the third program, then which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) Roamin' is the second program.",
      "B) Roamin' is the fifth program.",
      "C) Sundown is the fourth program.",
      "D) Terry is the fourth program.",
      "E) Waterloo is the second program."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.\nQuestion:\nIf Generations is the third program, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprograms = EnumSort([Generations, Roamin', Sundown, Terry, Waterloo])\nschedule = Function([hours:time] -> [programs])\n\n# Constraints\nForAll([h:time], schedule(h) == [programs]) ::: The schedule must be a list of programs\nAnd(schedule(1) == [Generations], Generations starts on the hour rather than the half hour) ::: Generations starts on the hour\nAnd(schedule(2) == [Roamin', Sundown], Roamin' is shown earlier than Sundown) ::: Roamin' is shown earlier than Sundown\nAnd(schedule(3) == [Terry, Waterloo], Terry starts on the half hour rather than the hour) ::: Terry starts on the half hour\nAnd(schedule(4) == [Terry, Waterloo], If Waterloo is shown earlier than Terry, it is shown immediately before Terry) ::: Waterloo is shown earlier than Terry\n\n# Options\nQuestion ::: Which one of the following could be true if Generations is the third program?\nis_valid(ForAll([h:time], schedule(h) == [Generations, Roamin', Sundown, Terry, Waterloo]))) ::: (A)\nis_valid(ForAll([h:time], schedule(h) == [Generations, Roamin', Sundown, Terry, Waterloo, Waterloo])) ::: (B)\nis_valid(ForAll([h:time], schedule(h) == [Generations, Roamin', Sundown, Terry, Terry])) ::: (C)\nis_valid(ForAll([h:time], schedule(h) == [Generations, Roamin', Sundown, Terry, Sundown])) ::: (D)\nis_valid(ForAll([h:time], schedule(h) == [Generations, Roamin', Sundown, Terry, Terry, Sundown])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_4_22",
    "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "B",
    "options": [
      "A) Sundown is shown immediately before Generations.",
      "B) Waterloo is shown immediately before Roamin'.",
      "C) Generations is shown immediately before Sundown.",
      "D) Roamin' is shown immediately before Terry.",
      "E) Terry is shown immediately before Waterloo."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.\nQuestion:\nWhich one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprograms = EnumSort([Generations, Roamin', Sundown, Terry, Waterloo])\ntime = EnumSort([1, 2, 3, 4])\nschedule = Function([time] -> [programs])\n\n# Constraints\nForAll([t:time], schedule(t) != schedule(t + 1)) ::: each program is shown exactly once\nAnd(schedule(1) == Generations, Count([p:programs], p == Generations) == 1) ::: Generations starts on the hour rather than the half hour\nAnd(schedule(2) == Roamin', Count([p:programs], p == Roamin') == 1) ::: Roamin' is shown earlier than Sundown\nOr(schedule(3) == Terry, schedule(4) == Waterloo) ::: Terry starts on the half hour rather than the hour\nOr(schedule(3) == Waterloo, schedule(4) == Terry) ::: If Waterloo is shown earlier than Terry, it is shown immediately before Terry\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_valid(Exists([t:time], schedule(t) == Generations)) ::: (A)\nis_valid(Exists([t:time], schedule(t) == Roamin')) ::: (B)\nis_valid(Exists([t:time], schedule(t) == Sundown)) ::: (C)\nis_valid(Exists([t:time], schedule(t) == Terry)) ::: (D)\nis_valid(Exists([t:time], schedule(t) == Waterloo)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201112_2-G_4_23",
    "context": "A television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.",
    "question": "Which one of the following, if substituted for the constraint that Generations starts on the hour rather than the half hour, would have the same effect in determining the order in which the programs are shown?",
    "answer": "C",
    "options": [
      "A) Generations is not shown immediately before Terry.",
      "B) Generations is either the first program or the fifth.",
      "C) Generations is neither the second program nor the fourth.",
      "D) If Generations is shown third, then Roamin' is shown first.",
      "E) If Generations is not shown first, then it is shown later than Terry."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA television programming director is scheduling a three-hour block of programs beginning at 1 P.M. The programs that are to fill this time block include an hour-long program called Generations and four half-hour programs: Roamin', Sundown, Terry, and Waterloo. The programs will be shown one after the other, each program shown exactly once. The schedule must meet the following constraints: Generations starts on the hour rather than the half hour. Terry starts on the half hour rather than the hour. Roamin' is shown earlier than Sundown. If Waterloo is shown earlier than Terry, it is shown immediately before Terry.\nQuestion:\nWhich one of the following, if substituted for the constraint that Generations starts on the hour rather than the half hour, would have the same effect in determining the order in which the programs are shown?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprograms = EnumSort([Generations, Roamin', Sundown, Terry, Waterloo])\ntime = EnumSort([1, 2, 3, 4])\nschedule = Function([time] -> [programs])\n\n# Constraints\nForAll([t:time], schedule(t) == [programs[0], programs[1], programs[2], programs[3], programs[4]])) ::: The schedule must consist of five programs, shown one after the other\nAnd(schedule(1) == [Generations], schedule(2) == Roamin') ::: Generations starts on the hour rather than the half hour\nAnd(schedule(3) == Terry, schedule(4) == Waterloo) ::: Terry starts on the half hour rather than the hour\nAnd(schedule(2) == Sundown, schedule(4) == Terry) ::: Roamin' is shown earlier than Sundown\nOr(schedule(3) == Waterloo, schedule(4) == Terry) ::: Waterloo is shown earlier than Terry\n\n# Options\nQuestion ::: Which one of the following, if substituted for the constraint that Generations starts on the hour rather than the half hour, would have the same effect in determining the order in which the programs are shown?\nis_sat(ForAll([t:time], schedule(t) == [Generations, Roamin', Sundown, Terry, Waterloo]))) ::: (A)\nis_sat(ForAll([t:time], schedule(t) == [Generations, Roamin', Terry, Sundown, Waterloo]))) ::: (B)\nis_sat(ForAll([t:time], schedule(t) == [Generations, Roamin', Terry, Waterloo, Sundown]))) ::: (C)\nis_sat(ForAll([t:time], schedule(t) == [Generations, Roamin', Sundown, Terry, Waterloo]))) ::: (D)\nis_sat(ForAll([t:time], schedule(t) == [Generations, Roamin', Waterloo, Sundown, Terry]))) ::: (E)\n\n------\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_1_1",
    "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
    "question": "Which one of the following could be a list of the majors of Manolo, Nadia, Owen, Peng, and Rana, respectively?",
    "answer": "C",
    "options": [
      "A) geology, geology, journalism, journalism, history",
      "B) geology, geology, history, history, history",
      "C) history, geology, geology, journalism, history",
      "D) history, geology, journalism, geology, history",
      "E) history, history, geology, journalism, history"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFive students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.\nQuestion:\nWhich one of the following could be a list of the majors of Manolo, Nadia, Owen, Peng, and Rana, respectively?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nstudents = EnumSort([Manolo, Nadia, Owen, Peng, Rana])\ntopics = EnumSort([friendship, liberty])\nspeeches = EnumSort([geology, history, journalism])\nmajors = EnumSort([geology, history])\nspeak = Function([students, topics] -> [speeches])\n\n# Constraints\nForAll([s:students], speak(s, topics[0]) == speeches[geology]) ::: Exactly two of the students speak on friendship\nAnd(speak(Manolo, topics[0]), speak(Nadia, topics[0])) ::: Manolo speaks on friendship\nOr(speak(Rana, topics[1]), speak(Peng, topics[1])) ::: Rana speaks on liberty\nNot(speak(Peng, speeches[geology]), speak(Rana, speeches[geology])) ::: Neither Peng nor Rana is a geology major\nspeak(Nadia, topics[0]) == speeches[geology] ::: Nadia is a geology major\n\n# Options\nQuestion ::: Which one of the following could be a list of the majors of Manolo, Nadia, Owen, Peng, and Rana, respectively?\nis_valid(Exists([m:majors], m == geology)) ::: (A)\nis_valid(Exists([m:majors], m == history)) ::: (B)\nis_valid(Exists([m:majors], m == journalism)) ::: (C)\nis_valid(Exists([m:majors], m == geology, And(m != Rana))) ::: (D)\nis_valid(Exists([m:majors], m == history, And(m != Peng))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_1_2",
    "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
    "question": "If Peng speaks on friendship, then which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Manolo is a history major.",
      "B) Nadia speaks on friendship.",
      "C) Owen speaks on friendship.",
      "D) Owen is a journalism major.",
      "E) Peng is a journalism major."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFive students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.\nQuestion:\nIf Peng speaks on friendship, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nstudents = EnumSort([Manolo, Nadia, Owen, Peng, Rana])\ntopics = EnumSort([friendship, liberty])\nmajors = EnumSort([geology, history])\nspeeches = Function([students, topics] -> [majors])\n\n# Constraints\nForAll([s:students], Count([t:topics], speeches(s, t)) >= 1) ::: each student delivers exactly one speech\nAnd(speeches(Manolo, friendship), speeches(Rana, liberty)) ::: Manolo speaks on friendship, and Rana speaks on liberty\nForAll([m:majors], Implies(speeches(m, friendship), Not(speeches(m, liberty)))) ::: Exactly two of the students speak on friendship\nForAll([m:majors], Implies(speeches(m, friendship), (m == geology) Or (m == history))) ::: A geology major and a history major speak on friendship\nspeeches(Peng, friendship) ::: Peng speaks on friendship\nspeeches(Rana, liberty) ::: Rana speaks on liberty\nNeither(speeches(Peng, liberty), speeches(Rana, geology)) ::: Neither Peng nor Rana is a geology major\nspeeches(Nadia, geology) ::: Nadia is a geology major\n\n# Options\nQuestion ::: Which one of the following could be true if Peng speaks on friendship?\nis_valid(ForAll([m:majors], speeches(Peng, m) == speeches(Rana, m))) ::: (A)\nis_valid(ForAll([m:majors], speeches(Peng, m) == speeches(Nadia, m))) ::: (B)\nis_valid(ForAll([m:majors], speeches(Peng, m) == speeches(Owen, m))) ::: (C)\nis_valid(ForAll([m:majors], speeches(Peng, m) == speeches(Manolo, m))) ::: (D)\nis_valid(ForAll([m:majors], speeches(Peng, m) == speeches(Rana, m))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_1_3",
    "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
    "question": "If Owen is a geology major who speaks on friendship, then which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) Manolo is a history major.",
      "B) Nadia speaks on friendship.",
      "C) Peng speaks on friendship.",
      "D) Peng is a history major.",
      "E) Rana is a journalism major."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFive students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.\nQuestion:\nIf Owen is a geology major who speaks on friendship, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nstudents = EnumSort([Manolo, Nadia, Owen, Peng, Rana])\ntopics = EnumSort([friendship, liberty])\nmajors = EnumSort([geology, history])\nspeeches = Function([students, topics] -> [majors])\n\n# Constraints\nForAll([s:students], Count([t:topics], speeches(s, t)) >= 1) ::: each student delivers exactly one speech\nAnd(speeches(Manolo, friendship), speeches(Rana, liberty)) ::: Manolo speaks on friendship, Rana speaks on liberty\nForAll([m:majors], Implies(speeches(m, friendship), Not(speeches(m, liberty)))) ::: Exactly two of the students speak on friendship\nForAll([m:majors], Implies(speeches(m, friendship), (m == geology) Or (m == history))) ::: A geology major and a history major speak on friendship\nspeeches(Owen, friendship) ::: Owen is a geology major who speaks on friendship\nspeeches(Peng, liberty) ::: Neither Peng nor Rana is a geology major\nspeeches(Nadia, geology) ::: Nadia is a geology major\n\n# Options\nQuestion ::: ::: If Owen is a geology major who speaks on friendship, then which one of the following must be true?\nis_sat(ForAll([m:majors], speeches(Owen, m) == friendship)) ::: (A)\nis_sat(ForAll([m:majors], speeches(Owen, m) == liberty)) ::: (B)\nis_sat(ForAll([m:majors], speeches(Owen, m) == geology)) ::: (C)\nis_sat(ForAll([m:majors], speeches(Owen, m) == history)) ::: (D)\nis_sat(ForAll([m:majors], speeches(Owen, m) == friendship Or speeches(Owen, m) == liberty)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_1_4",
    "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
    "question": "If Nadia speaks on friendship, then which one of the following must be false?",
    "answer": "A",
    "options": [
      "A) Manolo is a geology major.",
      "B) Manolo is a history major.",
      "C) Owen is a geology major.",
      "D) Peng is a history major.",
      "E) Rana is a history major."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFive students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.\nQuestion:\nIf Nadia speaks on friendship, then which one of the following must be false?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nstudents = EnumSort([Manolo, Nadia, Owen, Peng, Rana])\ntopics = EnumSort([friendship, liberty])\nmajors = EnumSort([geology, history])\nspeeches = Function([students, topics] -> [bool])\n\n# Constraints\nForAll([t:topics], Count([s:students], speeches(s, t)) >= 1) ::: each topic has at least one speech\nAnd(speeches(Manolo, friendship), speeches(Rana, liberty)) ::: Manolo speaks on friendship, and Rana speaks on liberty\nForAll([s:students], Implies(speeches(s, friendship), Not(speeches(s, liberty)))] ::: Exactly two of the students speak on friendship\nForAll([s:students], Implies(speeches(s, geology), Not(speeches(s, history)))) ::: A geology major and a history major speak on friendship\nspeeches(Nadia, friendship) ::: Nadia speaks on friendship\nspeeches(Peng, liberty) ::: Neither Peng nor Rana is a geology major\nspeeches(Rana, liberty) ::: Rana speaks on liberty\n\n# Options\nQuestion ::: Which one of the following must be false if Nadia speaks on friendship?\nis_valid(ForAll([s:students], speeches(s, friendship) == False)) ::: (A)\nis_valid(ForAll([s:students], speeches(s, liberty) == False)) ::: (B)\nis_valid(ForAll([s:students], speeches(s, geology) == False)) ::: (C)\nis_valid(ForAll([s:students], speeches(s, history) == False)) ::: (D)\nis_valid(ForAll([s:students], speeches(s, journalism) == False)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_1_5",
    "context": "Five students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.",
    "question": "Rana must be a journalism major if which one of the following is true?",
    "answer": "C",
    "options": [
      "A) Manolo is a geology major and Peng is a history major.",
      "B) Owen is a geology major and Manolo is a history major.",
      "C) Owen is a geology major and Peng is a history major.",
      "D) Both Manolo and Nadia speak on friendship.",
      "E) Both Manolo and Peng speak on friendship."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFive students—Manolo, Nadia, Owen, Peng, and Rana—are each to deliver exactly one speech. Speeches are on exactly one of two topics—friendship and liberty. Each student has only one major: two major in geology, two in history, and one in journalism. The following conditions must apply: Exactly two of the students speak on friendship. A geology major and a history major speak on friendship. Manolo speaks on friendship. Rana speaks on liberty. Neither Peng nor Rana is a geology major. Nadia is a geology major.\nQuestion:\nRana must be a journalism major if which one of the following is true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nstudents = EnumSort([Manolo, Nadia, Owen, Peng, Rana])\ntopics = EnumSort([friendship, liberty])\nmajors = EnumSort([geology, history, journalism])\nspeeches = Function([students, topics] -> [majors])\n\n# Constraints\nForAll([s:students], Count([t:topics], speeches(s, t)) >= 1) ::: each student delivers exactly one speech\nAnd(speeches(Manolo, friendship), Count([t:topics], And(t == friendship, speeches(s, t))) == 2) ::: Manolo speaks on friendship\nAnd(speeches(Rana, liberty), Not(speeches(Peng, liberty))) ::: Rana speaks on liberty\nForAll([t:topics], Implies(speeches(Peng, t), Not(speeches(Rana, t)))) ::: Neither Peng nor Rana is a geology major\nspeeches(Nadia, friendship) ::: Nadia is a geology major\n\n# Options\nQuestion ::: Rana must be a journalism major if which one of the following is true?\nis_valid(Exists([t:topics], speeches(Rana, t) == journalism)) ::: (A)\nis_valid(Exists([t:topics], speeches(Rana, t) == history)) ::: (B)\nis_valid(Exists([t:topics], speeches(Rana, t) == geology)) ::: (C)\nis_valid(Exists([t:topics], speeches(Rana, t) == liberty)) ::: (D)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_2_6",
    "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
    "question": "Which one of the following could be the order in which the professors lecture, from first to last?",
    "answer": "B",
    "options": [
      "A) Powell, Young, Taylor, Shihab, Vaughan, Zabel, Wood",
      "B) Taylor, Powell, Shihab, Wood, Vaughan, Young, Zabel",
      "C) Taylor, Vaughan, Shihab, Wood, Powell, Young, Zabel",
      "D) Vaughan, Taylor, Shihab, Powell, Wood, Zabel, Young",
      "E) Young, Taylor, Shihab, Powell, Vaughan, Zabel, Wood"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.\nQuestion:\nWhich one of the following could be the order in which the professors lecture, from first to last?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprofessors = EnumSort([Powell, Shihab, Taylor, Vaughan, Wood, Young, Zabel])\nlectures = EnumSort([1, 2, 3, 4, 5, 6, 7])\nlecture_order = Function([professors, lectures] -> [int])\n\n# Constraints\nForAll([p:professors], Count([l:lectures], lecture_order(p, l) == 1)) ::: each professor gives exactly one guest lecture\nAnd(ForAll([p:professors], Count([q:professors], And(p != q, lecture_order(p, l) < lecture_order(q, l)))), Powell(l) == 1) ::: Powell lectures first if, but only if, Young lectures before Vaughan\n\n# Options\nQuestion ::: Which one of the following could be the order in which the professors lecture, from first to last?\nis_valid(ForAll([l:lectures], lecture_order(Powell, l) == 1)) ::: (A)\nis_valid(ForAll([l:lectures], lecture_order(Shihab, l) == 3)) ::: (B)\nis_valid(ForAll([l:lectures], lecture_order(Taylor, l) == 2)) ::: (C)\nis_valid(ForAll([l:lectures], lecture_order(Vaughan, l) == 6)) ::: (D)\nis_valid(ForAll([l:lectures], lecture_order(Wood, l) == 4)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_2_7",
    "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
    "question": "Which one of the following could lecture first?",
    "answer": "B",
    "options": [
      "A) Shihab",
      "B) Vaughan",
      "C) Wood",
      "D) Young",
      "E) Zabel"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.\nQuestion:\nWhich one of the following could lecture first?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprofessors = EnumSort([Powell, Shihab, Taylor, Vaughan, Wood, Young, Zabel])\nlectures = EnumSort([1, 2, 3, 4, 5, 6, 7])\nlecture_order = Function([professors, lectures] -> [int])\n\n# Constraints\nForAll([p:professors], Count([l:lectures], lecture_order(p, l)) >= 1) ::: each professor gives exactly one guest lecture\nAnd(lecture_order(Powell, 1), Not(lecture_order(Young, 1))) ::: Powell lectures first if, but only if, Young lectures before Vaughan\nForAll([l:lectures], Implies(lecture_order(Vaughan, l), Not(lecture_order(Shihab, l)))) ::: Vaughan lectures before Zabel\nCount([l:lectures], lecture_order(Shihab, l)) <= 3 ::: Shihab is no later than third\nCount([l:lectures], lecture_order(Young, l)) != 7 ::: Young is not seventh\n\n# Options\nQuestion ::: Which one of the following could lecture first?\nis_valid(ForAll([p:professors], lecture_order(p, 1))) ::: (A)\nis_valid(ForAll([p:professors], lecture_order(p, 2))) ::: (B)\nis_valid(ForAll([p:professors], lecture_order(p, 3))) ::: (C)\nis_valid(ForAll([p:professors], lecture_order(p, 4))) ::: (D)\nis_valid(ForAll([p:professors], lecture_order(p, 5))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_2_8",
    "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
    "question": "Which one of the following CANNOT given the second guest lecture?",
    "answer": "E",
    "options": [
      "A) Powell",
      "B) Shihab",
      "C) Taylor",
      "D) Vaughan",
      "E) Wood"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.\nQuestion:\nWhich one of the following CANNOT given the second guest lecture?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprofessors = EnumSort([Powell, Shihab, Taylor, Vaughan, Wood, Young, Zabel])\nlectures = EnumSort([1, 2, 3, 4, 5, 6, 7])\ngives = Function([professors, lectures] -> [bool])\n\n# Constraints\nForAll([p:professors], Count([l:lectures], gives(p, l)) >= 1) ::: each professor gives at least one guest lecture\nAnd(gives(Powell, 1), Given(gives(Young, 7), gives(Vaughan, 6))) ::: Powell lectures first if, but only if, Young lectures before Vaughan\nAnd(gives(Taylor, 3), Given(gives(Shihab, 4), gives(Vaughan, 5))) ::: Taylor lectures before Shihab\nGiven(gives(Wood, 5), Given(gives(Zabel, 7), gives(Vaughan, 6))) ::: Wood lectures before Zabel\n\n# Options\nQuestion ::: Which one of the following CANNOT given the second guest lecture?\nis_valid(Exists([l:lectures], gives(professors[2], l) == False)) ::: (A)\nis_valid(Exists([l:lectures], gives(professors[3], l) == False)) ::: (B)\nis_valid(Exists([l:lectures], gives(professors[5], l) == False)) ::: (C)\nis_valid(Exists([l:lectures], gives(professors[6], l) == False)) ::: (D)\nis_valid(Exists([l:lectures], gives(professors[7], l) == False)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may have different constraints and options."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_2_9",
    "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
    "question": "If Shihab lectures second and Zabel lectures fourth, then which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) Powell lectures sixth",
      "B) Taylor lectures third",
      "C) Vaughan lectures fifth",
      "D) Wood lectures fifth",
      "E) Young lectures third"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.\nQuestion:\nIf Shihab lectures second and Zabel lectures fourth, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprofessors = EnumSort([Powell, Shihab, Taylor, Vaughan, Wood, Young, Zabel])\nlectures = EnumSort([1, 2, 3, 4, 5, 6, 7])\nlecture_order = Function([professors, lectures] -> [int])\n\n# Constraints\nForAll([p:professors], Count([l:lectures], lecture_order(p, l)) >= 1) ::: each professor gives exactly one guest lecture\nAnd(lecture_order(Powell, 1), Not(lecture_order(Young, 1))) ::: Powell lectures first if, but only if, Young lectures before Vaughan\nForAll([l:lectures], Implies(lecture_order(Shihab, l), l < 3)) ::: Shihab lectures second\nForAll([l:lectures], Implies(lecture_order(Zabel, l), l == 4)) ::: Zabel lectures fourth\n\n# Options\nQuestion ::: Which one of the following could be true if Shihab lectures second and Zabel lectures fourth?\nis_valid(ForAll([l:lectures], lecture_order(Shihab, l) == 2)) ::: (A)\nis_valid(ForAll([l:lectures], lecture_order(Zabel, l) == 4)) ::: (B)\nis_valid(ForAll([l:lectures], lecture_order(Taylor, l) == 3)) ::: (C)\nis_valid(ForAll([l:lectures], lecture_order(Vaughan, l) == 6)) ::: (D)\nis_valid(ForAll([l:lectures], lecture_order(Wood, l) == 5)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_2_10",
    "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
    "question": "Which one of the following CANNOT be the guest lecture that Vaughan gives?",
    "answer": "E",
    "options": [
      "A) second",
      "B) third",
      "C) fourth",
      "D) sixth",
      "E) seventh"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.\nQuestion:\nWhich one of the following CANNOT be the guest lecture that Vaughan gives?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprofessors = EnumSort([Powell, Shihab, Taylor, Vaughan, Wood, Young, Zabel])\nlectures = EnumSort([1, 2, 3, 4, 5, 6, 7])\nlecture_order = Function([professors, lectures] -> [int])\n\n# Constraints\nForAll([p:professors], Count([l:lectures], lecture_order(p, l)) >= 1) ::: each professor gives at least one lecture\nAnd(lecture_order(Powell, 1), Not(lecture_order(Young, 7))) ::: Powell lectures first if, but only if, Young lectures before Vaughan\nForAll([l:lectures], Implies(lecture_order(Vaughan, l), Not(lecture_order(Shihab, l)))) ::: Shihab is no later than third\n\n# Options\nQuestion ::: Which one of the following CANNOT be the guest lecture that Vaughan gives?\nis_valid(Exists([l:lectures], lecture_order(Vaughan, l) == 4)) ::: (A)\nis_valid(Exists([l:lectures], lecture_order(Vaughan, l) == 6)) ::: (B)\nis_valid(Exists([l:lectures], lecture_order(Vaughan, l) == 7)) ::: (C)\nis_valid(Exists([l:lectures], lecture_order(Vaughan, l) == 3)) ::: (D)\nis_valid(Exists([l:lectures], lecture_order(Vaughan, l) == 5)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_2_11",
    "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
    "question": "If Young lectures fourth and Taylor lectures first, then which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) Powell lectures no earlier than sixth",
      "B) Shihab lectures second.",
      "C) Vaughan lectures no later than third.",
      "D) Wood lectures seventh.",
      "E) Zabel lectures no earlier than sixth."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.\nQuestion:\nIf Young lectures fourth and Taylor lectures first, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprofessors = EnumSort([Powell, Shihab, Taylor, Vaughan, Wood, Young, Zabel])\nlectures = EnumSort([1, 2, 3, 4, 5, 6, 7])\nlecture_order = Function([professors, lectures] -> [int])\n\n# Constraints\nForAll([p:professors], Count([l:lectures], lecture_order(p, l)) >= 1) ::: each professor gives exactly one guest lecture\nAnd(lecture_order(Powell, 1), Not(lecture_order(Young, 4))) ::: Powell lectures first if, but only if, Young lectures before Vaughan\nForAll([l:lectures], Implies(lecture_order(Taylor, l), Not(lecture_order(Shihab, l)))) ::: Taylor lectures before Shihab\nForAll([l:lectures], Implies(lecture_order(Vaughan, l), Not(lecture_order(Zabel, l)))) ::: Vaughan lectures before Zabel\nCount([l:lectures], lecture_order(Shihab, l)) <= 3 ::: Shihab is no later than third\nCount([l:lectures], lecture_order(Young, l)) != 7 ::: Young is not seventh\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(ForAll([l:lectures], lecture_order(Taylor, l) == 1)) ::: (A)\nis_valid(ForAll([l:lectures], lecture_order(Shihab, l) == 3)) ::: (B)\nis_valid(ForAll([l:lectures], lecture_order(Vaughan, l) == 4)) ::: (C)\nis_valid(ForAll([l:lectures], lecture_order(Young, l) == 5)) ::: (D)\nis_valid(ForAll([l:lectures], lecture_order(Zabel, l) == 7)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_2_12",
    "context": "Each of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.",
    "question": "If Zabel lectures fourth, then which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Powell lectures second.",
      "B) Powell lectures seventh.",
      "C) Wood lectures third.",
      "D) Young lectures second.",
      "E) Young lectures sixth."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of exactly seven professors—Powell, Shihab, Taylor, Vaughan, Wood, Young, and Zabel—gives exactly one guest lecture in the literary theory course. The lectures are ordered from first through seventh, and their order must conform to the following: Powell lectures before Wood. Taylor lectures before Shihab. Vaughan lectures before Zabel. Shihab is no later than third. Young is not seventh. Powell lectures first if, but only if, Young lectures before Vaughan.\nQuestion:\nIf Zabel lectures fourth, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nprofessors = EnumSort([Powell, Shihab, Taylor, Vaughan, Wood, Young, Zabel])\nlectures = EnumSort([1, 2, 3, 4, 5, 6, 7])\nlecture_order = Function([professors, lectures] -> [int])\n\n# Constraints\nForAll([p:professors], Count([l:lectures], lecture_order(p, l)) >= 1) ::: each professor gives exactly one guest lecture\nAnd(lecture_order(Powell, 1), Not(lecture_order(Young, 1))) ::: Powell lectures first if, but only if, Young lectures before Vaughan\nForAll([l:lectures], Implies(lecture_order(Zabel, l), Not(lecture_order(Vaughan, l)))) ::: Zabel lectures fourth if, but only if, Vaughan lectures before Zabel\n\n# Options\nQuestion ::: Which one of the following could be true if Zabel lectures fourth?\nis_valid(ForAll([l:lectures], lecture_order(Zabel, l) == 4)) ::: (A)\nis_valid(ForAll([l:lectures], lecture_order(Taylor, l) == 3)) ::: (B)\nis_valid(ForAll([l:lectures], lecture_order(Vaughan, l) == 5)) ::: (C)\nis_valid(ForAll([l:lectures], lecture_order(Wood, l) == 6)) ::: (D)\nis_valid(ForAll([l:lectures], lecture_order(Young, l) == 7)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may have different constraints and options."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_3_13",
    "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
    "question": "If aisle 1 contains Hobbies only, which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Fantasy is located in aisle 3.",
      "B) Music is located in aisle 2.",
      "C) Puzzles is located in aisle 2.",
      "D) Reading is located in aisle 3.",
      "E) Science is located in aisle 3."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.\nQuestion:\nIf aisle 1 contains Hobbies only, which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\naisles = EnumSort([1, 2, 3])\nsections = EnumSort([Fantasy, Hobbies, Music, Puzzles, Reading, Science])\nlocation = Function([aisle:aisles, section:sections] -> [bool])\n\n# Constraints\nForAll([a:aisles], Count([s:sections], location(a, s)) >= 1) ::: each aisle contains at least one of the following sections\nAnd(location(1, Fantasy), location(1, Music) < location(1, Puzzles)) ::: Reading must be located in the same aisle as either Fantasy or Music\nAnd(location(1, Fantasy), location(2, Music) < location(2, Puzzles)) ::: Fantasy must be located in a lower-numbered aisle than both Music and Puzzles\nAnd(location(2, Puzzles), location(3, Science) < location(3, Hobbies)) ::: Science must be located in a lower-numbered aisle than Puzzles\nAnd(location(3, Science), location(3, Hobbies) < location(2, Puzzles)) ::: Science cannot be located in a lower-numbered aisle than Hobbies\n\n# Options\nQuestion ::: Which one of the following could be true if aisle 1 contains Hobbies only?\nis_valid(ForAll([a:aisles], location(a, Hobbies) == True)) ::: (A)\nis_valid(ForAll([a:aisles], location(a, Fantasy) == True)) ::: (B)\nis_valid(ForAll([a:aisles], location(a, Music) == True)) ::: (C)\nis_valid(ForAll([a:aisles], location(a, Puzzles) == True)) ::: (D)\nis_valid(ForAll([a:aisles], location(a, Reading) == True)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_3_14",
    "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
    "question": "If aisle 3 contains Puzzles only, which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) Fantasy is located in aisle 1.",
      "B) Hobbies is located in aisle 1.",
      "C) Music is located in aisle 1.",
      "D) Reading is located in aisle 1.",
      "E) Science is located in aisle 2."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.\nQuestion:\nIf aisle 3 contains Puzzles only, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\naisles = EnumSort([1, 2, 3])\nsections = EnumSort([Fantasy, Hobbies, Music, Puzzles, Reading, Science])\nlocation = Function([aisle:aisles, section:sections] -> [int])\n\n# Constraints\nForAll([s:sections], Count([a:aisles], section in location(a, s)) >= 1) ::: each section is located in at least one aisle\nAnd(location(3, Puzzles), Count([s:sections], And(s != Puzzles, location(a, s))) == 2) ::: Reading must be located in the same aisle as either Fantasy or Music\nForAll([s:sections], Implies(location(a, s), Not(location(a, Puzzles)))) ::: Fantasy must be located in a lower-numbered aisle than both Music and Puzzles\nForAll([s:sections], Implies(location(a, s), Not(location(a, Puzzles)))) ::: Science must be located in a lower-numbered aisle than Puzzles\nForAll([s:sections], Implies(location(a, s), Not(location(a, Hobbies)))) ::: Science cannot be located in a lower-numbered aisle than Hobbies\n\n# Options\nQuestion ::: Which one of the following must be true if aisle 3 contains Puzzles only?\nis_valid(ForAll([s:sections], location(3, s) == 1)) ::: (A)\nis_valid(ForAll([s:sections], location(3, s) == 2)) ::: (B)\nis_valid(ForAll([s:sections], location(3, s) == 3)) ::: (C)\nis_valid(ForAll([s:sections], location(3, s) == 4)) ::: (D)\nis_valid(ForAll([s:sections], location(3, s) == 5)) ::: (E)\n\n------\n\nNote: The problem and question statements are given in a logical form, which is a standard way of representing problems in logic programming. The goal is to write the problem as a set of logical formulas, which can be used to reason about the problem and find a solution. The three parts of a logic program are:\n\n1. Declarations: This part of the program defines the variables and functions that are used in the problem.\n2. Constraints: This part of the program defines the constraints that must be satisfied by the solution.\n3. Options: This part of the program defines the possible solutions to the problem.\n\nIn each problem, the declarative part (declarations and constraints) is written in a logical syntax, using logical connectives such as \"and,\" \"or,\" \"not,\" and quantifiers such as \"for all\" and \"exists.\" The option part (options) is also written in a logical syntax, using logical formulas to represent the possible solutions.\n\nThe goal of logic programming is to find a solution to the problem that satisfies all the constraints and is one of the possible solutions. The problem and question statements are written in a way that makes it clear which variables are involved in the problem, which constraints must be satisfied, and which possible solutions are available."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_3_15",
    "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
    "question": "If each aisle contains exactly two of the six sections, then Science must be located in the same aisle as",
    "answer": "B",
    "options": [
      "A) Fantasy",
      "B) Hobbies",
      "C) Music",
      "D) Puzzles",
      "E) Reading"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.\nQuestion:\nIf each aisle contains exactly two of the six sections, then Science must be located in the same aisle as\nChoices:\n[[CHOICES]]\n###\n# Declarations\naisles = EnumSort([1, 2, 3])\nsections = EnumSort([Fantasy, Hobbies, Music, Puzzles, Reading, Science])\nlocation = Function([aisle:aisles, section:sections] -> [int])\n\n# Constraints\nForAll([aisle:aisles, section:sections], location(aisle, section) >= 1) ::: each section is located in at least one aisle\nAnd(location(1, Fantasy), location(1, Music) < location(1, Puzzles)) ::: Reading must be located in the same aisle as either Fantasy or Music\nAnd(location(2, Fantasy), location(2, Music) < location(2, Puzzles)) ::: Fantasy must be located in a lower-numbered aisle than both Music and Puzzles\nAnd(location(3, Puzzles), location(3, Science) < location(3, Hobbies)) ::: Science must be located in a lower-numbered aisle than Puzzles\nOr(location(1, Reading), location(2, Reading)) ::: Reading must be located in the same aisle as either Fantasy or Music\nOr(location(1, Reading), location(3, Reading)) ::: Reading must be located in the same aisle as either Puzzles or Science\n\n# Options\nQuestion ::: If each aisle contains exactly two of the six sections, then Science must be located in the same aisle as\nis_sat(ForAll([aisle:aisles, section:sections], location(aisle, section) == 2)) ::: (A)\nis_sat(ForAll([aisle:aisles, section:sections], location(aisle, section) == 3)) ::: (B)\nis_sat(ForAll([aisle:aisles, section:sections], location(aisle, section) == 1)) ::: (C)\nis_sat(ForAll([aisle:aisles, section:sections], location(aisle, section) == 2)) ::: (D)\nis_sat(ForAll([aisle:aisles, section:sections], location(aisle, section) == 3)) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, it returns `True` if the given formula is satisfiable (i.e., there exists an assignment of values to the variables that makes the formula true), and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_3_16",
    "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
    "question": "Which one of the following CANNOT be the list of the sections located in aisle 2?",
    "answer": "A",
    "options": [
      "A) Hobbies, Music",
      "B) Music, Reading",
      "C) Music, Science",
      "D) Hobbies, Music, Science",
      "E) Music, Reading, Science"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.\nQuestion:\nWhich one of the following CANNOT be the list of the sections located in aisle 2?\nChoices:\n[[CHOICES]]\n###\n# Declarations\naisles = EnumSort([1, 2, 3])\nsections = EnumSort([Fantasy, Hobbies, Music, Puzzles, Reading, Science])\nlocation = Function([aisle:aisles, section:sections] -> [bool])\n\n# Constraints\nForAll([a:aisles], Count([s:sections], location(a, s)) >= 1) ::: each section is located in at least one aisle\nAnd(location(1, Fantasy), location(1, Music) != location(1, Puzzles)) ::: Reading must be located in the same aisle as either Fantasy or Music\nAnd(location(2, Fantasy), location(2, Music) < location(2, Puzzles)) ::: Fantasy must be located in a lower-numbered aisle than both Music and Puzzles\nAnd(location(3, Puzzles), location(3, Science) < location(3, Hobbies)) ::: Science must be located in a lower-numbered aisle than Puzzles\nOr(location(2, Reading), location(2, Fantasy) != location(2, Music)) ::: Reading must be located in the same aisle as either Fantasy or Music\n\n# Options\nQuestion ::: Which one of the following CANNOT be the list of the sections located in aisle 2?\nis_valid(Exists([s:sections], location(2, s) == Reading)) ::: (A)\nis_valid(Exists([s:sections], location(2, s) == Fantasy)) ::: (B)\nis_valid(Exists([s:sections], location(2, s) == Music)) ::: (C)\nis_valid(Exists([s:sections], location(2, s) == Puzzles)) ::: (D)\nis_valid(Exists([s:sections], location(2, s) == Science)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_3_17",
    "context": "A toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.",
    "question": "If aisle 2 contains Science only, then each of the following must be true EXCEPT:",
    "answer": "E",
    "options": [
      "A) Fantasy is located in aisle 1.",
      "B) Hobbies is located in aisle 1.",
      "C) Music is located in aisle 3.",
      "D) Puzzles is located in aisle 3.",
      "E) Reading is located in aisle 1."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA toy retailer is opening a small satellite store with exactly three aisles, numbered from 1 (lowest) to 3 (highest). Six sections—Fantasy, Hobbies, Music, Puzzles, Reading, and Science—will each be confined to exactly one aisle, with each aisle containing at least one of the sections. The following conditions hold: Reading must be located in the same aisle as either Fantasy or Music. Fantasy must be located in a lower-numbered aisle than both Music and Puzzles. Science must be located in a lower-numbered aisle than Puzzles. Science cannot be located in a lower-numbered aisle than Hobbies.\nQuestion:\nIf aisle 2 contains Science only, then each of the following must be true EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\naisles = EnumSort([1, 2, 3])\nsections = EnumSort([Fantasy, Hobbies, Music, Puzzles, Reading, Science])\nlocation = Function([aisle:aisles, section:sections] -> [int])\n\n# Constraints\nForAll([s:sections], Count([a:aisles], section in location(a, s)) >= 1) ::: each section is located in at least one aisle\nAnd(location(2, Reading), location(2, Music) < location(2, Fantasy)) ::: Reading must be located in the same aisle as either Fantasy or Music\nAnd(location(2, Fantasy), location(2, Music) < location(2, Puzzles)) ::: Fantasy must be located in a lower-numbered aisle than both Music and Puzzles\nAnd(location(2, Puzzles), location(2, Science) < location(2, Hobbies)) ::: Science must be located in a lower-numbered aisle than Puzzles\nAnd(location(2, Science), location(2, Hobbies) < location(2, Reading)) ::: Science cannot be located in a lower-numbered aisle than Hobbies\n\n# Options\nQuestion ::: Which one of the following must be true if aisle 2 contains Science only?\nis_valid(ForAll([s:sections], location(2, s) == 2)) ::: (A)\nis_valid(ForAll([s:sections], location(2, s) == 3)) ::: (B)\nis_valid(ForAll([s:sections], location(2, s) == 1)) ::: (C)\nis_valid(ForAll([s:sections], location(2, s) == 4)) ::: (D)\nis_valid(ForAll([s:sections], location(2, s) == 5)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_4_18",
    "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
    "question": "Which one of the following is an allowable way of designating subzones within the three zones?",
    "answer": "E",
    "options": [
      "A) Z1: no designated subzones Z2: one housing subzone, two retail subzones Z3: one industrial subzone, one retail subzone",
      "B) Z1: one housing subzone, one industrial subzone Z2: two housing subzones, one retail subzone Z3: one industrial subzone, one retail subzone",
      "C) Z1: one housing subzone, one retail subzone Z2: two housing subzones, one retail subzone Z3: one industrial subzone, one retail subzone",
      "D) Z1: one industrial subzone Z2: three housing subzones Z3: three retail subzones",
      "E) Z1: one industrial subzone Z2: two housing subzones, one retail subzone Z3: one industrial subzone, two retail subzones"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nMillville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.\nQuestion:\nWhich one of the following is an allowable way of designating subzones within the three zones?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nzones = EnumSort([Z1, Z2, Z3])\nsubzones = EnumSort([housing, industrial, retail])\ndesignations = EnumSort([housing_designations, industrial_designations, retail_designations])\n\n# Constraints\nForAll([z:zones], Count([s:subzones], designations(s, z) == 1)) ::: each zone has exactly one designated subzone\nForAll([s:subzones], Count([z:zones], designations(s, z) == 1)) ::: each subzone is designated for exactly one zone\nForAll([z:zones], Implies(designations(housing, z), Not(designations(retail, z)))) ::: no retail subzone is designated in a zone designated for housing\nForAll([z:zones], Implies(designations(industrial, z), Not(designations(housing, z) | designations(retail, z)))) ::: no industrial subzone is designated in a zone designated for housing or retail\n\n# Options\nQuestion ::: Which one of the following is an allowable way of designating subzones within the three zones?\nis_valid(Exists([d:designations], ForAll([z:zones], d(z, z) == housing_designations))) ::: (A)\nis_valid(Exists([d:designations], ForAll([z:zones], d(z, z) == industrial_designations))) ::: (B)\nis_valid(Exists([d:designations], ForAll([z:zones], d(z, z) == retail_designations))) ::: (C)\nis_valid(Exists([d:designations], ForAll([z:zones], d(z, z) == housing_designations | d(z, z) == industrial_designations)))) ::: (D)\nis_valid(Exists([d:designations], ForAll([z:zones], d(z, z) == housing_designations | d(z, z) == retail_designations)))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_4_19",
    "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
    "question": "Which one of the following CANNOT be true within a single zone?",
    "answer": "D",
    "options": [
      "A) Two subzones are designated, one housing and one retail.",
      "B) Two subzones are designated, one industrial and one retail.",
      "C) Three subzones are designated, all of them retail.",
      "D) Four subzones are designated, none of them industrial.",
      "E) Four subzones are designated, two retail and two industrial."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nMillville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.\nQuestion:\nWhich one of the following CANNOT be true within a single zone?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nzone = EnumSort([Z1, Z2, Z3])\nsubzone = EnumSort([housing, industrial, retail])\ndesignated = Function([zone, subzone] -> [bool])\n\n# Constraints\nForAll([z:zone], Count([s:subzone], designated(z, s)) >= 1) ::: each zone has at least one subzone designated for each of the three uses\nAnd(Count([s:subzone], s == housing) <= 2, designated(Z1, s)) ::: no more than two subzones for housing are allowed in any particular zone\nAnd(Count([s:subzone], s == retail) <= 3, designated(Z1, s)) ::: no more than three retail subzones are allowed in any zone in which a subzone is designated for housing\nAnd(Count([s:subzone], s == industrial) <= 0, designated(Z1, s)) ::: no more than one industrial subzone is allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use\nOr(Count([s:subzone], s == housing) > 2, designated(Z2, s)) ::: no more than two subzones for housing are allowed in any particular zone\nOr(Count([s:subzone], s == retail) > 3, designated(Z2, s)) ::: no more than three retail subzones are allowed in any zone in which a subzone is designated for housing\nOr(Count([s:subzone], s == industrial) > 0, designated(Z2, s)) ::: no more than one industrial subzone is allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use\n\n# Options\nQuestion ::: Which one of the following CANNOT be true within a single zone?\nis_valid(Exists([z:zone], designated(z, housing) == 2)) ::: (A)\nis_valid(Exists([z:zone], designated(z, retail) == 3)) ::: (B)\nis_valid(Exists([z:zone], designated(z, industrial) == 1)) ::: (C)\nis_valid(Exists([z:zone], designated(z, housing) == 3)) ::: (D)\nis_valid(Exists([z:zone], designated(z, retail) == 2)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_4_20",
    "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
    "question": "What is the maximum number of designated subzones allowed in Z3?",
    "answer": "D",
    "options": [
      "A) 2",
      "B) 3",
      "C) 4",
      "D) 5",
      "E) 6"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nMillville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.\nQuestion:\nWhat is the maximum number of designated subzones allowed in Z3?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nzones = EnumSort([Z1, Z2, Z3])\nsubzones = EnumSort([housing, industrial, retail])\ndesignated_subzones = Function([z:zones, s:subzones] -> [bool])\n\n# Constraints\nForAll([z:zones], Count([s:subzones], designated_subzones(z, s)) >= 1) ::: each zone has at least one designated subzone\nAnd(designated_subzones(Z1, housing) == 0, designated_subzones(Z2, housing) == 2) ::: no retail subzone is allowed in Z1, exactly two subzones for housing are allowed in Z2\nAnd(designated_subzones(Z2, industrial) == 0, designated_subzones(Z3, industrial) == 1) ::: no retail subzone is allowed in Z2, exactly one retail subzone is allowed in Z3\nAnd(designated_subzones(Z3, retail) == 0, designated_subzones(Z3, housing) == 1) ::: no industrial subzone is allowed in Z3, exactly one subzone for housing is allowed in Z3\n\n# Options\nQuestion ::: What is the maximum number of designated subzones allowed in Z3?\nis_valid(Exists([s:subzones], designated_subzones(Z3, s) == 3)) ::: (A)\nis_valid(Exists([s:subzones], designated_subzones(Z3, s) == 2)) ::: (B)\nis_valid(Exists([s:subzones], designated_subzones(Z3, s) == 1)) ::: (C)\nis_valid(Exists([s:subzones], designated_subzones(Z3, s) == 0)) ::: (D)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may vary based on the specific requirements of the problem."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_4_21",
    "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
    "question": "If three subzones are designated for each use, then which one of the following is allowed?",
    "answer": "B",
    "options": [
      "A) Exactly one subzone in Z3 is designated for industrial use and exactly one subzone in Z3 is designated for retail use.",
      "B) Exactly two subzones in Z2 are designated for housing.",
      "C) Three subzones in Z1 are designated for industrial use.",
      "D) Three subzones in Z2 are designated for industrial use and exactly one subzone in Z2 is designated for retail use.",
      "E) Three subzones in Z3 are designated for retail use."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nMillville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.\nQuestion:\nIf three subzones are designated for each use, then which one of the following is allowed?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nzones = EnumSort([Z1, Z2, Z3])\nsubzones = EnumSort([housing, industrial, retail])\ndesignated = Function([z:zones, s:subzones] -> [bool])\n\n# Constraints\nForAll([z:zones], Count([s:subzones], designated(z, s)) >= 3) ::: no more than three subzones can be designated for each of the three uses\nAnd(designated(Z1, housing) == 0, designated(Z1, retail) == 0) ::: Retail subzones are not allowed in Z1\nForAll([z:zones], Count([s:subzones], And(designated(z, s), s != housing)) >= 2) ::: no more than two subzones for housing are allowed in any particular zone\nForAll([z:zones], Count([s:subzones], And(designated(z, s), s != housing, s != retail)) == 1) ::: no more than one retail subzone is allowed in any zone in which a subzone is designated for housing\nForAll([z:zones], Not(designated(z, industrial))) ::: industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use\n\n# Options\nQuestion ::: Which one of the following is allowed?\nis_valid(Exists([s:subzones], designated(Z2, s) == retail)) ::: (A)\nis_valid(Exists([s:subzones], designated(Z3, s) == housing)) ::: (B)\nis_valid(Exists([s:subzones], designated(Z1, s) == retail)) ::: (C)\nis_valid(Exists([s:subzones], designated(Z2, s) == housing)) ::: (D)\nis_valid(Exists([s:subzones], designated(Z3, s) == industrial)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_4_22",
    "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
    "question": "If one subzone in each of the zones is designated for industrial use, then which one of the following is allowed?",
    "answer": "A",
    "options": [
      "A) More subzones are designated for retail use in Z2 than in Z3.",
      "B) A subzone in one of the zones is designated for housing.",
      "C) Exactly two subzones are designated in Z1.",
      "D) Exactly three subzones each are designated in Z2 and Z3.",
      "E) Exactly four subzones are designated in Z3."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nMillville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.\nQuestion:\nIf one subzone in each of the zones is designated for industrial use, then which one of the following is allowed?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nzones = EnumSort([Z1, Z2, Z3])\nsubzones = EnumSort([housing, industrial, retail])\ndesignated = Function([z:zones, s:subzones] -> [bool])\n\n# Constraints\nForAll([z:zones], Count([s:subzones], designated(z, s)) >= 1) ::: each zone has at least one designated subzone\nAnd(Count([s:subzones], And(s != retail, designated(z, s))) == 2) ::: no more than two subzones for housing are allowed in any particular zone\nAnd(Count([s:subzones], And(s != housing, designated(z, s))) == 1) ::: no more than one retail subzone is allowed in any zone in which a subzone is designated for housing\nOr(Count([s:subzones], And(s == industrial, designated(z, s))) == 0) ::: industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use\n\n# Options\nQuestion ::: Which one of the following is allowed?\nis_valid(Exists([z:zones], designated(z, industrial))) ::: (A)\nis_valid(Exists([z:zones], designated(z, housing))) ::: (B)\nis_valid(Exists([z:zones], designated(z, retail))) ::: (C)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may vary based on the specific requirements of the problem."
    ]
  },
  {
    "id": "ar_lsat_201210_3-G_4_23",
    "context": "Millville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.",
    "question": "If three subzones in all are designated for retail use and a subzone in Z2 is designated for housing, then which one of the following is allowed?",
    "answer": "A",
    "options": [
      "A) Two subzones in Z1 are designated for housing.",
      "B) More subzones are designated for industrial use in Z2 than in Z3.",
      "C) More subzones are designated for retail use in Z2 than in Z3.",
      "D) The same number of subzones are designated for retail use in Z2 and Z3.",
      "E) A subzone in Z3 is designated for housing."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nMillville has created three new development zones: Z1, Z2, and Z3. Within these zones, subzones can be designated for housing, industrial, or retail use, with no subzone designated for more than one use. By city regulation, a total of no more than three subzones can be designated for each of the three uses. The following restrictions are in place: Retail subzones are not allowed in Z1. No more than two subzones for housing are allowed in any particular zone. No more than one retail subzone is allowed in any zone in which a subzone is designated for housing. Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use.\nQuestion:\nIf three subzones in all are designated for retail use and a subzone in Z2 is designated for housing, then which one of the following is allowed?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nzones = EnumSort([Z1, Z2, Z3])\nsubzones = EnumSort([housing, industrial, retail])\ndesignated = Function([z:zones, s:subzones] -> [bool])\n\n# Constraints\nForAll([z:zones], Count([s:subzones], designated(z, s)) >= 1) ::: each zone has at least one designated subzone\nAnd(designated(Z1, retail), Count([s:subzones], And(s != retail, designated(Z1, s))) == 0) ::: Retail subzones are not allowed in Z1\nForAll([s:subzones], Implies(designated(Z2, s), Not(designated(Z2, housing)))) ::: No more than two subzones for housing are allowed in any particular zone\nForAll([z:zones], Implies(designated(z, retail), Not(designated(z, industrial)))) ::: No more than one retail subzone is allowed in any zone in which a subzone is designated for housing\nForAll([z:zones], Implies(designated(z, industrial), Not(designated(z, retail)))) ::: Industrial subzones are not allowed in any zone in which a subzone is designated for housing or three subzones are designated for retail use\n\n# Options\nQuestion ::: Which one of the following is allowed?\nis_valid(Exists([s:subzones], designated(Z2, s) == retail)) ::: (A)\nis_valid(Exists([s:subzones], designated(Z2, s) == housing)) ::: (B)\nis_valid(Exists([s:subzones], designated(Z2, s) == industrial)) ::: (C)\nis_valid(Exists([s:subzones], designated(Z2, s) == retail, designated(Z2, housing))) ::: (D)\nis_valid(Exists([s:subzones], designated(Z2, s) == retail, designated(Z2, industrial))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_1_1",
    "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
    "question": "Which one of the following could be the order in which the manuscripts were written, from first to last?",
    "answer": "E",
    "options": [
      "A) F, M, G, H, P, L, S",
      "B) G, P, M, F, H, S, L",
      "C) H, F, M, G, P, L, S",
      "D) L, F, M, G, P, H, S",
      "E) M, F, H, S, L, G, P"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.\nQuestion:\nWhich one of the following could be the order in which the manuscripts were written, from first to last?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nmanuscripts = EnumSort([F, G, H, L, M, P, S])\norder = EnumSort([])\n\n# Constraints\nForAll([m:manuscripts], Not(order(m))) ::: no order has been determined for any manuscript yet\nForAll([m:manuscripts], Implies(order(m), Not(order(m + 1))))) ::: no two manuscripts have the same order\nForAll([m:manuscripts], Implies(order(m), And(m != H, order(m + 1) == H))) ::: H was written earlier than S but later than F\nForAll([m:manuscripts], Implies(order(m), And(m == P, order(m + 1) == L))) ::: P was the next manuscript written after G\nForAll([m:manuscripts], Implies(order(m), And(m != L, order(m + 1) == M))) ::: at least four of the manuscripts were written earlier than L\nForAll([m:manuscripts], Implies(order(m), And(m != M, order(m + 1) == H))) ::: at least four of the manuscripts were written later than M\nForAll([m:manuscripts], Implies(order(m), Not(order(m + 5))))) ::: H was not written fifth\n\n# Options\nQuestion ::: Which one of the following could be the order in which the manuscripts were written, from first to last?\nis_valid(Exists([m:manuscripts], order(m) == [F, G, H, P, S])) ::: (A)\nis_valid(Exists([m:manuscripts], order(m) == [G, H, P, S, F])) ::: (B)\nis_valid(Exists([m:manuscripts], order(m) == [H, G, P, S, F])) ::: (C)\nis_valid(Exists([m:manuscripts], order(m) == [P, G, H, S, F])) ::: (D)\nis_valid(Exists([m:manuscripts], order(m) == [S, G, H, P, F])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_1_2",
    "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
    "question": "Which one of the following manuscripts CANNOT have been written third?",
    "answer": "A",
    "options": [
      "A) S",
      "B) P",
      "C) M",
      "D) H",
      "E) G"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.\nQuestion:\nWhich one of the following manuscripts CANNOT have been written third?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nmanuscripts = EnumSort([F, G, H, L, M, P, S])\n\n# Constraints\nForAll([m:manuscripts], Count([n:manuscripts], m == n) >= 1) ::: each manuscript has at least one predecessor\nAnd(H < S, Count([m:manuscripts], m == H) >= 1) ::: H was written earlier than S\nAnd(P < G, Count([m:manuscripts], m == P) >= 1) ::: P was the next manuscript written after G\nForAll([m:manuscripts], Implies(m == L, Count([n:manuscripts], n == L) >= 4)) ::: at least four of the manuscripts were written earlier than L\nForAll([m:manuscripts], Implies(m == M, Count([n:manuscripts], n == M) >= 4)) ::: at least four of the manuscripts were written later than M\nForAll([m:manuscripts], Implies(m == H, Not(m == fifth))) ::: H was not written fifth\n\n# Options\nQuestion ::: Which one of the following manuscripts CANNOT have been written third?\nis_valid(Exists([m:manuscripts], m == third)) ::: (A)\nis_valid(Exists([m:manuscripts], m == second)) ::: (B)\nis_valid(Exists([m:manuscripts], m == fourth)) ::: (C)\nis_valid(Exists([m:manuscripts], m == fifth)) ::: (D)\nis_valid(Exists([m:manuscripts], m == sixth)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_1_3",
    "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
    "question": "If H was the next manuscript written after M, which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) F was written second.",
      "B) G was written third.",
      "C) H was written fourth.",
      "D) P was written third.",
      "E) S was written fourth."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.\nQuestion:\nIf H was the next manuscript written after M, which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nmanuscripts = EnumSort([F, G, H, L, M, P, S])\norder = EnumSort([earlier, later])\n\n# Constraints\nForAll([m:manuscripts], Count([n:manuscripts], And(m != n, order(m, n))) >= 4) ::: no two manuscripts were written at the same time\nAnd(order(H, S), Count([m:manuscripts], And(m == H, order(m, S))) == 1) ::: H was written earlier than S but later than F\nAnd(order(P, L), Count([m:manuscripts], And(m == P, order(m, L))) == 1) ::: P was the next manuscript written after G\nForAll([m:manuscripts], Implies(order(m, L), Not(order(m, M)))) ::: at least four of the manuscripts were written later than M\nForAll([m:manuscripts], Implies(order(H, M), Not(order(H, L)))) ::: H was not written fifth\n\n# Options\nQuestion ::: Which one of the following could be true if H was the next manuscript written after M?\nis_valid(Exists([m:manuscripts], And(order(m, M), order(m, H)))) ::: (A)\nis_valid(Exists([m:manuscripts], And(order(m, M), order(m, P)))) ::: (B)\nis_valid(Exists([m:manuscripts], And(order(m, M), order(m, L)))) ::: (C)\nis_valid(Exists([m:manuscripts], And(order(m, M), order(m, S)))) ::: (D)\nis_valid(Exists([m:manuscripts], And(order(m, M), order(m, H) == order(m, P)))) ::: (E)\n\n------\n\nNote: The `is_valid` function is used to check the validity of a given option, which means that it returns `True` if the option is valid, and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_1_4",
    "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
    "question": "Which one of the following manuscripts CANNOT have been written fourth?",
    "answer": "D",
    "options": [
      "A) F",
      "B) G",
      "C) H",
      "D) P",
      "E) S"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.\nQuestion:\nWhich one of the following manuscripts CANNOT have been written fourth?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nmanuscripts = EnumSort([F, G, H, L, M, P, S])\norder = EnumSort([earlier, same_time, later])\n\n# Constraints\nForAll([m:manuscripts], Count([n:manuscripts], And(m != n, order(m, n))) >= 1) ::: no two manuscripts were written at the same time\nAnd(order(H, S), Count([m:manuscripts], And(m == H, order(m, S))) == 1) ::: H was written earlier than S but later than F\nAnd(order(P, L), Count([m:manuscripts], And(m == P, order(m, L))) == 1) ::: P was the next manuscript written after G\nForAll([m:manuscripts], Implies(order(m, L), Not(order(m, M)))) ::: at least four of the manuscripts were written later than M\nForAll([m:manuscripts], Implies(order(H, m), Not(order(m, S)))) ::: H was not written fifth\n\n# Options\nQuestion ::: Which one of the following manuscripts CANNOT have been written fourth?\nis_valid(Exists([m:manuscripts], order(m, L) == order(m, M))) ::: (A)\nis_valid(Exists([m:manuscripts], order(m, P) == order(m, S))) ::: (B)\nis_valid(Exists([m:manuscripts], order(m, H) == order(m, M))) ::: (C)\nis_valid(Exists([m:manuscripts], order(m, L) == order(m, M))) ::: (D)\nis_valid(Exists([m:manuscripts], order(m, H) == order(m, P))) ::: (E)\n\n------\n\nNote: The `is_valid` function is used to check the validity of a given option, which means that it returns `True` if the option is valid, and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_1_5",
    "context": "A researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.",
    "question": "If P was written earlier than H, then any of the following could be true EXCEPT:",
    "answer": "D",
    "options": [
      "A) F was written first.",
      "B) G was written third.",
      "C) H was written sixth.",
      "D) L was written seventh.",
      "E) M was written second."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA researcher is studying seven manuscripts—F, G, H, L, M, P, and S—to determine their relative ages. It is known that no two manuscripts were written at the same time. The researcher has also determined the following: H was written earlier than S but later than F. P was the next manuscript written after G. At least four of the manuscripts were written earlier than L. At least four of the manuscripts were written later than M. H was not written fifth.\nQuestion:\nIf P was written earlier than H, then any of the following could be true EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\nmanuscripts = EnumSort([F, G, H, L, M, P, S])\nages = EnumSort([integer])\n\n# Constraints\nForAll([m:manuscripts], Count([a:ages], m == a) >= 1) ::: each manuscript has at least one age\nAnd(Age(H) < Age(S), Count([m:manuscripts], And(m == H, m > F)) == 1) ::: H was written earlier than S but later than F\nAnd(Age(P) > Age(G), Count([m:manuscripts], And(m == P, m < G)) == 1) ::: P was written next after G\nForAll([m:manuscripts], Implies(And(m == L, m > M), Count([n:manuscripts], And(n == L, n < M)) >= 4)) ::: at least four of the manuscripts were written earlier than L\nForAll([m:manuscripts], Implies(And(m == M, m < P), Count([n:manuscripts], And(n == M, n > P)) >= 4)) ::: at least four of the manuscripts were written later than M\nForAll([m:manuscripts], Implies(And(m == H, m < P), Not(And(m == H, m > F))), m != H) ::: H was not written fifth\n\n# Options\nQuestion ::: If P was written earlier than H, then any of the following could be true EXCEPT:\nis_valid(ForAll([m:manuscripts], And(m == P, m < H))) ::: (A)\nis_valid(ForAll([m:manuscripts], And(m == H, m > F))) ::: (B)\nis_valid(ForAll([m:manuscripts], And(m == H, m < G))) ::: (C)\nis_valid(ForAll([m:manuscripts], And(m == H, m > M))) ::: (D)\nis_valid(ForAll([m:manuscripts], And(m == H, m < L))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_2_6",
    "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
    "question": "Which one of the following is an acceptable placement of dishes on the bottom, middle, and top shelves?",
    "answer": "B",
    "options": [
      "A) bottom: dish 1 middle: dish 6 top: dishes 2, 3, 4, 5",
      "B) bottom: dishes 1, 3 middle: dish 6 top: dishes 2, 4, 5",
      "C) bottom: dish 2 middle: dishes 4, 6 top: dishes 1, 3, 5",
      "D) bottom: dishes 3, 5 middle: dish 6 top: dishes 1, 2, 4",
      "E) bottom: dishes 4, 6 middle: dishes 1, 3 top: dishes 2, 5"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.\nQuestion:\nWhich one of the following is an acceptable placement of dishes on the bottom, middle, and top shelves?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ndishes = EnumSort([dish1, dish2, dish3, dish4, dish5, dish6])\nshelves = EnumSort([bottom, middle, top])\nstorage = Function([dishes, shelves] -> [bool])\n\n# Constraints\nForAll([d:dishes], Count([s:shelves], storage(d, s)) >= 1) ::: each dish is stored on at least one shelf\nAnd(storage(dish2, bottom), storage(dish6, top)) ::: dish 2 is stored at least one shelf above dish 6\nAnd(storage(dish5, middle), storage(dish6, top)) ::: dish 5 is stored either one shelf above or one shelf below dish 6\nForAll([d:dishes], Implies(storage(d, bottom), Not(storage(d, middle)) or storage(d, top))) ::: dish 1 is not stored on the same shelf as dish 4\n\n# Options\nQuestion ::: Which one of the following is an acceptable placement of dishes on the bottom, middle, and top shelves?\nis_sat(ForAll([d:dishes], storage(d, bottom) == storage(d, middle))) ::: (A)\nis_sat(ForAll([d:dishes], storage(d, bottom) == storage(d, top))) ::: (B)\nis_sat(ForAll([d:dishes], storage(d, middle) == storage(d, top))) ::: (C)\nis_sat(ForAll([d:dishes], storage(d, bottom) == storage(d, top))) ::: (D)\nis_sat(ForAll([d:dishes], storage(d, bottom) == storage(d, middle))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_2_7",
    "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
    "question": "If dish 6 is the only dish stored on the bottom shelf, which one of the following could be the list of dishes that are stored together on the middle shelf?",
    "answer": "E",
    "options": [
      "A) dish 1, dish 3",
      "B) dish 2, dish 4",
      "C) dish 2, dish 3",
      "D) dish 3, dish 5",
      "E) dish 4, dish 5"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.\nQuestion:\nIf dish 6 is the only dish stored on the bottom shelf, which one of the following could be the list of dishes that are stored together on the middle shelf?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ndishes = EnumSort([dish1, dish2, dish3, dish4, dish5, dish6])\nshelves = EnumSort([bottom, middle, top])\nstorage = Function([dishes, shelves] -> [bool])\n\n# Constraints\nForAll([s:shelves], Count([d:dishes], storage(d, s)) >= 1) ::: each dish is stored on at least one shelf\nAnd(storage(dish2, bottom), Count([d:dishes], And(d != dish2, storage(d, bottom))) == 2) ::: Dish 2 is stored at least one shelf above dish 6\nAnd(storage(dish6, bottom), Count([d:dishes], And(d != dish6, storage(d, bottom))) == 1) ::: Dish 6 is stored either one shelf above or one shelf below dish 5\nAnd(storage(dish1, middle), Count([d:dishes], And(d != dish1, storage(d, middle))) == 0) ::: Dish 1 is not stored on the same shelf as dish 4\n\n# Options\nQuestion ::: Which one of the following could be the list of dishes that are stored together on the middle shelf if dish 6 is the only dish stored on the bottom shelf?\nis_sat(ForAll([d:dishes], storage(d, middle) == [dish2, dish5, dish6])) ::: (A)\nis_sat(ForAll([d:dishes], storage(d, middle) == [dish2, dish4, dish6])) ::: (B)\nis_sat(ForAll([d:dishes], storage(d, middle) == [dish3, dish5, dish6])) ::: (C)\nis_sat(ForAll([d:dishes], storage(d, middle) == [dish4, dish5, dish6])) ::: (D)\nis_sat(ForAll([d:dishes], storage(d, middle) == [dish5, dish6, dish1])) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, it returns `True` if the given formula is satisfiable (i.e., there exists an assignment of values to the variables that makes the formula true), and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_2_8",
    "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
    "question": "If dish 1, dish 2, and dish 3 are stored on the same shelf as each other, which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) Exactly one of the dishes is stored on the top shelf.",
      "B) Exactly two of the dishes are stored on the top shelf.",
      "C) Exactly two of the dishes are stored on the middle shelf.",
      "D) Exactly three of the dishes are stored on the middle shelf.",
      "E) Exactly three of the dishes are stored on the bottom shelf."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.\nQuestion:\nIf dish 1, dish 2, and dish 3 are stored on the same shelf as each other, which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ndishes = EnumSort([dish 1, dish 2, dish 3, dish 4, dish 5, dish 6])\nshelves = EnumSort([bottom, middle, top])\nstorage = Function([dishes, shelves] -> [bool])\n\n# Constraints\nForAll([s:shelves], Count([d:dishes], storage(d, s)) <= 3) ::: No more than three dishes are stored on any shelf\nImplies(storage(dish 2, bottom), storage(dish 6, bottom)) ::: Dish 2 is stored at least one shelf above dish 6\nImplies(storage(dish 6, middle), storage(dish 5, middle)) ::: Dish 6 is stored either one shelf above or one shelf below dish 5\nImplies(storage(dish 1, bottom), Not(storage(dish 4, bottom))) ::: Dish 1 is not stored on the same shelf as dish 4\n\n# Options\nQuestion ::: If dish 1, dish 2, and dish 3 are stored on the same shelf as each other, which one of the following could be true?\nis_valid(ForAll([s:shelves], storage(dish 1, s) == storage(dish 2, s))) ::: (A)\nis_valid(ForAll([s:shelves], storage(dish 2, s) == storage(dish 3, s))) ::: (B)\nis_valid(ForAll([s:shelves], storage(dish 3, s) == storage(dish 1, s))) ::: (C)\nis_valid(ForAll([s:shelves], storage(dish 1, s) == storage(dish 5, s))) ::: (D)\nis_valid(ForAll([s:shelves], storage(dish 2, s) == storage(dish 6, s))) ::: (E)\n\n------\n\nNote: The problem and question are given in a logical form, which means that the variables and constraints are written in a logical syntax, and the options are written in a logical form as well. The task is to convert the problem and question into a logic program, which can be used to solve the problem and answer the question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_2_9",
    "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
    "question": "If exactly one of the shelves has no dish stored on it, which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) Exactly three of the dishes are stored on the bottom shelf.",
      "B) Exactly three of the dishes are stored on the middle shelf.",
      "C) Dish 1 is stored on the same shelf as dish 5.",
      "D) Dish 2 is stored on the same shelf as dish 3.",
      "E) Dish 4 is stored on the same shelf as dish 5."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.\nQuestion:\nIf exactly one of the shelves has no dish stored on it, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ndishes = EnumSort([dish1, dish2, dish3, dish4, dish5, dish6])\nshelves = EnumSort([bottom, middle, top])\nstorage = Function([shelves] -> [dishes])\n\n# Constraints\nForAll([s:shelves], Count([d:dishes], storage(s) >= 3) ::: No more than three dishes are stored on any shelf)\nImplies(storage(bottom), Count([d:dishes], And(d == dish2, s == bottom)) >= 1) ::: Dish 2 is stored at least one shelf above dish 6\nImplies(storage(middle), Count([d:dishes], And(d == dish6, s == middle)) >= 1) ::: Dish 6 is stored either one shelf above or one shelf below dish 5\nImplies(storage(top), Count([d:dishes], And(d == dish1, s == top)) >= 1) ::: Dish 1 is not stored on the same shelf as dish 4\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(Exists([s:shelves], storage(s) == [dish1, dish2, dish3])) ::: (A)\nis_valid(Exists([s:shelves], storage(s) == [dish2, dish3, dish4])) ::: (B)\nis_valid(Exists([s:shelves], storage(s) == [dish3, dish4, dish5])) ::: (C)\nis_valid(Exists([s:shelves], storage(s) == [dish4, dish5, dish6])) ::: (D)\nis_valid(Exists([s:shelves], storage(s) == [dish5, dish6, dish1])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_2_10",
    "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
    "question": "If dish 5 is the only dish stored on the bottom shelf and if exactly two of the dishes are stored on the middle shelf, then which one of the following is a pair of dishes that must be among the dishes stored on the top shelf?",
    "answer": "C",
    "options": [
      "A) dish 1 and dish 2",
      "B) dish 1 and dish 6",
      "C) dish 2 and dish 3",
      "D) dish 2 and dish 4",
      "E) dish 3 and dish 4"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.\nQuestion:\nIf dish 5 is the only dish stored on the bottom shelf and if exactly two of the dishes are stored on the middle shelf, then which one of the following is a pair of dishes that must be among the dishes stored on the top shelf?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ndishes = EnumSort([dish1, dish2, dish3, dish4, dish5, dish6])\nshelves = EnumSort([bottom, middle, top])\nstorage = Function([dishes, shelves] -> [bool])\n\n# Constraints\nForAll([s:shelves], Count([d:dishes], storage(d, s)) >= 1) ::: each dish is stored on at least one shelf\nAnd(storage(dish5, bottom), Count([d:dishes], And(d != dish5, storage(d, bottom))) == 3) ::: No more than three dishes are stored on the bottom shelf\nAnd(storage(dish6, middle), Count([d:dishes], And(d != dish6, storage(d, middle))) == 2) ::: Exactly two dishes are stored on the middle shelf\nAnd(storage(dish1, top), Implies(storage(dish5, top), Not(storage(dish1, top)))) ::: Dish 1 is not stored on the same shelf as dish 5\n\n# Options\nQuestion ::: Which one of the following pairs of dishes must be among the dishes stored on the top shelf?\nis_valid(Exists([s:shelves], storage(dish2, s) == storage(dish4, s))) ::: (A)\nis_valid(Exists([s:shelves], storage(dish3, s) == storage(dish5, s))) ::: (B)\nis_valid(Exists([s:shelves], storage(dish5, s) == storage(dish6, s))) ::: (C)\nis_valid(Exists([s:shelves], storage(dish6, s) == storage(dish1, s))) ::: (D)\nis_valid(Exists([s:shelves], storage(dish2, s) == storage(dish4, s))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_2_11",
    "context": "Exactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.",
    "question": "If exactly one of the dishes is stored on the middle shelf, which one of the following could be the list of dishes stored on the top shelf?",
    "answer": "A",
    "options": [
      "A) dish 1, dish 2",
      "B) dish 1, dish 5",
      "C) dish 2, dish 3",
      "D) dish 3, dish 4",
      "E) dish 3, dish 5"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six petri dishes—labeled dish 1 through dish 6—are to be stored in an otherwise empty refrigerator. There are three available shelves—the bottom shelf, the middle shelf, and the top shelf. The placement of the dishes must be consistent with the following conditions: No more than three dishes are stored on any shelf. Dish 2 is stored at least one shelf above dish 6. Dish 6 is stored either one shelf above or one shelf below dish 5. Dish 1 is not stored on the same shelf as dish 4.\nQuestion:\nIf exactly one of the dishes is stored on the middle shelf, which one of the following could be the list of dishes stored on the top shelf?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ndishes = EnumSort([dish1, dish2, dish3, dish4, dish5, dish6])\nshelves = EnumSort([bottom, middle, top])\nstorage = Function([shelves] -> [dishes])\n\n# Constraints\nForAll([s:shelves], Count([d:dishes], storage(s) == [d]) >= 1) ::: each dish is stored on at least one shelf\nAnd(storage(middle), Count([d:dishes], And(d != dish2, storage(middle) == [d])) == 2) ::: No more than two dishes are stored on the middle shelf\nAnd(storage(top), Count([d:dishes], And(d != dish1, storage(top) == [d])) == 1) ::: exactly one dish is stored on the top shelf\nAnd(storage(bottom), Count([d:dishes], And(d != dish5, storage(bottom) == [d])) == 1) ::: exactly one dish is stored on the bottom shelf\nForAll([d:dishes], Implies(storage(top), Not(storage(bottom))(d))) ::: dish 1 is not stored on the same shelf as dish 4\n\n# Options\nQuestion ::: Which one of the following could be the list of dishes stored on the top shelf if exactly one of the dishes is stored on the middle shelf?\nis_sat(ForAll([d:dishes], storage(middle) == [d, dish4])) ::: (A)\nis_sat(ForAll([d:dishes], storage(middle) == [d, dish5])) ::: (B)\nis_sat(ForAll([d:dishes], storage(middle) == [d, dish6])) ::: (C)\nis_sat(ForAll([d:dishes], storage(middle) == [dish1, dish4])) ::: (D)\nis_sat(ForAll([d:dishes], storage(middle) == [dish1, dish5])) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, it returns `True` if the given formula is satisfiable (i.e., there exists an assignment of values to the variables that makes the formula true), and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_3_12",
    "context": "A company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.",
    "question": "Which one of the following could be the schedule of deliveries to the schools, from the first to the fourth?",
    "answer": "A",
    "options": [
      "A) Juices: Hafford, Ferndale, Gladstone, Isley Snacks: Ferndale, Isley, Gladstone, Hafford",
      "B) Juices: Hafford, Isley, Ferndale, Gladstone Snacks: Isley, Ferndale, Gladstone, Hafford",
      "C) Juices: Isley, Ferndale, Gladstone, Hafford Snacks: Hafford, Ferndale, Gladstone, Isley",
      "D) Juices: Isley, Gladstone, Ferndale, Hafford Snacks: Ferndale, Gladstone, Hafford, Isley",
      "E) Juices: Isley, Hafford, Gladstone, Ferndale Snacks: Ferndale, Isley, Gladstone, Hafford"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.\nQuestion:\nWhich one of the following could be the schedule of deliveries to the schools, from the first to the fourth?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nschools = EnumSort([Ferndale, Gladstone, Hafford, Isley])\ntrucks = EnumSort([juice, snack])\ndeliveries = EnumSort([juice, snack])\ndeliver_time = Function([schools, trucks] -> [bool])\n\n# Constraints\nForAll([t:trucks], Count([s:schools], deliver_time(t, s)) >= 1) ::: each truck makes at least one delivery\nAnd(deliver_time(juice, Ferndale), Not(deliver_time(juice, Gladstone))) ::: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford\nAnd(deliver_time(snack, Gladstone), Not(deliver_time(snack, Ferndale))) ::: Gladstone cannot be the fourth school to which juices are delivered\nAnd(deliver_time(juice, Hafford), Not(deliver_time(snack, Hafford))) ::: Gladstone must be the third school to which snacks are delivered\nAnd(deliver_time(snack, Isley), Not(deliver_time(juice, Isley))) ::: The first school to which juices are delivered must be the fourth one to which snacks are delivered\n\n# Options\nQuestion ::: Which one of the following could be the schedule of deliveries to the schools, from the first to the fourth?\nis_valid(Exists([t:trucks], deliver_time(t, Ferndale) == 1)) ::: (A)\nis_valid(Exists([t:trucks], deliver_time(t, Gladstone) == 2)) ::: (B)\nis_valid(Exists([t:trucks], deliver_time(t, Hafford) == 3)) ::: (C)\nis_valid(Exists([t:trucks], deliver_time(t, Isley) == 4)) ::: (D)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_3_13",
    "context": "A company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.",
    "question": "If Hafford is the fourth school to which juices are delivered, which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Ferndale is the second school to which juices are delivered.",
      "B) Gladstone is the third school to which juices are delivered.",
      "C) Ferndale is the second school to which snacks are delivered.",
      "D) Hafford is the second school to which snacks are delivered.",
      "E) Isley is the first school to which snacks are delivered."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.\nQuestion:\nIf Hafford is the fourth school to which juices are delivered, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nschools = EnumSort([Ferndale, Gladstone, Hafford, Isley])\ntrucks = EnumSort([juice, snack])\ndeliveries = EnumSort([juice, snack])\ndeliver_juice = Function([schools, trucks] -> [bool])\ndeliver_snack = Function([schools, trucks] -> [bool])\n\n# Constraints\nForAll([s:schools], ForAll([t:trucks], Implies(deliver_juice(s, t), Not(deliver_snack(s, t))))) ::: juices and snacks are delivered in separate trucks\nAnd(deliver_juice(Ferndale, juice), ForAll([s:schools], Implies(deliver_snack(s, snack), Not(deliver_juice(s, juice))))) ::: juices must be delivered to Ferndale before snacks\nAnd(deliver_snack(Gladstone, snack), ForAll([s:schools], Implies(deliver_juice(s, juice), Not(deliver_snack(s, snack))))) ::: snacks must be delivered to Gladstone before juices\nForAll([s:schools], Implies(deliver_juice(s, juice), deliver_snack(s, snack))) ::: the first school to which juices are delivered must be the fourth one to which snacks are delivered\n\n# Options\nQuestion ::: Which one of the following must be true if Hafford is the fourth school to which juices are delivered?\nis_valid(ForAll([s:schools], deliver_snack(s, snack) == Hafford)) ::: (A)\nis_valid(ForAll([s:schools], deliver_juice(s, juice) == Hafford)) ::: (B)\nis_valid(ForAll([s:schools], deliver_snack(s, snack) == Isley)) ::: (C)\nis_valid(ForAll([s:schools], deliver_juice(s, juice) == Isley)) ::: (D)\nis_valid(ForAll([s:schools], deliver_snack(s, snack) == Ferndale)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_3_14",
    "context": "A company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.",
    "question": "If Isley is the third school to which juices are delivered, which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) Juices are delivered to Gladstone at some time before they are delivered to Hafford.",
      "B) Juices are delivered to Isley at some time before they are delivered to Hafford.",
      "C) Snacks are delivered to Ferndale at some time before they are delivered to Isley.",
      "D) Snacks are delivered to Gladstone at some time before they are delivered to Isley.",
      "E) Snacks are delivered to Hafford at some time before they are delivered to Gladstone."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.\nQuestion:\nIf Isley is the third school to which juices are delivered, which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nschools = EnumSort([Ferndale, Gladstone, Hafford, Isley])\ntrucks = EnumSort([juice, snack])\ndeliveries = EnumSort([juice, snack])\ndeliver_juice = Function([schools, trucks] -> [bool])\ndeliver_snack = Function([schools, trucks] -> [bool])\n\n# Constraints\nForAll([s:schools], ForAll([t:trucks], Implies(deliver_juice(s, t), Not(deliver_snack(s, t)))) ::: Juices must be delivered in the juice truck, and snacks in the other truck)\nForAll([s:schools], Implies(deliver_snack(s, juice), Not(deliver_snack(s, snack)))) ::: Snacks must be delivered in the snack truck\nForAll([s:schools], Count([t:trucks], deliver_juice(s, t)) <= 1) ::: Exactly one delivery of juices is made to each school\nForAll([s:schools], Count([t:trucks], deliver_snack(s, t)) <= 1) ::: Exactly one delivery of snacks is made to each school\nForAll([s:schools], Implies(deliver_juice(s, snack), Not(deliver_juice(s, juice)))) ::: If snacks are delivered to a school, then juices are not delivered to that school\nForAll([s:schools], Implies(deliver_snack(s, juice), Not(deliver_snack(s, snack)))) ::: If snacks are delivered to a school, then juices are not delivered to that school\n\n# Options\nQuestion ::: Which one of the following could be true if Isley is the third school to which juices are delivered?\nis_sat(ForAll([s:schools], deliver_juice(Isley, juice) == deliver_snack(Isley, snack))) ::: (A)\nis_sat(ForAll([s:schools], deliver_snack(Isley, snack) == deliver_juice(Isley, juice))) ::: (B)\nis_sat(ForAll([s:schools], deliver_snack(Isley, snack) == deliver_snack(Isley, juice))) ::: (C)\nis_sat(ForAll([s:schools], deliver_juice(Isley, juice) == deliver_snack(Isley, snack))) ::: (D)\nis_sat(ForAll([s:schools], deliver_juice(Isley, juice) == deliver_juice(Isley, snack))) ::: (E)\n\n------\n\nNote: The above code is just an example, and you may need to adjust it to fit your specific problem. Additionally, the `is_sat` function is not a built-in function in Prolog, you may need to define it yourself."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_3_15",
    "context": "A company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.",
    "question": "If Isley is the first school to which snacks are delivered, which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) Ferndale is the second school to which juices are delivered.",
      "B) Hafford is the second school to which juices are delivered.",
      "C) Hafford is the third school to which juices are delivered.",
      "D) Isley is the first school to which juices are delivered.",
      "E) Hafford is the second school to which snacks are delivered."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.\nQuestion:\nIf Isley is the first school to which snacks are delivered, which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nschools = EnumSort([Ferndale, Gladstone, Hafford, Isley])\ntrucks = EnumSort([juice, snack])\ndeliveries = EnumSort([juice, snack])\ndeliver_juice = Function([trucks, schools] -> [bool])\ndeliver_snack = Function([trucks, schools] -> [bool])\n\n# Constraints\nForAll([t:trucks], ForAll([s:schools], deliver_juice(t, s) == deliver_snack(t, s))) ::: juices and snacks are delivered in the same trucks\nAnd(deliver_juice(juice, Ferndale), deliver_snack(snack, Ferndale)) ::: snacks are delivered to Ferndale at some time before they are delivered to Hafford\nAnd(deliver_snack(snack, Gladstone), deliver_juice(juice, Gladstone)) ::: Gladstone cannot be the fourth school to which juices are delivered\nAnd(deliver_snack(snack, Hafford), deliver_juice(juice, Hafford)) ::: Gladstone must be the third school to which snacks are delivered\nAnd(deliver_snack(snack, Isley), deliver_juice(juice, Isley)) ::: Isley is the first school to which snacks are delivered\n\n# Options\nQuestion ::: Which one of the following could be true if Isley is the first school to which snacks are delivered?\nis_valid(ForAll([s:schools], deliver_snack(snack, s) == deliver_juice(juice, s))) ::: (A)\nis_valid(ForAll([s:schools], deliver_snack(snack, s) == deliver_juice(juice, s))) ::: (B)\nis_valid(ForAll([s:schools], deliver_snack(snack, s) == deliver_juice(juice, s))) ::: (C)\nis_valid(ForAll([s:schools], deliver_snack(snack, s) == deliver_juice(juice, s))) ::: (D)\nis_valid(ForAll([s:schools], deliver_snack(snack, s) == deliver_juice(juice, s))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_3_16",
    "context": "A company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.",
    "question": "Which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Both juices and snacks are delivered to Gladstone at some time before they are delivered to Ferndale.",
      "B) Both juices and snacks are delivered to Gladstone at some time before they are delivered to Isley.",
      "C) Both juices and snacks are delivered to Hafford at some time before they are delivered to Isley.",
      "D) Both juices and snacks are delivered to Isley at some time before they are delivered to Ferndale.",
      "E) Both juices and snacks are delivered to Isley at some time before they are delivered to Hafford."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.\nQuestion:\nWhich one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nschools = EnumSort([Ferndale, Gladstone, Hafford, Isley])\ntrucks = EnumSort([juice, snack])\ndeliveries = EnumSort([juice, snack])\ndeliver_juice = Function([trucks, schools] -> [bool])\ndeliver_snack = Function([trucks, schools] -> [bool])\n\n# Constraints\nForAll([t:trucks], ForAll([s:schools], Implies(deliver_juice(t, s), Not(deliver_snack(t, s))))) ::: juices and snacks are delivered in separate trucks\nAnd(deliver_juice(juice, Ferndale), ForAll([s:schools], Implies(deliver_snack(snack, s), Not(deliver_juice(juice, s))))) ::: snacks are delivered after juices\nAnd(deliver_snack(snack, Gladstone), ForAll([s:schools], Implies(deliver_juice(juice, s), Not(deliver_snack(snack, s))))) ::: Gladstone is the third school to which snacks are delivered\nAnd(deliver_juice(juice, Isley), ForAll([s:schools], Implies(deliver_snack(snack, s), Not(deliver_juice(juice, s))))) ::: Isley is the fourth school to which juices are delivered\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_valid(Exists([t:trucks], ForAll([s:schools], deliver_juice(t, s) == deliver_snack(t, s))))) ::: (A)\nis_valid(Exists([t:trucks], ForAll([s:schools], deliver_snack(t, s) == deliver_juice(t, s))))) ::: (B)\nis_valid(Exists([t:trucks], ForAll([s:schools], deliver_juice(t, s) == deliver_snack(t, s))))) ::: (C)\nis_valid(Exists([t:trucks], ForAll([s:schools], deliver_snack(t, s) == deliver_juice(t, s))))) ::: (D)\nis_valid(Exists([t:trucks], ForAll([s:schools], deliver_juice(t, s) == deliver_snack(t, s))))) ::: (E)\n\n------\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_3_17",
    "context": "A company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.",
    "question": "Which one of the following, if substituted for the condition that Gladstone cannot be the fourth school to which juices are delivered, would have the same effect in determining the delivery schedule?",
    "answer": "B",
    "options": [
      "A) Ferndale must be either the second school or the fourth school to which juices are delivered.",
      "B) Gladstone must be either the second school or the third school to which juices are delivered.",
      "C) Hafford must be either the first school or the fourth school to which juices are delivered.",
      "D) The first school to which juices are delivered must be either Ferndale or Isley.",
      "E) The fourth school to which juices are delivered must be either Hafford or Isley."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA company operates vending machines in four schools: Ferndale, Gladstone, Hafford, and Isley. The company delivers juices in one of its two trucks and snacks in the other truck. Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school, subject to the following conditions: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford. Gladstone cannot be the fourth school to which juices are delivered. Gladstone must be the third school to which snacks are delivered. The first school to which juices are delivered must be the fourth one to which snacks are delivered.\nQuestion:\nWhich one of the following, if substituted for the condition that Gladstone cannot be the fourth school to which juices are delivered, would have the same effect in determining the delivery schedule?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nschools = EnumSort([Ferndale, Gladstone, Hafford, Isley])\ntrucks = EnumSort([juice, snack])\ndeliveries = EnumSort([juice, snack])\nweek = EnumSort([1, 2, 3, 4])\ndeliver(t:trucks, s:schools, w:week) ::: (t, s, w) -> [bool]\n\n# Constraints\nForAll([t:trucks, s:schools, w:week], deliver(t, s, w) == deliver(t, s, w + 1)) ::: Each week, exactly one delivery of juices and exactly one delivery of snacks is made to each school\nAnd(deliver(juice, Ferndale, 1), deliver(snack, Gladstone, 3)) ::: Snacks must be delivered to Ferndale at some time before they are delivered to Hafford\nAnd(deliver(snack, Gladstone, 2), deliver(juice, Hafford, 4)) ::: Gladstone must be the third school to which snacks are delivered\nOr(deliver(juice, Ferndale, 1), deliver(snack, Gladstone, 3)) ::: The first school to which juices are delivered must be the fourth one to which snacks are delivered\n\n# Options\nQuestion ::: Which one of the following, if substituted for the condition that Gladstone cannot be the fourth school to which juices are delivered, would have the same effect in determining the delivery schedule?\nis_sat(ForAll([t:trucks, s:schools, w:week], deliver(t, s, w) == deliver(t, s, w + 1))) ::: (A)\nis_sat(ForAll([t:trucks, s:schools, w:week], deliver(t, s, w) == deliver(t, s, w + 2))) ::: (B)\nis_sat(ForAll([t:trucks, s:schools, w:week], deliver(t, s, w) == deliver(t, s, w + 3))) ::: (C)\nis_sat(ForAll([t:trucks, s:schools, w:week], deliver(t, s, w) == deliver(t, s, w + 4))) ::: (D)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_4_18",
    "context": "Each of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.",
    "question": "Which one of the following could be the assignment of paralegals to cases?",
    "answer": "D",
    "options": [
      "A) Raimes: Frank Sicoli: Gina, Hiro, Kevin Thompson: Laurie",
      "B) Raimes: Kevin Sicoli: Gina Thompson: Frank, Hiro, Laurie",
      "C) Raimes: Gina, Kevin Sicoli: Frank, Hiro Thompson: Laurie",
      "D) Raimes: Kevin, Laurie Sicoli: Gina, Hiro Thompson: Frank",
      "E) Raimes: Frank, Kevin, Laurie Sicoli: Hiro Thompson: Gina"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.\nQuestion:\nWhich one of the following could be the assignment of paralegals to cases?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nparalegals = EnumSort([Frank, Gina, Hiro, Kevin, Laurie])\ncases = EnumSort([Raimes, Sicoli, Thompson])\nassignment = Function([paralegals, cases] -> [bool])\n\n# Constraints\nForAll([p:paralegals], Count([c:cases], assignment(p, c)) >= 1) ::: each paralegal is assigned to at least one case\nOr(assignment(Frank, Raimes), assignment(Kevin, Thompson)) ::: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson\nForAll([p:paralegals], Implies(assignment(p, Raimes), Not(assignment(p, Sicoli)))) ::: Hiro is assigned to Sicoli\nassignment(Hiro, Sicoli) ::: Hiro is the sole paralegal assigned to his case\nForAll([p:paralegals], Implies(assignment(p, Thompson), Not(assignment(p, Raimes)))) ::: Laurie is not the sole paralegal assigned to her case\n\n# Options\nQuestion ::: Which one of the following could be the assignment of paralegals to cases?\nis_valid(ForAll([p:paralegals], assignment(p, Raimes) == assignment(p, Sicoli))) ::: (A)\nis_valid(ForAll([p:paralegals], assignment(p, Sicoli) == assignment(p, Thompson))) ::: (B)\nis_valid(ForAll([p:paralegals], assignment(p, Raimes) == assignment(p, Thompson))) ::: (C)\nis_valid(ForAll([p:paralegals], assignment(p, Thompson) == assignment(p, Raimes))) ::: (D)\nis_valid(ForAll([p:paralegals], assignment(p, Sicoli) == assignment(p, Raimes))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_4_19",
    "context": "Each of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.",
    "question": "Which one of the following CANNOT be the complete assignment of paralegals to the Sicoli case?",
    "answer": "E",
    "options": [
      "A) Frank, Hiro, Kevin",
      "B) Frank, Hiro, Laurie",
      "C) Gina, Hiro, Kevin",
      "D) Gina, Hiro, Laurie",
      "E) Hiro, Kevin, Laurie"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.\nQuestion:\nWhich one of the following CANNOT be the complete assignment of paralegals to the Sicoli case?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nparalegals = EnumSort([Frank, Gina, Hiro, Kevin, Laurie])\ncases = EnumSort([Raimes, Sicoli, Thompson])\nassignment = Function([paralegals, cases] -> [bool])\n\n# Constraints\nForAll([p:paralegals], Count([c:cases], assignment(p, c)) >= 1) ::: each paralegal is assigned to at least one case\nAnd(assignment(Frank, Raimes), assignment(Kevin, Thompson)) ::: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson\nOr(assignment(Frank, Raimes), assignment(Gina, Sicoli)) ::: Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both\nassignment(Hiro, Sicoli) ::: Hiro is assigned to Sicoli\n\n# Options\nQuestion ::: Which one of the following CANNOT be the complete assignment of paralegals to the Sicoli case?\nis_valid(ForAll([p:paralegals], assignment(p, Sicoli) == assignment(Gina, Sicoli))) ::: (A)\nis_valid(ForAll([p:paralegals], assignment(p, Sicoli) == assignment(Laurie, Sicoli))) ::: (B)\nis_valid(ForAll([p:paralegals], assignment(p, Sicoli) == assignment(Hiro, Sicoli))) ::: (C)\nis_valid(ForAll([p:paralegals], assignment(p, Sicoli) == assignment(Kevin, Sicoli))) ::: (D)\nis_valid(ForAll([p:paralegals], assignment(p, Sicoli) == assignment(Frank, Sicoli))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_4_20",
    "context": "Each of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.",
    "question": "If exactly two of the paralegals are assigned to the Thompson case, then which one of the following could be the complete assignment of paralegals to the Raimes case?",
    "answer": "A",
    "options": [
      "A) Gina",
      "B) Kevin",
      "C) Laurie",
      "D) Gina, Kevin",
      "E) Kevin, Laurie"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.\nQuestion:\nIf exactly two of the paralegals are assigned to the Thompson case, then which one of the following could be the complete assignment of paralegals to the Raimes case?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nparalegals = EnumSort([Frank, Gina, Hiro, Kevin, Laurie])\ncases = EnumSort([Raimes, Sicoli, Thompson])\nassignment = Function([paralegals, cases] -> [bool])\n\n# Constraints\nForAll([p:paralegals], Count([c:cases], assignment(p, c)) >= 1) ::: each paralegal is assigned to at least one case\nAnd(assignment(Frank, Raimes), assignment(Kevin, Thompson)) ::: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson\nForAll([p:paralegals], Implies(assignment(p, Sicoli), Not(assignment(p, Raimes)))) ::: Hiro is assigned to Sicoli\nassignment(Hiro, Sicoli) ::: Hiro is the sole paralegal assigned to his case\nForAll([p:paralegals], Implies(assignment(p, Thompson), Not(assignment(p, Raimes)))) ::: Laurie is not assigned to Raimes\nassignment(Laurie, Thompson) ::: Laurie is the sole paralegal assigned to her case\n\n# Options\nQuestion ::: Which one of the following could be the complete assignment of paralegals to the Raimes case?\nis_sat(ForAll([p:paralegals], assignment(p, Raimes) == [Gina, Laurie])) ::: (A)\nis_sat(ForAll([p:paralegals], assignment(p, Raimes) == [Frank, Kevin])) ::: (B)\nis_sat(ForAll([p:paralegals], assignment(p, Raimes) == [Hiro, Laurie])) ::: (C)\nis_sat(ForAll([p:paralegals], assignment(p, Raimes) == [Laurie, Kevin])) ::: (D)\nis_sat(ForAll([p:paralegals], assignment(p, Raimes) == [Frank, Gina])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_4_21",
    "context": "Each of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.",
    "question": "If one of the cases has Gina and Laurie as the only paralegals assigned to it, then each of the following must be false EXCEPT:",
    "answer": "C",
    "options": [
      "A) Frank is assigned to the Raimes case.",
      "B) Frank is assigned to the Sicoli case.",
      "C) Gina is assigned to the Raimes case.",
      "D) Kevin is assigned to the Raimes case.",
      "E) Laurie is assigned to the Thompson case."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.\nQuestion:\nIf one of the cases has Gina and Laurie as the only paralegals assigned to it, then each of the following must be false EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\nparalegals = EnumSort([Frank, Gina, Hiro, Kevin, Laurie])\ncases = EnumSort([Raimes, Sicoli, Thompson])\nassigned = Function([paralegals, cases] -> [bool])\n\n# Constraints\nForAll([p:paralegals], Count([c:cases], assigned(p, c)) >= 1) ::: each paralegal is assigned to at least one case\nAnd(assigned(Frank, Raimes), assigned(Kevin, Thompson)) ::: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson\nForAll([p:paralegals], Implies(assigned(p, Sicoli), Not(assigned(Gina, Sicoli)))) ::: Hiro is assigned to Sicoli\nForAll([p:paralegals], Implies(assigned(p, Raimes), Not(assigned(Gina, Raimes)))) ::: Frank is not assigned to Raimes\nCount([p:paralegals], assigned(p, Sicoli)) == 1 ::: Hiro is the sole paralegal assigned to Sicoli\nCount([p:paralegals], assigned(p, Raimes)) == 1 ::: Frank is the sole paralegal assigned to Raimes\n\n# Options\nQuestion ::: ::: If one of the cases has Gina and Laurie as the only paralegals assigned to it, then each of the following must be false EXCEPT:\nis_sat(ForAll([c:cases], assigned(Gina, c) == assigned(Laurie, c))) ::: (A)\nis_sat(ForAll([c:cases], assigned(Laurie, c) == assigned(Gina, c))) ::: (B)\nis_sat(ForAll([c:cases], assigned(Gina, c) == assigned(Hiro, c))) ::: (C)\nis_sat(ForAll([c:cases], assigned(Laurie, c) == assigned(Hiro, c))) ::: (D)\nis_sat(ForAll([c:cases], assigned(Hiro, c) == assigned(Gina, c))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_4_22",
    "context": "Each of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.",
    "question": "Which one of the following CANNOT be the complete assignment of paralegals to the Thompson case?",
    "answer": "D",
    "options": [
      "A) Gina",
      "B) Laurie",
      "C) Gina, Kevin",
      "D) Gina, Laurie",
      "E) Kevin, Laurie"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.\nQuestion:\nWhich one of the following CANNOT be the complete assignment of paralegals to the Thompson case?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nparalegals = EnumSort([Frank, Gina, Hiro, Kevin, Laurie])\ncases = EnumSort([Raimes, Sicoli, Thompson])\nassignments = Function([paralegals, cases] -> [bool])\n\n# Constraints\nForAll([p:paralegals], Count([c:cases], assignments(p, c)) >= 1) ::: each paralegal is assigned to at least one case\nAnd(assignments(Frank, Raimes), Count([p:paralegals], And(p != Frank, assignments(p, Raimes))) == 1) ::: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson\nAnd(assignments(Gina, Sicoli), assignments(Gina, Thompson) == False) ::: Hiro is assigned to Sicoli\nForAll([p:paralegals], Implies(assignments(p, Thompson), Not(assignments(p, Raimes)))) ::: Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both\n\n# Options\nQuestion ::: Which one of the following CANNOT be the complete assignment of paralegals to the Thompson case?\nis_valid(Exists([p:paralegals], assignments(p, Thompson) == False)) ::: (A)\nis_valid(Exists([p:paralegals], assignments(p, Thompson) == True)) ::: (B)\nis_valid(Exists([p:paralegals], assignments(p, Sicoli) == True)) ::: (C)\nis_valid(Exists([p:paralegals], assignments(p, Raimes) == True)) ::: (D)\nis_valid(Exists([p:paralegals], assignments(p, Thompson) == False)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201306_2-G_4_23",
    "context": "Each of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.",
    "question": "If Kevin is the sole paralegal assigned to one of the cases then which one of the following lists all of the paralegals any one of",
    "answer": "B",
    "options": [
      "A) Frank, Kevin, Laurie",
      "B) Frank, Kevin",
      "C) Frank",
      "D) Gina",
      "E) Kevin"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach of five paralegals—Frank, Gina, Hiro, Kevin, and Laurie—is being assigned to exactly one of three cases—the Raimes, Sicoli, or Thompson case. At least one paralegal will be assigned to each case. The following conditions must apply: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson. Either Frank is the sole paralegal assigned to his case or Gina is the sole paralegal assigned to her case, but not both. Hiro is assigned to Sicoli.\nQuestion:\nIf Kevin is the sole paralegal assigned to one of the cases then which one of the following lists all of the paralegals any one of\nChoices:\n[[CHOICES]]\n###\n# Declarations\nparalegals = EnumSort([Frank, Gina, Hiro, Kevin, Laurie])\ncases = EnumSort([Raimes, Sicoli, Thompson])\nassigned = Function([paralegals, cases] -> [bool])\n\n# Constraints\nForAll([p:paralegals], Count([c:cases], assigned(p, c)) >= 1) ::: each paralegal is assigned to at least one case\nOr(assigned(Frank, Raimes), assigned(Kevin, Thompson)) ::: Either Frank is assigned to Raimes and Kevin is assigned to Thompson, or Frank is not assigned to Raimes and Kevin is not assigned to Thompson\nForAll([p:paralegals], Implies(assigned(p, Raimes), Not(assigned(p, Sicoli)))) ::: Hiro is assigned to Sicoli\nForAll([p:paralegals], Implies(assigned(Kevin, m), Not(assigned(p, m)))) ::: Kevin is the sole paralegal assigned to his case\n\n# Options\nQuestion ::: Which one of the following lists all of the paralegals any one of which is the sole paralegal assigned to one of the cases?\nis_sat(ForAll([p:paralegals], assigned(p, Raimes) == assigned(p, Sicoli))) ::: (A)\nis_sat(ForAll([p:paralegals], assigned(p, Raimes) == assigned(p, Thompson))) ::: (B)\nis_sat(ForAll([p:paralegals], assigned(p, Sicoli) == assigned(p, Thompson))) ::: (C)\nis_sat(ForAll([p:paralegals], assigned(p, Raimes) == assigned(p, Raimes))) ::: (D)\nis_sat(ForAll([p:paralegals], assigned(p, Sicoli) == assigned(p, Sicoli))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_1_1",
    "context": "A record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.",
    "question": "The five pieces could appear in which one of the following sequences on the CD, in order from first to last?",
    "answer": "B",
    "options": [
      "A) Reciprocity, Trapezoid, Wisteria, Salammbo, Vancouver",
      "B) Salammbo, Reciprocity, Trapezoid, Vancouver, Wisteria",
      "C) Trapezoid, Wisteria, Salammbo, Vancouver, Reciprocity",
      "D) Vancouver, Wisteria, Salammbo, Reciprocity, Trapezoid",
      "E) Wisteria, Salammbo, Vancouver, Trapezoid, Reciprocity"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.\nQuestion:\nThe five pieces could appear in which one of the following sequences on the CD, in order from first to last?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npieces = EnumSort([Reciprocity, Salammbo, Trapezoid, Vancouver, Wisteria])\ncd = EnumSort([CD])\nsequence = Function([pieces] -> [pieces])\n\n# Constraints\nForAll([p:pieces], sequence(p) != sequence(p, CD)) ::: each piece appears only once in the sequence\nAnd(sequence(Salammbo) == sequence(Reciprocity), sequence(Trapezoid) == sequence(Reciprocity, Salammbo)) ::: Salammbo must be earlier than Vancouver\nAnd(sequence(Trapezoid) == sequence(Reciprocity, Salammbo), sequence(Wisteria) == sequence(Reciprocity, Trapezoid, Salammbo)) ::: Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo\nAnd(sequence(Wisteria) == sequence(Reciprocity, Trapezoid), sequence(Vancouver) == sequence(Reciprocity, Trapezoid, Wisteria)) ::: Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid\n\n# Options\nQuestion ::: The five pieces could appear in which one of the following sequences on the CD, in order from first to last?\nis_valid(ForAll([p:pieces], sequence(p) == [[Reciprocity, Salammbo, Trapezoid, Vancouver, Wisteria]])) ::: (A)\nis_valid(ForAll([p:pieces], sequence(p) == [[Reciprocity, Salammbo, Wisteria, Trapezoid, Vancouver]])) ::: (B)\nis_valid(ForAll([p:pieces], sequence(p) == [[Salammbo, Reciprocity, Trapezoid, Vancouver, Wisteria]])) ::: (C)\nis_valid(ForAll([p:pieces], sequence(p) == [[Trapezoid, Reciprocity, Salammbo, Vancouver, Wisteria]])) ::: (D)\nis_valid(ForAll([p:pieces], sequence(p) == [[Vancouver, Wisteria, Trapezoid, Reciprocity, Salammbo]])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_1_2",
    "context": "A record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.",
    "question": "If Salammbo is the fourth piece on the CD, then which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) Reciprocity is earlier on the CD than Wisteria.",
      "B) Salammbo is earlier on the CD than Trapezoid.",
      "C) Trapezoid is earlier on the CD than Reciprocity.",
      "D) Vancouver is earlier on the CD than Wisteria.",
      "E) Wisteria is earlier on the CD than Trapezoid."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.\nQuestion:\nIf Salammbo is the fourth piece on the CD, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npieces = EnumSort([Reciprocity, Salammbo, Trapezoid, Vancouver, Wisteria])\norder = EnumSort([earlier, later])\n\n# Constraints\nForAll([p:pieces], Count([m:pieces], order(p, m)) >= 1) ::: each piece is in the sequence of pieces\nAnd(order(Salammbo, pieces[3]), Count([t:pieces], And(t != Salammbo, order(t, pieces[3]))) == 1) ::: Salammbo must be earlier than the third piece\nForAll([p:pieces], Or(order(p, pieces[0]), order(p, pieces[1]))) ::: Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo\nForAll([p:pieces], Or(order(p, pieces[2]), order(p, pieces[3]))) ::: Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid\n\n# Options\nQuestion ::: Which one of the following must be true if Salammbo is the fourth piece on the CD?\nis_valid(ForAll([p:pieces], order(Salammbo, p) == earlier)) ::: (A)\nis_valid(ForAll([p:pieces], order(Salammbo, p) == later)) ::: (B)\nis_valid(ForAll([p:pieces], order(Salammbo, p) == earlier, order(Trapezoid, pieces[2]) == later)) ::: (C)\nis_valid(ForAll([p:pieces], order(Salammbo, p) == later, order(Trapezoid, pieces[2]) == earlier)) ::: (D)\nis_valid(ForAll([p:pieces], order(Salammbo, p) == earlier, order(Wisteria, pieces[3]) == later)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_1_3",
    "context": "A record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.",
    "question": "If Reciprocity is the first piece on the CD, then which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) Trapezoid is the second piece on the CD.",
      "B) Vancouver is the third piece on the CD.",
      "C) Wisteria is the third piece on the CD.",
      "D) Salammbo is the fourth piece on the CD.",
      "E) Trapezoid is the last piece on the CD."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.\nQuestion:\nIf Reciprocity is the first piece on the CD, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npieces = EnumSort([Reciprocity, Salammbo, Trapezoid, Vancouver, Wisteria])\norder = EnumSort([earlier, later])\n\n# Constraints\nForAll([p:pieces], Implies(order(p, Reciprocity), order(p, Salammbo) == earlier)) ::: Salammbo must be earlier than Vancouver\nForAll([p:pieces], Implies(order(p, Trapezoid), And(order(p, Reciprocity) == earlier, order(p, Salammbo) == later))) ::: Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo\nForAll([p:pieces], Implies(order(p, Wisteria), And(order(p, Reciprocity) == earlier, order(p, Trapezoid) == later))) ::: Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid\n\n# Options\nQuestion ::: If Reciprocity is the first piece on the CD, then which one of the following could be true?\nis_valid(ForAll([p:pieces], order(p, Reciprocity) == earlier)) ::: (A)\nis_valid(ForAll([p:pieces], order(p, Reciprocity) == later)) ::: (B)\nis_valid(ForAll([p:pieces], order(p, Salammbo) == earlier)) ::: (C)\nis_valid(ForAll([p:pieces], order(p, Salammbo) == later)) ::: (D)\nis_valid(ForAll([p:pieces], order(p, Trapezoid) == earlier)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_1_4",
    "context": "A record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.",
    "question": "If Trapezoid is the second piece on the CD, then which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Salammbo is the first piece on the CD.",
      "B) Reciprocity is the first piece on the CD.",
      "C) Vancouver is the third piece on the CD.",
      "D) Wisteria is the fourth piece on the CD.",
      "E) Reciprocity is the last piece on the CD."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.\nQuestion:\nIf Trapezoid is the second piece on the CD, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npieces = EnumSort([Reciprocity, Salammbo, Trapezoid, Vancouver, Wisteria])\norder = EnumSort([earlier, later])\n\n# Constraints\nForAll([p:pieces], Count([o:order], p == o)) ::: each piece is in exactly one order\nAnd(Count([p:pieces], And(p == Salammbo, p == earlier)), Count([p:pieces], And(p == Vancouver, p == later))) ::: Salammbo must be earlier than Vancouver\nAnd(Count([p:pieces], And(p == Trapezoid, p == earlier)), Count([p:pieces], And(p == Reciprocity, p == later))) ::: Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo\nAnd(Count([p:pieces], And(p == Wisteria, p == earlier)), Count([p:pieces], And(p == Reciprocity, p == later))) ::: Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid\n\n# Options\nQuestion ::: Which one of the following could be true if Trapezoid is the second piece on the CD?\nis_valid(ForAll([p:pieces], And(p == Trapezoid, p == earlier))) ::: (A)\nis_valid(ForAll([p:pieces], And(p == Trapezoid, p == later))) ::: (B)\nis_valid(ForAll([p:pieces], And(p == Reciprocity, p == earlier))) ::: (C)\nis_valid(ForAll([p:pieces], And(p == Reciprocity, p == later))) ::: (D)\nis_valid(ForAll([p:pieces], And(p == Salammbo, p == earlier))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_1_5",
    "context": "A record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.",
    "question": "The first and second pieces on the CD, listed in order, could be",
    "answer": "E",
    "options": [
      "A) Reciprocity and Vancouver",
      "B) Reciprocity and Wisteria",
      "C) Salammbo and Trapezoid",
      "D) Trapezoid and Wisteria",
      "E) Wisteria and Salammbo"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.\nQuestion:\nThe first and second pieces on the CD, listed in order, could be\nChoices:\n[[CHOICES]]\n###\n# Declarations\npieces = EnumSort([Reciprocity, Salammbo, Trapezoid, Vancouver, Wisteria])\norder = EnumSort([First, Second])\n\n# Constraints\nForAll([p:pieces], p in order(p)) ::: each piece is in the correct order\nAnd(order(Reciprocity), order(Salammbo) == First) ::: Salammbo must be earlier than Reciprocity\nAnd(order(Trapezoid), Or(order(Reciprocity), order(Salammbo))) ::: Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo\nAnd(order(Wisteria), Or(order(Reciprocity), order(Trapezoid))) ::: Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid\n\n# Options\nQuestion ::: The first and second pieces on the CD, listed in order, could be\nis_valid(ForAll([p:pieces], order(p) == [Reciprocity, Salammbo, Trapezoid, Vancouver, Wisteria])) ::: (A)\nis_valid(ForAll([p:pieces], order(p) == [Salammbo, Reciprocity, Trapezoid, Vancouver, Wisteria])) ::: (B)\nis_valid(ForAll([p:pieces], order(p) == [Trapezoid, Reciprocity, Salammbo, Vancouver, Wisteria])) ::: (C)\nis_valid(ForAll([p:pieces], order(p) == [Vancouver, Salammbo, Reciprocity, Trapezoid, Wisteria])) ::: (D)\nis_valid(ForAll([p:pieces], order(p) == [Wisteria, Salammbo, Reciprocity, Trapezoid, Vancouver])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_1_6",
    "context": "A record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.",
    "question": "If Vancouver is the second piece on the CD, then which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Wisteria is the first piece on the CD.",
      "B) Salammbo is the third piece on the CD.",
      "C) Trapezoid is the third piece on the CD.",
      "D) Reciprocity is the fourth piece on the CD.",
      "E) Reciprocity is the last piece on the CD."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.\nQuestion:\nIf Vancouver is the second piece on the CD, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npieces = EnumSort([Reciprocity, Salammbo, Trapezoid, Vancouver, Wisteria])\norder = EnumSort([earlier, later])\n\n# Constraints\nForAll([p:pieces], Count([o:order], p == o)) ::: each piece is in exactly one order\nAnd(Count([p:pieces], And(p == Salammbo, p == 2)) == 1) ::: Salammbo must be earlier than Vancouver\nAnd(Count([p:pieces], And(p == Trapezoid, p == 2)) == 1) ::: Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo\nAnd(Count([p:pieces], And(p == Wisteria, p == 2)) == 1) ::: Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid\n\n# Options\nQuestion ::: Which one of the following could be true if Vancouver is the second piece on the CD?\nis_valid(ForAll([p:pieces], And(p == Vancouver, p == 2))) ::: (A)\nis_valid(ForAll([p:pieces], And(p == Trapezoid, p == 2))) ::: (B)\nis_valid(ForAll([p:pieces], And(p == Wisteria, p == 2))) ::: (C)\nis_valid(ForAll([p:pieces], And(p == Salammbo, p == 2))) ::: (D)\nis_valid(ForAll([p:pieces], And(p == Reciprocity, p == 2))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_1_7",
    "context": "A record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.",
    "question": "If Wisteria is the first piece on the CD, then which one of the following CANNOT be true?",
    "answer": "A",
    "options": [
      "A) Trapezoid is the third piece on the CD.",
      "B) Vancouver is the third piece on the CD.",
      "C) Salammbo is the fourth piece on the CD.",
      "D) Vancouver is the fourth piece on the CD",
      "E) Trapezoid is the last piece on the CD."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA record producer is planning the contents of a CD consisting of a sequence of exactly five instrumental pieces—Reciprocity, Salammbo, Trapezoid, Vancouver, and Wisteria. To create and sustain certain moods, the sequence of pieces will satisfy the following constraints: Salammbo must be earlier than Vancouver. Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo. Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid.\nQuestion:\nIf Wisteria is the first piece on the CD, then which one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npieces = EnumSort([Reciprocity, Salammbo, Trapezoid, Vancouver, Wisteria])\norder = EnumSort([earlier, later])\n\n# Constraints\nForAll([p:pieces], Implies(order(p), order(pieces[p]))) ::: for each piece p, the order of p must be the same as the order of pieces[p]\nAnd(order(Salammbo) == earlier, order(Vancouver) == later) ::: Salammbo must be earlier than Vancouver\nAnd(order(Trapezoid) == either(earlier, later), order(Reciprocity) == either(earlier, later)) ::: Trapezoid must either be earlier than both Reciprocity and Salammbo or later than both Reciprocity and Salammbo\nAnd(order(Wisteria) == either(earlier, later), order(Trapezoid) == either(earlier, later)) ::: Wisteria must either be earlier than both Reciprocity and Trapezoid or later than both Reciprocity and Trapezoid\n\n# Options\nQuestion ::: Which one of the following CANNOT be true if Wisteria is the first piece on the CD?\nis_valid(ForAll([p:pieces], order(p) == earlier)) ::: (A)\nis_valid(ForAll([p:pieces], order(p) == later)) ::: (B)\nis_valid(ForAll([p:pieces], order(p) == Trapezoid)) ::: (C)\nis_valid(ForAll([p:pieces], order(p) == Vancouver)) ::: (D)\nis_valid(ForAll([p:pieces], order(p) == Wisteria)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_2_8",
    "context": "At a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.",
    "question": "Which one of the following could be the speeches given in each room, listed in the order in which they occur?",
    "answer": "A",
    "options": [
      "A) Gold Room: Molina's, Long's Rose Room: Zimmerman's, Xiao's, Yoshida's",
      "B) Gold Room: Molina's, Yoshida's, Long's Rose Room: Xiao's Zimmerman's",
      "C) Gold Room: Xiao's, Molina's, Long's Rose Room: Zimmerman's, Yoshida's",
      "D) Gold Room: Yoshida's, Long's, Molina's Rose Room: Zimmerman's, Xiao's",
      "E) Gold Room: Zimmerman's, Molina's Rose Room: Xiao's, Yoshida's, Long's"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAt a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.\nQuestion:\nWhich one of the following could be the speeches given in each room, listed in the order in which they occur?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nspeakers = EnumSort([Long, Molina, Xiao, Yoshida, Zimmerman])\nrooms = EnumSort([Gold Room, Rose Room])\nspeeches = EnumSort([1 P.M., 2 P.M., 3 P.M.])\ngives = Function([speakers, rooms] -> [speeches])\n\n# Constraints\nForAll([s:speakers], Count([r:rooms], gives(s, r) >= 1)) ::: each speaker gives at least one speech\nAnd(gives(Molina, Gold Room), gives(Long, Gold Room) < gives(Molina, Gold Room)) ::: Molina's speech must be earlier than Long's, and in the same room\nOr(gives(Xiao, Gold Room), gives(Yoshida, Rose Room)) ::: Xiao's speech or Yoshida's speech cannot be earlier than Zimmerman's\nIf gives(Long, Gold Room), Then(gives(Xiao, Rose Room), gives(Zimmerman, Rose Room)) ::: If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room\n\n# Options\nQuestion ::: Which one of the following could be the speeches given in each room, listed in the order in which they occur?\nis_valid(Exists([r:rooms], gives(Molina, r) == [1 P.M., 2 P.M.])) ::: (A)\nis_valid(Exists([r:rooms], gives(Xiao, r) == [1 P.M., 3 P.M.])) ::: (B)\nis_valid(Exists([r:rooms], gives(Yoshida, r) == [2 P.M., 3 P.M.])) ::: (C)\nis_valid(Exists([r:rooms], gives(Zimmerman, r) == [1 P.M., 2 P.M.])) ::: (D)\nis_valid(Exists([r:rooms], gives(Long, r) == [3 P.M.])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_2_9",
    "context": "At a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.",
    "question": "Which one of the following pairs of speeches CANNOT be given at the same time?",
    "answer": "B",
    "options": [
      "A) Long's and Yoshida's",
      "B) Long's and Zimmerman's",
      "C) Molina's and Xiao's",
      "D) Xiao's and Yoshida's",
      "E) Yoshida's and Zimmerman's"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAt a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.\nQuestion:\nWhich one of the following pairs of speeches CANNOT be given at the same time?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nspeakers = EnumSort([Long, Molina, Xiao, Yoshida, Zimmerman])\nrooms = EnumSort([Gold Room, Rose Room])\nspeeches = EnumSort([1 PM, 2 PM, 3 PM])\ngives = Function([speakers, rooms] -> [speeches])\n\n# Constraints\nForAll([s:speakers], Count([r:rooms], gives(s, r) >= 1)) ::: each speaker gives at least one speech\nAnd(gives(Molina, Gold Room), gives(Long, Gold Room) < gives(Molina, Gold Room)) ::: Molina's speech must be earlier than Long's, and in the same room\nOr(gives(Xiao, Gold Room), gives(Zimmerman, Rose Room)) ::: Xiao's speech cannot be earlier than Zimmerman's\nIf gives(Long, Gold Room), Then(gives(Xiao, Rose Room), gives(Zimmerman, Gold Room)) ::: If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room\n\n# Options\nQuestion ::: Which one of the following pairs of speeches CANNOT be given at the same time?\nis_valid(Exists([r:rooms], gives(Molina, r) == gives(Xiao, r))) ::: (A)\nis_valid(Exists([r:rooms], gives(Xiao, r) == gives(Yoshida, r))) ::: (B)\nis_valid(Exists([r:rooms], gives(Yoshida, r) == gives(Zimmerman, r))) ::: (C)\nis_valid(Exists([r:rooms], gives(Zimmerman, r) == gives(Molina, r))) ::: (D)\nis_valid(Exists([r:rooms], gives(Molina, r) == gives(Long, r))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_2_10",
    "context": "At a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.",
    "question": "If Xiao's speech is at 3 P.M., which one of the following CANNOT be true?",
    "answer": "A",
    "options": [
      "A) Long's speech is in the same room as Yoshida's.",
      "B) Molina's speech is in the same room as Xiao's.",
      "C) Xiao's speech is in the same room as Yoshida's.",
      "D) Xiao's speech is in the same room as Zimmerman's.",
      "E) Yoshida's speech is in the same room as Zimmerman's."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAt a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.\nQuestion:\nIf Xiao's speech is at 3 P.M., which one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nspeakers = EnumSort([Long, Molina, Xiao, Yoshida, Zimmerman])\nrooms = EnumSort([Gold Room, Rose Room])\nspeeches = EnumSort([1 P.M., 2 P.M., 3 P.M.])\ngives = Function([speakers, rooms] -> [speeches])\n\n# Constraints\nForAll([s:speakers], Count([r:rooms], gives(s, r)) >= 1) ::: each speaker gives a speech in at least one of the rooms\nAnd(gives(Molina, Gold Room), gives(Long, Gold Room)) ::: Molina's speech must be earlier than Long's, and in the same room\nOr(gives(Xiao, Rose Room), gives(Zimmerman, Rose Room)) ::: If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room\nNot(gives(Xiao, 3 P.M.), gives(Yoshida, 3 P.M.)) ::: Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_valid(Exists([s:speakers], gives(s, 3 P.M.) == Xiao)) ::: (A)\nis_valid(Exists([s:speakers], gives(s, 3 P.M.) == Yoshida)) ::: (B)\nis_valid(Exists([s:speakers], gives(s, 3 P.M.) == Zimmerman)) ::: (C)\nis_valid(Exists([s:speakers], gives(s, 3 P.M.) == Long)) ::: (D)\nis_valid(Exists([s:speakers], gives(s, 3 P.M.) == Molina)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_2_11",
    "context": "At a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.",
    "question": "Which one of the following could be a complete and accurate list of the speeches given in the Gold Room, in the order in which they occur?",
    "answer": "C",
    "options": [
      "A) Long's, Molina's",
      "B) Molina's, Yoshida's",
      "C) Molina's, Yoshida's, Long's",
      "D) Yoshida's, Zimmerman's, Xiao's",
      "E) Zimmerman's, Molina's, Long's"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAt a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.\nQuestion:\nWhich one of the following could be a complete and accurate list of the speeches given in the Gold Room, in the order in which they occur?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nspeakers = EnumSort([Long, Molina, Xiao, Yoshida, Zimmerman])\nrooms = EnumSort([Gold Room, Rose Room])\nspeeches = EnumSort([1 P.M., 2 P.M., 3 P.M.])\ngives = Function([speakers, rooms] -> [speeches])\n\n# Constraints\nForAll([s:speakers], Count([r:rooms], gives(s, r)) >= 1) ::: each speaker gives at least one speech in at least one room\nAnd(gives(Molina, Gold Room), gives(Long, Gold Room) < gives(Molina, Gold Room)) ::: Molina's speech must be earlier than Long's, and in the same room\nOr(gives(Xiao, Gold Room), gives(Zimmerman, Rose Room)) ::: Xiao's speech or Zimmerman's speech must be in the Gold Room\nIf gives(Long, Gold Room), Then(gives(Xiao, Rose Room), gives(Zimmerman, Gold Room)) ::: If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the speeches given in the Gold Room, in the order in which they occur?\nis_valid(ForAll([s:speakers], gives(s, Gold Room) == [[1 P.M., 2 P.M.]])) ::: (A)\nis_valid(ForAll([s:speakers], gives(s, Gold Room) == [[1 P.M., 3 P.M.]])) ::: (B)\nis_valid(ForAll([s:speakers], gives(s, Gold Room) == [[2 P.M., 3 P.M.]])) ::: (C)\nis_valid(ForAll([s:speakers], gives(s, Gold Room) == [[1 P.M., 2 P.M.]])) ::: (D)\nis_valid(ForAll([s:speakers], gives(s, Gold Room) == [[3 P.M., 2 P.M.]])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_2_12",
    "context": "At a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.",
    "question": "If Yoshida's speech is at 1 P.M., which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) Long's speech is at 1 P.M. in the Gold Room.",
      "B) Long's speech is at 2 P.M. in the Rose Room.",
      "C) Molina's speech is at 2 P.M. in the Gold Room.",
      "D) Xiao's speech is at 3 P.M. in the Gold Room.",
      "E) Xiao's speech is at 1 P.M. in the Rose Room."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAt a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.\nQuestion:\nIf Yoshida's speech is at 1 P.M., which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nspeakers = EnumSort([Long, Molina, Xiao, Yoshida, Zimmerman])\nrooms = EnumSort([Gold Room, Rose Room])\nspeeches = EnumSort([1 P.M., 2 P.M., 3 P.M.])\ngives = Function([speakers, rooms] -> [speeches])\n\n# Constraints\nForAll([s:speakers], Count([r:rooms], gives(s, r) >= 1)) ::: each speaker gives at least one speech\nAnd(gives(Molina, Gold Room), gives(Long, Gold Room) < gives(Molina, Gold Room)) ::: Molina's speech must be earlier than Long's, and in the same room\nOr(gives(Xiao, Gold Room), gives(Zimmerman, Rose Room)) ::: Xiao's speech or Zimmerman's speech must be in the Gold Room if Long's speech is there\nForAll([r:rooms], Implies(gives(Yoshida, r), Not(gives(Zimmerman, r)) if gives(Long, Gold Room) then gives(Xiao, Rose Room))) ::: Yoshida's speech cannot be earlier than Zimmerman's speech, and if Long's speech is in the Gold Room, then Xiao's speech must be in the Rose Room\n\n# Options\nQuestion ::: Which one of the following could be true if Yoshida's speech is at 1 P.M.?\nis_valid(ForAll([r:rooms], gives(Yoshida, r) == 1 P.M.)) ::: (A)\nis_valid(ForAll([r:rooms], gives(Yoshida, r) == 2 P.M.)) ::: (B)\nis_valid(ForAll([r:rooms], gives(Yoshida, r) == 3 P.M.)) ::: (C)\nis_valid(ForAll([r:rooms], gives(Yoshida, r) == 1 P.M. if gives(Long, Gold Room) then gives(Xiao, Rose Room))) ::: (D)\nis_valid(ForAll([r:rooms], gives(Yoshida, r) == 2 P.M. if gives(Long, Gold Room) then gives(Xiao, Rose Room))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_2_13",
    "context": "At a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.",
    "question": "Which one of the following, if substituted for the constraint that neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's, would have the same effect in determining the schedule of speeches with regard to rooms and times?",
    "answer": "E",
    "options": [
      "A) Long's speech must be at 3 P.M.",
      "B) Molina's speech cannot be earlier than Zimmerman's.",
      "C) Either Xiao's speech or Yoshida's speech must be after Zimmerman's.",
      "D) Either Xiao's speech or Yoshida's speech or both must be at 2 P.M.",
      "E) Zimmerman's speech must be at 1 P.M."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAt a business symposium there will be exactly five speakers: Long, Molina, Xiao, Yoshida, and Zimmerman. Each speaker will give exactly one speech, in either the Gold Room or the Rose Room. In each room, there will be exactly one speech at 1 P.M. and one speech at 2 P.M. In one of the rooms, yet to be determined, there will also be a speech at 3 P.M. The schedule of speeches is constrained by the following: Molina's speech must be earlier than Long's, and in the same room. Neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's. If Long's speech is in the Gold Room, then Xiao's and Zimmerman's speeches must both be in the Rose Room.\nQuestion:\nWhich one of the following, if substituted for the constraint that neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's, would have the same effect in determining the schedule of speeches with regard to rooms and times?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nspeakers = EnumSort([Long, Molina, Xiao, Yoshida, Zimmerman])\nrooms = EnumSort([Gold Room, Rose Room])\nspeeches = EnumSort([1 P.M., 2 P.M., 3 P.M.])\nschedule = Function([speakers, rooms] -> [speeches])\n\n# Constraints\nForAll([s:speakers], Count([r:rooms], schedule(s, r)) >= 1) ::: each speaker gives a speech in at least one of the rooms\nAnd(schedule(Molina, Gold Room), schedule(Long, Gold Room) < schedule(Molina, Gold Room)) ::: Molina's speech must be earlier than Long's, and in the same room\nOr(schedule(Xiao, Rose Room), schedule(Yoshida, Rose Room)) ::: Xiao's speech and Yoshida's speech cannot be in the same room\nIf schedule(Long, Gold Room), Then schedule(Xiao, Rose Room) ::: If Long's speech is in the Gold Room, then Xiao's speech must be in the Rose Room\n\n# Options\nQuestion ::: Which one of the following, if substituted for the constraint that neither Xiao's speech nor Yoshida's speech can be earlier than Zimmerman's, would have the same effect in determining the schedule of speeches with regard to rooms and times?\nis_sat(ForAll([s:speakers], schedule(s, Gold Room) == schedule(s, Rose Room))) ::: (A)\nis_sat(ForAll([s:speakers], schedule(s, Gold Room) == schedule(s, 3 P.M.))) ::: (B)\nis_sat(ForAll([s:speakers], schedule(s, Rose Room) == schedule(s, 3 P.M.))) ::: (C)\nis_sat(ForAll([s:speakers], schedule(s, Gold Room) == schedule(s, Yoshida))) ::: (D)\nis_sat(ForAll([s:speakers], schedule(s, Rose Room) == schedule(s, Zimmerman))) ::: (E)\n\n------\n\nNote: The problem and question statements are given in a logical form, which is a standard way of representing problems in logic programming. The goal is to write the problem and question in a way that can be solved using logical reasoning and inference. The three parts of a logic program are:\n\n1. Declarations: This section defines the variables and functions that are used in the problem and question.\n2. Constraints: This section specifies the constraints that must be satisfied in order to find a valid solution to the problem.\n3. Options: This section provides the possible options for the question, which are the possible answers that can be given to the question.\n\nIn each part, we use logical operators such as `ForAll`, `And`, `Or`, and `Implies` to define the constraints and options. The `is_sat` function is used to check whether a given option is valid or not."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_3_14",
    "context": "During the seventeenth century, three families—the Trents, the Williamses, and the Yandells—owned the five buildings that constituted the center of their village—the forge, the granary, the inn, the mill, and the stable. Each family owned at least one of the buildings and each building was owned by exactly one of the families. The historical evidence establishes the following about the ownership of the buildings: The Williamses owned more of the buildings than the Yandells owned. Neither the inn nor the mill belonged to the owner of the forge. Either the Trents owned the stable or the Yandells owned the inn, or both.",
    "question": "Which one of the following could be an accurate matching of each family to the building or buildings it owned?",
    "answer": "A",
    "options": [
      "A) Trents: the granary, the stable Williamses: the inn, the mill Yandells: the forge",
      "B) Trents: the granary, the mill Williamses: the inn, the stable Yandells: the forge",
      "C) Trents: the forge, the mill Williamses: the granary, the stable Yandells: the inn",
      "D) Trents: the forge, the granary Williamses: the mill Yandells: the inn, the stable",
      "E) Trents: the stable Williamses: the inn, the mill Yandells: the forge, the granary"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nDuring the seventeenth century, three families—the Trents, the Williamses, and the Yandells—owned the five buildings that constituted the center of their village—the forge, the granary, the inn, the mill, and the stable. Each family owned at least one of the buildings and each building was owned by exactly one of the families. The historical evidence establishes the following about the ownership of the buildings: The Williamses owned more of the buildings than the Yandells owned. Neither the inn nor the mill belonged to the owner of the forge. Either the Trents owned the stable or the Yandells owned the inn, or both.\nQuestion:\nWhich one of the following could be an accurate matching of each family to the building or buildings it owned?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfamilies = EnumSort([Trents, Williamses, Yandells])\nbuildings = EnumSort([forge, granary, inn, mill, stable])\nowns = Function([families, buildings] -> [bool])\n\n# Constraints\nForAll([f:families], Count([b:buildings], owns(f, b)) >= 1) ::: each family owns at least one building\nAnd(owns(Williamses, forge), Count([f:families], And(f != Williamses, owns(f, forge))) >= 2) ::: The Williamses owned more of the buildings than the Yandells owned\nImplies(owns(Trents, stable), Not(owns(Yandells, stable))) ::: Either the Trents owned the stable or the Yandells owned the inn, or both\nImplies(owns(Yandells, inn), Not(owns(Trents, inn))) ::: Either the Trents owned the stable or the Yandells owned the inn, or both\n\n# Options\nQuestion ::: Which one of the following could be an accurate matching of each family to the building or buildings it owned?\nis_sat(ForAll([b:buildings], owns(Trents, b) == [forge, stable])) ::: (A)\nis_sat(ForAll([b:buildings], owns(Williamses, b) == [forge, inn, mill])) ::: (B)\nis_sat(ForAll([b:buildings], owns(Yandells, b) == [inn, stable])) ::: (C)\nis_sat(ForAll([b:buildings], owns(Trents, b) == [stable, forge])) ::: (D)\nis_sat(ForAll([b:buildings], owns(Yandells, b) == [stable, inn])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may have different constraints and options."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_3_15",
    "context": "During the seventeenth century, three families—the Trents, the Williamses, and the Yandells—owned the five buildings that constituted the center of their village—the forge, the granary, the inn, the mill, and the stable. Each family owned at least one of the buildings and each building was owned by exactly one of the families. The historical evidence establishes the following about the ownership of the buildings: The Williamses owned more of the buildings than the Yandells owned. Neither the inn nor the mill belonged to the owner of the forge. Either the Trents owned the stable or the Yandells owned the inn, or both.",
    "question": "Which one of the following is a pair of buildings that CANNOT both have been owned by the Trents?",
    "answer": "D",
    "options": [
      "A) the forge, the granary",
      "B) the granary, the mill",
      "C) the granary, the stable",
      "D) the inn, the mill",
      "E) the inn, the stable"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nDuring the seventeenth century, three families—the Trents, the Williamses, and the Yandells—owned the five buildings that constituted the center of their village—the forge, the granary, the inn, the mill, and the stable. Each family owned at least one of the buildings and each building was owned by exactly one of the families. The historical evidence establishes the following about the ownership of the buildings: The Williamses owned more of the buildings than the Yandells owned. Neither the inn nor the mill belonged to the owner of the forge. Either the Trents owned the stable or the Yandells owned the inn, or both.\nQuestion:\nWhich one of the following is a pair of buildings that CANNOT both have been owned by the Trents?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfamilies = EnumSort([Trents, Williamses, Yandells])\nbuildings = EnumSort([forge, granary, inn, mill, stable])\nowners = Function([families, buildings] -> [bool])\n\n# Constraints\nForAll([f:families], Count([b:buildings], owners(f, b)) >= 1) ::: each family owns at least one building\nAnd(owners(Williamses, inn), Count([f:families], And(f != Williamses, owners(f, inn))) == 2) ::: The Williamses owned more of the buildings than the Yandells owned\nImplies(owners(Trents, stable), Not(owners(Yandells, inn))) ::: Either the Trents owned the stable or the Yandells owned the inn, or both\nImplies(owners(Yandells, mill), Not(owners(Trents, stable))) ::: Either the Trents owned the stable or the Yandells owned the mill\n\n# Options\nQuestion ::: Which one of the following is a pair of buildings that CANNOT both have been owned by the Trents?\nis_valid(Exists([b:buildings], owners(Trents, b) == owners(Yandells, b))) ::: (A)\nis_valid(Exists([b:buildings], owners(Trents, b) == owners(Williamses, b))) ::: (B)\nis_valid(Exists([b:buildings], owners(Trents, b) == owners(Yandells, b))) ::: (C)\nis_valid(Exists([b:buildings], owners(Yandells, b) == owners(Trents, b))) ::: (D)\nis_valid(Exists([b:buildings], owners(Yandells, b) == owners(Williamses, b))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_3_16",
    "context": "During the seventeenth century, three families—the Trents, the Williamses, and the Yandells—owned the five buildings that constituted the center of their village—the forge, the granary, the inn, the mill, and the stable. Each family owned at least one of the buildings and each building was owned by exactly one of the families. The historical evidence establishes the following about the ownership of the buildings: The Williamses owned more of the buildings than the Yandells owned. Neither the inn nor the mill belonged to the owner of the forge. Either the Trents owned the stable or the Yandells owned the inn, or both.",
    "question": "If the Yandells owned the mill, which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) The Trents owned the forge.",
      "B) The Trents owned the inn.",
      "C) The Williamses owned the forge.",
      "D) The Williamses owned the granary.",
      "E) The Williamses owned the inn."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nDuring the seventeenth century, three families—the Trents, the Williamses, and the Yandells—owned the five buildings that constituted the center of their village—the forge, the granary, the inn, the mill, and the stable. Each family owned at least one of the buildings and each building was owned by exactly one of the families. The historical evidence establishes the following about the ownership of the buildings: The Williamses owned more of the buildings than the Yandells owned. Neither the inn nor the mill belonged to the owner of the forge. Either the Trents owned the stable or the Yandells owned the inn, or both.\nQuestion:\nIf the Yandells owned the mill, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfamilies = EnumSort([Trents, Williamses, Yandells])\nbuildings = EnumSort([forge, granary, inn, mill, stable])\nowned = Function([families, buildings] -> [bool])\n\n# Constraints\nForAll([b:buildings], Count([f:families], owned(f, b)) >= 1) ::: each building is owned by exactly one of the families\nAnd(owned(Williamses, mill), Count([f:families], And(f != Williamses, owned(f, mill))) == 2) ::: The Williamses owned more of the buildings than the Yandells owned\nImplies(owned(Trents, stable), Not(owned(Yandells, inn))) ::: Either the Trents owned the stable or the Yandells owned the inn, or both\nImplies(owned(Yandells, mill), Not(owned(Williamses, inn))) ::: Either the Yandells owned the mill or the Williamses owned the inn\n\n# Options\nQuestion ::: Which one of the following must be true if the Yandells owned the mill?\nis_valid(ForAll([b:buildings], owned(Yandells, b) == true)) ::: (A)\nis_valid(ForAll([b:buildings], owned(Yandells, b) == false)) ::: (B)\nis_valid(ForAll([b:buildings], owned(Yandells, b) == owned(Williamses, b))) ::: (C)\nis_valid(ForAll([b:buildings], owned(Yandells, b) == owned(Trents, b))) ::: (D)\nis_valid(ForAll([b:buildings], owned(Yandells, b) == owned(Trents, b) && owned(Williamses, b))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may have different constraints and options."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_3_17",
    "context": "During the seventeenth century, three families—the Trents, the Williamses, and the Yandells—owned the five buildings that constituted the center of their village—the forge, the granary, the inn, the mill, and the stable. Each family owned at least one of the buildings and each building was owned by exactly one of the families. The historical evidence establishes the following about the ownership of the buildings: The Williamses owned more of the buildings than the Yandells owned. Neither the inn nor the mill belonged to the owner of the forge. Either the Trents owned the stable or the Yandells owned the inn, or both.",
    "question": "If one of the families owned both the granary and the inn, which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) The Trents owned the granary.",
      "B) The Trents owned the mill.",
      "C) The Williamses owned the forge.",
      "D) The Williamses owned the stable.",
      "E) The Yandells owned the inn."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nDuring the seventeenth century, three families—the Trents, the Williamses, and the Yandells—owned the five buildings that constituted the center of their village—the forge, the granary, the inn, the mill, and the stable. Each family owned at least one of the buildings and each building was owned by exactly one of the families. The historical evidence establishes the following about the ownership of the buildings: The Williamses owned more of the buildings than the Yandells owned. Neither the inn nor the mill belonged to the owner of the forge. Either the Trents owned the stable or the Yandells owned the inn, or both.\nQuestion:\nIf one of the families owned both the granary and the inn, which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfamilies = EnumSort([Trents, Williamses, Yandells])\nbuildings = EnumSort([forge, granary, inn, mill, stable])\nowned = Function([families, buildings] -> [bool])\n\n# Constraints\nForAll([b:buildings], Count([f:families], owned(f, b)) >= 1) ::: each building is owned by at least one family\nAnd(owned(Williamses, inn), Count([t:families], And(t != Williamses, owned(t, inn))) == 2) ::: The Williamses owned more of the buildings than the Yandells owned\nImplies(owned(Trents, stable), Not(owned(Yandells, inn))) ::: Either the Trents owned the stable or the Yandells owned the inn, or both\nImplies(owned(Yandells, mill), Not(owned(Trents, inn))) ::: Neither the inn nor the mill belonged to the owner of the forge\n\n# Options\nQuestion ::: Which one of the following could be true if one of the families owned both the granary and the inn?\nis_valid(ForAll([b:buildings], owned(Trents, b) == owned(Yandells, b))) ::: (A)\nis_valid(ForAll([b:buildings], owned(Yandells, b) == owned(Williamses, b))) ::: (B)\nis_valid(ForAll([b:buildings], owned(Yandells, b) == owned(Trents, b))) ::: (C)\nis_valid(ForAll([b:buildings], owned(Williamses, b) == owned(Trents, b))) ::: (D)\nis_valid(ForAll([b:buildings], owned(Trents, b) == owned(Yandells, b))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_3_18",
    "context": "During the seventeenth century, three families—the Trents, the Williamses, and the Yandells—owned the five buildings that constituted the center of their village—the forge, the granary, the inn, the mill, and the stable. Each family owned at least one of the buildings and each building was owned by exactly one of the families. The historical evidence establishes the following about the ownership of the buildings: The Williamses owned more of the buildings than the Yandells owned. Neither the inn nor the mill belonged to the owner of the forge. Either the Trents owned the stable or the Yandells owned the inn, or both.",
    "question": "If the Trents owned exactly one of the buildings, which one of the following is a complete and accurate list of the buildings any one of which could be the building that the Trents owned?",
    "answer": "E",
    "options": [
      "A) the forge",
      "B) the forge, the mill",
      "C) the inn, the stable",
      "D) the forge, the granary, the mill",
      "E) the forge, the mill, the stable"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nDuring the seventeenth century, three families—the Trents, the Williamses, and the Yandells—owned the five buildings that constituted the center of their village—the forge, the granary, the inn, the mill, and the stable. Each family owned at least one of the buildings and each building was owned by exactly one of the families. The historical evidence establishes the following about the ownership of the buildings: The Williamses owned more of the buildings than the Yandells owned. Neither the inn nor the mill belonged to the owner of the forge. Either the Trents owned the stable or the Yandells owned the inn, or both.\nQuestion:\nIf the Trents owned exactly one of the buildings, which one of the following is a complete and accurate list of the buildings any one of which could be the building that the Trents owned?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfamilies = EnumSort([Trents, Williamses, Yandells])\nbuildings = EnumSort([forge, granary, inn, mill, stable])\nowned = Function([families, buildings] -> [bool])\n\n# Constraints\nForAll([f:families], Count([b:buildings], owned(f, b)) >= 1) ::: each family owns at least one building\nAnd(owned(Williamses, forge), Count([t:families], And(t != Williamses, owned(t, forge))) == 2) ::: The Williamses owned more of the buildings than the Yandells owned\nImplies(owned(Trents, stable), Or(owned(Yandells, inn), owned(Yandells, mill))) ::: Either the Trents owned the stable or the Yandells owned the inn or the Yandells owned the mill\n\n# Options\nQuestion ::: Which one of the following is a complete and accurate list of the buildings any one of which could be the building that the Trents owned?\nis_sat(ForAll([b:buildings], owned(Trents, b) == (b == stable))) ::: (A)\nis_sat(ForAll([b:buildings], owned(Trents, b) == (b == inn))) ::: (B)\nis_sat(ForAll([b:buildings], owned(Trents, b) == (b == mill))) ::: (C)\nis_sat(ForAll([b:buildings], owned(Trents, b) == (b == forge))) ::: (D)\nis_sat(ForAll([b:buildings], owned(Trents, b) == (b == granary))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_4_19",
    "context": "A florist is filling a customer's order for three bouquets—bouquet 1, bouquet 2, and bouquet 3. Each of the bouquets is to be composed of one or more of five kinds of flowers—lilies, peonies, roses, snapdragons, and tulips—subject to the following conditions: Bouquets 1 and 3 cannot have any kind of flower in common. Bouquets 2 and 3 must have exactly two kinds of flowers in common. Bouquet 3 must have snapdragons. If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons. If a bouquet has tulips, that bouquet must also have peonies.",
    "question": "Which one of the following could be a complete and accurate list of the kinds of flowers in each of the bouquets?",
    "answer": "A",
    "options": [
      "A) bouquet 1: lilies, roses bouquet 2: peonies, roses, tulips bouquet 3: peonies, snapdragons, tulips",
      "B) bouquet 1: peonies, roses bouquet 2: peonies, snapdragons bouquet 3: peonies, snapdragons, tulips",
      "C) bouquet 1: peonies, tulips bouquet 2: roses, snapdragons, tulips bouquet 3: roses, snapdragons",
      "D) bouquet 1: roses bouquet 2: peonies, snapdragons bouquet 3: lilies, peonies, snapdragons",
      "E) bouquet 1: snapdragons bouquet 2: lilies, roses bouquet 3: lilies, roses"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA florist is filling a customer's order for three bouquets—bouquet 1, bouquet 2, and bouquet 3. Each of the bouquets is to be composed of one or more of five kinds of flowers—lilies, peonies, roses, snapdragons, and tulips—subject to the following conditions: Bouquets 1 and 3 cannot have any kind of flower in common. Bouquets 2 and 3 must have exactly two kinds of flowers in common. Bouquet 3 must have snapdragons. If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons. If a bouquet has tulips, that bouquet must also have peonies.\nQuestion:\nWhich one of the following could be a complete and accurate list of the kinds of flowers in each of the bouquets?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nbouquets = EnumSort([bouquet_1, bouquet_2, bouquet_3])\nflowers = EnumSort([lilies, peonies, roses, snapdragons, tulips])\n\n# Constraints\nForAll([b:bouquets], Count([f:flowers], b.flowers == f) >= 1) ::: each bouquet contains at least one kind of flower\nAnd(bouquet_1.flowers != bouquet_2.flowers, bouquet_1.flowers != bouquet_3.flowers) ::: Bouquets 1 and 3 cannot have any kind of flower in common\nAnd(bouquet_2.flowers == bouquet_3.flowers, Count([f:flowers], bouquet_2.flowers == f) == 2) ::: Bouquets 2 and 3 must have exactly two kinds of flowers in common\nAnd(bouquet_3.flowers == [snapdragons], Not(bouquet_3.flowers == [lilies, roses])) ::: Bouquet 3 must have snapdragons\nForAll([b:bouquets], Implies(b.flowers == [lilies, roses], b.flowers == [tulips, peonies])) ::: If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the kinds of flowers in each of the bouquets?\nis_valid(ForAll([b:bouquets], b.flowers == [lilies, roses, tulips, peonies, snapdragons])) ::: (A)\nis_valid(ForAll([b:bouquets], b.flowers == [lilies, roses, peonies, snapdragons, tulips])) ::: (B)\nis_valid(ForAll([b:bouquets], b.flowers == [lilies, roses, tulips, peonies, snapdragons])) ::: (C)\nis_valid(ForAll([b:bouquets], b.flowers == [lilies, roses, tulips, snapdragons, peonies])) ::: (D)\nis_valid(ForAll([b:bouquets], b.flowers == [lilies, roses, tulips, snapdragons, peonies, roses])) ::: (E)\n\n------\n\nNote: The `is_valid` function is used to check whether a given list of flowers is consistent with the constraints of the problem. If the list is consistent, the function returns `True`, otherwise it returns `False`."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_4_20",
    "context": "A florist is filling a customer's order for three bouquets—bouquet 1, bouquet 2, and bouquet 3. Each of the bouquets is to be composed of one or more of five kinds of flowers—lilies, peonies, roses, snapdragons, and tulips—subject to the following conditions: Bouquets 1 and 3 cannot have any kind of flower in common. Bouquets 2 and 3 must have exactly two kinds of flowers in common. Bouquet 3 must have snapdragons. If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons. If a bouquet has tulips, that bouquet must also have peonies.",
    "question": "If lilies are in bouquet 1, which one of the following must",
    "answer": "B",
    "options": [
      "A) Lilies are in bouquet 2.",
      "B) Peonies are in bouquet 3.",
      "C) Roses are in bouquet 2.",
      "D) Tulips are in bouquet 2.",
      "E) Tulips are in bouquet 3."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA florist is filling a customer's order for three bouquets—bouquet 1, bouquet 2, and bouquet 3. Each of the bouquets is to be composed of one or more of five kinds of flowers—lilies, peonies, roses, snapdragons, and tulips—subject to the following conditions: Bouquets 1 and 3 cannot have any kind of flower in common. Bouquets 2 and 3 must have exactly two kinds of flowers in common. Bouquet 3 must have snapdragons. If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons. If a bouquet has tulips, that bouquet must also have peonies.\nQuestion:\nIf lilies are in bouquet 1, which one of the following must\nChoices:\n[[CHOICES]]\n###\n# Declarations\nbouquets = EnumSort([bouquet_1, bouquet_2, bouquet_3])\nflowers = EnumSort([lilies, peonies, roses, snapdragons, tulips])\n\n# Constraints\nForAll([b:bouquets], Count([f:flowers], b.contains(f)) >= 1) ::: each bouquet contains at least one kind of flower\nAnd(bouquet_1.contains(lilies), bouquet_1.contains(roses)) ::: if lilies are in bouquet 1, that bouquet must also have roses\nAnd(bouquet_2.contains(tulips), bouquet_2.contains(peonies)) ::: if tulips are in bouquet 2, that bouquet must also have peonies\nAnd(bouquet_3.contains(snapdragons), Not(bouquet_3.contains(lilies))) ::: snapdragons are in bouquet 3, and lilies are not\n\n# Options\nQuestion ::: Which one of the following must be true if lilies are in bouquet 1?\nis_valid(ForAll([b:bouquets], And(b.contains(lilies), b.contains(roses)))) ::: (A)\nis_valid(ForAll([b:bouquets], And(b.contains(tulips), b.contains(peonies)))) ::: (B)\nis_valid(ForAll([b:bouquets], And(b.contains(snapdragons), Not(b.contains(lilies))))) ::: (C)\nis_valid(ForAll([b:bouquets], And(b.contains(lilies), Not(b.contains(snapdragons))))) ::: (D)\nis_valid(ForAll([b:bouquets], And(b.contains(peonies), Not(b.contains(tulips))))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual problem and question may vary based on the specific requirements."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_4_21",
    "context": "A florist is filling a customer's order for three bouquets—bouquet 1, bouquet 2, and bouquet 3. Each of the bouquets is to be composed of one or more of five kinds of flowers—lilies, peonies, roses, snapdragons, and tulips—subject to the following conditions: Bouquets 1 and 3 cannot have any kind of flower in common. Bouquets 2 and 3 must have exactly two kinds of flowers in common. Bouquet 3 must have snapdragons. If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons. If a bouquet has tulips, that bouquet must also have peonies.",
    "question": "If tulips are in bouquet 1, which one of the following could be a complete and accurate list of the kinds of flowers in bouquet 2?",
    "answer": "E",
    "options": [
      "A) peonies, tulips",
      "B) peonies, snapdragons",
      "C) peonies, snapdragons, tulips",
      "D) peonies, roses, tulips",
      "E) peonies, roses, snapdragons, tulips"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA florist is filling a customer's order for three bouquets—bouquet 1, bouquet 2, and bouquet 3. Each of the bouquets is to be composed of one or more of five kinds of flowers—lilies, peonies, roses, snapdragons, and tulips—subject to the following conditions: Bouquets 1 and 3 cannot have any kind of flower in common. Bouquets 2 and 3 must have exactly two kinds of flowers in common. Bouquet 3 must have snapdragons. If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons. If a bouquet has tulips, that bouquet must also have peonies.\nQuestion:\nIf tulips are in bouquet 1, which one of the following could be a complete and accurate list of the kinds of flowers in bouquet 2?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nbouquets = EnumSort([bouquet_1, bouquet_2, bouquet_3])\nflowers = EnumSort([lilies, peonies, roses, snapdragons, tulips])\n\n# Constraints\nForAll([b:bouquets], Count([f:flowers], b.contains(f)) >= 1) ::: each bouquet contains at least one kind of flower\nAnd(bouquet_1.contains(tulips), Not(bouquet_1.contains(snapdragons))) ::: if tulips are in bouquet 1, that bouquet cannot have snapdragons\nAnd(bouquet_2.contains(lilies, roses), Exactly(2, bouquet_2.contains(flowers))) ::: bouquet 2 must have exactly two kinds of flowers in common\nAnd(bouquet_3.contains(snapdragons), Not(bouquet_3.contains(lilies, roses, tulips))) ::: snapdragons are in bouquet 3, and that bouquet cannot have lilies, roses, or tulips\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the kinds of flowers in bouquet 2?\nis_valid(ForAll([f:flowers], bouquet_2.contains(f) == [tulips, roses])) ::: (A)\nis_valid(ForAll([f:flowers], bouquet_2.contains(f) == [tulips, peonies])) ::: (B)\nis_valid(ForAll([f:flowers], bouquet_2.contains(f) == [tulips, roses, peonies])) ::: (C)\nis_valid(ForAll([f:flowers], bouquet_2.contains(f) == [snapdragons, roses])) ::: (D)\nis_valid(ForAll([f:flowers], bouquet_2.contains(f) == [snapdragons, peonies])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem description and question."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_4_22",
    "context": "A florist is filling a customer's order for three bouquets—bouquet 1, bouquet 2, and bouquet 3. Each of the bouquets is to be composed of one or more of five kinds of flowers—lilies, peonies, roses, snapdragons, and tulips—subject to the following conditions: Bouquets 1 and 3 cannot have any kind of flower in common. Bouquets 2 and 3 must have exactly two kinds of flowers in common. Bouquet 3 must have snapdragons. If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons. If a bouquet has tulips, that bouquet must also have peonies.",
    "question": "Which one of the following CANNOT be a complete and accurate list of the kinds of flowers in bouquet 2?",
    "answer": "A",
    "options": [
      "A) lilies, roses",
      "B) peonies, tulips",
      "C) peonies, roses, snapdragons",
      "D) peonies, roses, tulips",
      "E) peonies, roses, snapdragons, tulips"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA florist is filling a customer's order for three bouquets—bouquet 1, bouquet 2, and bouquet 3. Each of the bouquets is to be composed of one or more of five kinds of flowers—lilies, peonies, roses, snapdragons, and tulips—subject to the following conditions: Bouquets 1 and 3 cannot have any kind of flower in common. Bouquets 2 and 3 must have exactly two kinds of flowers in common. Bouquet 3 must have snapdragons. If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons. If a bouquet has tulips, that bouquet must also have peonies.\nQuestion:\nWhich one of the following CANNOT be a complete and accurate list of the kinds of flowers in bouquet 2?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nbouquets = EnumSort([bouquet_1, bouquet_2, bouquet_3])\nflowers = EnumSort([lilies, peonies, roses, snapdragons, tulips])\n\n# Constraints\nForAll([b:bouquets], Count([f:flowers], b.flowers == f) >= 1) ::: each bouquet contains at least one kind of flower\nAnd(bouquet_1.flowers != bouquet_2.flowers, Count([f:flowers], And(bouquet_1.flowers == f, bouquet_2.flowers == f))) == 2 ::: Bouquets 1 and 3 cannot have any kind of flower in common\nAnd(bouquet_2.flowers != bouquet_3.flowers, Count([f:flowers], And(bouquet_2.flowers == f, bouquet_3.flowers == f))) == 2 ::: Bouquets 2 and 3 must have exactly two kinds of flowers in common\nAnd(bouquet_3.flowers == [tulips, snapdragons], Count([f:flowers], bouquet_3.flowers == f) >= 1) ::: Bouquet 3 must have snapdragons\nForAll([b:bouquets], Implies(b.flowers.lilies, b.flowers.roses)) ::: If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons\nForAll([b:bouquets], Implies(b.flowers.tulips, b.flowers.peonies)) ::: If a bouquet has tulips, that bouquet must also have peonies\n\n# Options\nQuestion ::: Which one of the following CANNOT be a complete and accurate list of the kinds of flowers in bouquet 2?\nis_valid(Exists([f:flowers], bouquet_2.flowers == f)) ::: (A)\nis_valid(Exists([f:flowers], bouquet_2.flowers == [lilies, roses])) ::: (B)\nis_valid(Exists([f:flowers], bouquet_2.flowers == [tulips, peonies])) ::: (C)\nis_valid(Exists([f:flowers], bouquet_2.flowers == [snapdragons, roses])) ::: (D)\nis_valid(Exists([f:flowers], bouquet_2.flowers == [tulips, snapdragons])) ::: (E)\n\n------\n\nNote: The `is_valid` function checks whether the given list of flowers is a complete and accurate list of the kinds of flowers in the given bouquet, based on the constraints given in the problem."
    ]
  },
  {
    "id": "ar_lsat_201409_3-G_4_23",
    "context": "A florist is filling a customer's order for three bouquets—bouquet 1, bouquet 2, and bouquet 3. Each of the bouquets is to be composed of one or more of five kinds of flowers—lilies, peonies, roses, snapdragons, and tulips—subject to the following conditions: Bouquets 1 and 3 cannot have any kind of flower in common. Bouquets 2 and 3 must have exactly two kinds of flowers in common. Bouquet 3 must have snapdragons. If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons. If a bouquet has tulips, that bouquet must also have peonies.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "C",
    "options": [
      "A) Lilies and roses are the only kinds of flowers in bouquet 1.",
      "B) Peonies and tulips are the only kinds of flowers in bouquet 1.",
      "C) Lilies, peonies, and roses are the only kinds of flowers in bouquet 2.",
      "D) Peonies, roses, and snapdragons are the only kinds of flowers in bouquet 2.",
      "E) Peonies, snapdragons, and tulips are the only kinds of flowers in bouquet 3."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA florist is filling a customer's order for three bouquets—bouquet 1, bouquet 2, and bouquet 3. Each of the bouquets is to be composed of one or more of five kinds of flowers—lilies, peonies, roses, snapdragons, and tulips—subject to the following conditions: Bouquets 1 and 3 cannot have any kind of flower in common. Bouquets 2 and 3 must have exactly two kinds of flowers in common. Bouquet 3 must have snapdragons. If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons. If a bouquet has tulips, that bouquet must also have peonies.\nQuestion:\nWhich one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nbouquets = EnumSort([bouquet_1, bouquet_2, bouquet_3])\nflowers = EnumSort([lilies, peonies, roses, snapdragons, tulips])\nbouquet_components = Function([bouquets, flowers] -> [set])\n\n# Constraints\nForAll([b:bouquets], Count([f:flowers], bouquet_components(b) == f)) ::: each bouquet is composed of one or more of the five kinds of flowers\nAnd(bouquet_components(bouquet_1) != bouquet_components(bouquet_2)) ::: Bouquets 1 and 2 cannot have any kind of flower in common\nAnd(bouquet_components(bouquet_2) != bouquet_components(bouquet_3)) ::: Bouquets 2 and 3 must have exactly two kinds of flowers in common\nAnd(bouquet_components(bouquet_3) == set([snapdragons])) ::: Bouquet 3 must have snapdragons\nForAll([b:bouquets], Implies(bouquet_components(b) == set([lilies, roses]), bouquet_components(b) == set([peonies, roses]))) ::: If a bouquet has lilies, that bouquet must also have roses but cannot have snapdragons\nForAll([b:bouquets], Implies(bouquet_components(b) == set([tulips]), bouquet_components(b) == set([peonies]))) ::: If a bouquet has tulips, that bouquet must also have peonies\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_valid(Exists([b:bouquets], bouquet_components(b) == set([lilies, roses, peonies]))) ::: (A)\nis_valid(Exists([b:bouquets], bouquet_components(b) == set([tulips, snapdragons]))) ::: (B)\nis_valid(Exists([b:bouquets], bouquet_components(b) == set([snapdragons, peonies]))) ::: (C)\nis_valid(Exists([b:bouquets], bouquet_components(b) == set([lilies, roses, snapdragons]))) ::: (D)\nis_valid(Exists([b:bouquets], bouquet_components(b) == set([tulips, peonies]))) ::: (E)\n\n------\n\nNote: The `is_valid` function is used to check whether a given option is valid, i.e., whether it satisfies the constraints of the problem. The `ForAll` and `Exists` predicates are used to define the constraints and options, respectively."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_1_1",
    "context": "A corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.",
    "question": "Which one of the following is an allowable distribution of bonuses to the seven employees?",
    "answer": "C",
    "options": [
      "A) [Finance] Kimura: $1,000; Lopez: $5,000; Meng: $5,000; Peterson: $1,000 [Graphics] Vaughan: $3,000; Xavier: $3,000; Zane: $3,000",
      "B) [Finance] Kimura: $1,000; Lopez: $5,000; Meng: $5,000; Peterson: $3,000 [Graphics] Vaughan: $3,000; Xavier: $5,000; Zane: $1,000",
      "C) [Finance] Kimura: $1,000; Lopez: $5,000; Meng: $5,000; Peterson: $3,000 [Graphics] Vaughan: $3,000; Xavier: $5,000; Zane: $3,000",
      "D) [Finance] Kimura: $3,000; Lopez: $5,000; Meng: $3,000; Peterson: $1,000 [Graphics] Vaughan: $3,000; Xavier: $5,000; Zane: $3,000",
      "E) [Finance] Kimura: $3,000; Lopez: $5,000; Meng: $5,000; Peterson: $1,000 [Graphics] Vaughan: $1,000; Xavier: $5,000; Zane: $3,000"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.\nQuestion:\nWhich one of the following is an allowable distribution of bonuses to the seven employees?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nemployees = EnumSort([Kimura, Lopez, Meng, Peterson, Vaughan, Xavier, Zane])\ndepartments = EnumSort([Finance, Graphics])\nbonus_amounts = EnumSort([$1000, $3000, $5000])\nbonus = Function([employees, departments] -> [bonus_amounts])\n\n# Constraints\nForAll([e:employees], Count([d:departments], e in d) >= 1) ::: each employee works in at least one department\nAnd(Count([d:departments], e in d, bonus(e, d) == $1000), Count([d:departments], e in d, bonus(e, d) == $3000) > 1) ::: No one in the Graphics department receives a $1,000 bonus\nForAll([e:employees], Implies(bonus(e, Finance) > bonus(e, Graphics), e was rated Highly Effective)) ::: Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective\nCount([e:employees], bonus(e, Finance) == $5000) == 3 ::: Lopez, Meng, and Xavier were rated Highly Effective\n\n# Options\nQuestion ::: Which one of the following is an allowable distribution of bonuses to the seven employees?\nis_valid(ForAll([e:employees], bonus(e, Finance) == $3000)) ::: (A)\nis_valid(ForAll([e:employees], bonus(e, Graphics) == $5000)) ::: (B)\nis_valid(ForAll([e:employees], bonus(e, Finance) == $1000) && ForAll([e:employees], bonus(e, Graphics) == $3000)) ::: (C)\nis_valid(ForAll([e:employees], bonus(e, Finance) == $5000) && ForAll([e:employees], bonus(e, Graphics) == $1000)) ::: (D)\nis_valid(ForAll([e:employees], bonus(e, Finance) == $5000) && ForAll([e:employees], bonus(e, Graphics) == $3000)) ::: (E)\n\n------\n\nNote: The `is_valid` function is used to check whether a given distribution of bonuses is allowable according to the constraints and options provided. If the distribution is allowable, the `is_valid` function returns `True`, otherwise it returns `False`."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_1_2",
    "context": "A corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.",
    "question": "If Lopez does not receive the same bonus as Meng, which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) Kimura receives a $3,000 bonus.",
      "B) Lopez receives a $3,000 bonus.",
      "C) Peterson receives a $3,000 bonus.",
      "D) Kimura receives the same bonus as Vaughan.",
      "E) Peterson receives a larger bonus than Kimura."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.\nQuestion:\nIf Lopez does not receive the same bonus as Meng, which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Kimura, Lopez, Meng, Peterson, Vaughan, Xavier, Zane])\ndepartments = EnumSort([Finance, Graphics])\nbonuses = EnumSort([$1000, $3000, $5000])\nrated = Function([people, departments] -> [bool])\n\n# Constraints\nForAll([p:people], Count([d:departments], p in d) >= 1) ::: each person works in at least one department\nAnd(rated(Lopez), Not(rated(Meng))) ::: Lopez does not receive the same bonus as Meng\nForAll([p:people], Implies(rated(p), Not(rated(p, departments[1])))) ::: only Lopez, Meng, and Xavier were rated Highly Effective\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_valid(Exists([p:people], rated(p) == $3000)) ::: (A)\nis_valid(Exists([p:people], rated(p) == $5000)) ::: (B)\nis_valid(Exists([p:people], rated(p) == $1000)) ::: (C)\nis_valid(Exists([p:people], rated(p) == $3000, rated(Meng) == $5000)) ::: (D)\nis_valid(Exists([p:people], rated(p) == $5000, rated(Meng) == $3000)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_1_3",
    "context": "A corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.",
    "question": "If only one of the employees receives a $1,000 bonus, which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) Meng receives a $5,000 bonus.",
      "B) Peterson receives a $3,000 bonus.",
      "C) Meng receives a $3,000 bonus.",
      "D) The employee who receives a $1,000 bonus is Peterson.",
      "E) The employee who receives a $1,000 bonus is Kimura."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.\nQuestion:\nIf only one of the employees receives a $1,000 bonus, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nemployees = EnumSort([Kimura, Lopez, Meng, Peterson, Vaughan, Xavier, Zane])\nbonus = EnumSort([$1000, $3000, $5000])\nrating = EnumSort([HighlyEffective, NotHighlyEffective])\nbonus_received = Function([employee:employees, bonus:bonus] -> [rating(employee) == HighlyEffective])\n\n# Constraints\nForAll([e:employees], Count([b:bonus], e.bonus == b) >= 1) ::: each employee receives a bonus\nAnd(Count([b:bonus], e.bonus == $1000) == 0, e.rating == HighlyEffective) ::: No one in the Graphics department receives a $1,000 bonus\nForAll([e:employees], Implies(e.rating == HighlyEffective, e.bonus > Count([f:employees], f.rating == HighlyEffective, f.bonus))) ::: Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective\nCount([e:employees], e.rating == HighlyEffective) == 3 ::: Lopez, Meng, and Xavier were rated Highly Effective\n\n# Options\nQuestion ::: Which one of the following must be true if only one of the employees receives a $1,000 bonus?\nis_valid(ForAll([e:employees], Implies(e.bonus == $1000, e.rating == NotHighlyEffective))) ::: (A)\nis_valid(ForAll([e:employees], Implies(e.bonus == $1000, e.rating == HighlyEffective))) ::: (B)\nis_valid(ForAll([e:employees], Implies(e.bonus == $1000, e.rating == NotHighlyEffective))) ::: (C)\nis_valid(ForAll([e:employees], Implies(e.bonus == $1000, e.rating == HighlyEffective))) ::: (D)\nis_valid(ForAll([e:employees], Implies(e.bonus == $1000, e.rating == NotHighlyEffective))) ::: (E)\n\n------\n\nNote: The `is_valid` function is used to check whether a given formula is valid (i.e., whether it is a logical consequence of the given constraints). If the formula is valid, the corresponding choice is correct. If the formula is not valid, the corresponding choice is incorrect."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_1_4",
    "context": "A corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.",
    "question": "Which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) At least one of the employees receives a $1,000 bonus.",
      "B) At least three of the employees receives a $3,000 bonuses.",
      "C) At most three of the employees receives a $3,000 bonuses.",
      "D) At least two of the employees receives a $5,000 bonuses.",
      "E) At most three of the employees receives a $5,000 bonuses."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.\nQuestion:\nWhich one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Kimura, Lopez, Meng, Peterson, Vaughan, Xavier, Zane])\ndepartments = EnumSort([Finance, Graphics])\nbonuses = EnumSort([$1000, $3000, $5000])\nrated = Function([people, departments] -> [bool])\n\n# Constraints\nForAll([p:people], Count([d:departments], p in d) >= 1) ::: each person works in at least one department\nAnd(rated(p, Finance) -> rated(p, Graphics)) ::: if an employee was rated Highly Effective in the Finance department, then they were not rated Highly Effective in the Graphics department\nForAll([p:people], Implies(rated(p, Finance), Not(rated(p, Graphics)))) ::: only Lopez, Meng, and Xavier were rated Highly Effective\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(Exists([p:people], rated(p, Finance) == $3000)) ::: (A)\nis_valid(Exists([p:people], rated(p, Graphics) == $5000)) ::: (B)\nis_valid(Exists([p:people], rated(p, Finance) == $5000)) ::: (C)\nis_valid(Exists([p:people], rated(p, Graphics) == $3000)) ::: (D)\nis_valid(Exists([p:people], rated(p, Finance) == $1000)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_1_5",
    "context": "A corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.",
    "question": "If exactly two of the employees receive $5,000 bonuses, which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Lopez receives a $3,000 bonus.",
      "B) Meng receives a $3,000 bonus.",
      "C) Meng is one of the employees who receives a $5,000 bonus.",
      "D) Peterson receives a $1,000 bonus.",
      "E) Peterson receives a $3,000 bonus."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.\nQuestion:\nIf exactly two of the employees receive $5,000 bonuses, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nemployees = EnumSort([Kimura, Lopez, Meng, Peterson, Vaughan, Xavier, Zane])\nbonus_amounts = EnumSort([$1000, $3000, $5000])\nbonus_ratings = Function([employees] -> [bool])\n\n# Constraints\nForAll([e:employees], Count([b:bonus_amounts], e.bonus == b) >= 1) ::: each employee receives a bonus of at least one of the following amounts\nAnd(bonus_ratings(Graphics), Count([e:employees], And(e in Graphics, e.bonus != $1000)) == 0) ::: No one in the Graphics department receives a $1,000 bonus\nForAll([e:employees], Implies(bonus_ratings(e), Not(bonus_ratings(e.department)) if e.department == Graphics)) ::: Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective\nCount([e:employees], And(bonus_ratings(e), e.bonus == $5000)) >= 3 ::: Exactly two of the employees receive $5,000 bonuses\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(ForAll([e:employees], And(bonus_ratings(e), e.bonus == $5000))) ::: (A)\nis_valid(ForAll([e:employees], And(bonus_ratings(e), e.bonus == $3000))) ::: (B)\nis_valid(ForAll([e:employees], And(bonus_ratings(e), e.bonus == $1000))) ::: (C)\nis_valid(ForAll([e:employees], And(bonus_ratings(e), e.bonus == $5000, e in Graphics))) ::: (D)\nis_valid(ForAll([e:employees], And(bonus_ratings(e), e.bonus == $5000, e.department == Graphics))) ::: (E)\n\n------\n\nNote: The `is_valid` function is a built-in function in the logic programming language, which returns `True` if the given formula is valid (i.e., satisfies all the constraints) and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_1_6",
    "context": "A corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.",
    "question": "Any of the following could be true of the seven employees EXCEPT:",
    "answer": "B",
    "options": [
      "A) The same number receive $1,000 bonuses as receive $3,000 bonuses.",
      "B) More receive $1,000 bonuses than receive $3,000 bonuses.",
      "C) The same number receive $1,000 bonuses as receive $5,000 bonuses.",
      "D) More receive $1,000 bonuses than receive $5,000 bonuses.",
      "E) More receive $3,000 bonuses than receive $5,000 bonuses."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA corporation's Human Resources department must determine annual bonuses for seven employees—Kimura, Lopez, Meng, and Peterson, who work in the Finance department; and Vaughan, Xavier, and Zane, who work in the Graphics department. Each employee will receive either a $1,000 bonus, a $3,000 bonus, or a $5,000 bonus, in accordance with the following: No one in the Graphics department receives a $1,000 bonus. Any employee who was rated Highly Effective receives a larger bonus than anyone in his or her department who was not rated Highly Effective. Only Lopez, Meng, and Xavier were rated Highly Effective.\nQuestion:\nAny of the following could be true of the seven employees EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\nemployees = EnumSort([Kimura, Lopez, Meng, Peterson, Vaughan, Xavier, Zane])\nbonuses = EnumSort([$1000, $3000, $5000])\nrated = Function([employees] -> [bool])\n\n# Constraints\nForAll([e:employees], Count([d:departments], e in d) >= 1) ::: each employee works in at least one department\nAnd(rated(Lopez), Count([e:employees], And(e != Lopez, rated(e))) >= 2) ::: Lopez and exactly two other employees were rated Highly Effective\nForAll([e:employees], Implies(rated(e), Not(rated(Vaughan)))) ::: Vaughan was not rated Highly Effective\nCount([e:employees], bonuses(e)) > Count([d:departments], bonuses(d)) ::: each employee in the Finance department receives a larger bonus than each department in the Graphics department\n\n# Options\nQuestion ::: Any of the following could be true of the seven employees EXCEPT:\nis_valid(Exists([e:employees], bonuses(e) == $1000)) ::: (A)\nis_valid(Exists([e:employees], bonuses(e) == $3000)) ::: (B)\nis_valid(Exists([e:employees], bonuses(e) == $5000)) ::: (C)\nis_valid(ForAll([e:employees], bonuses(e) == bonuses(Lopez))) ::: (D)\nis_valid(ForAll([e:employees], bonuses(e) == bonuses(Vaughan))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_2_7",
    "context": "A landscaper will plant exactly seven trees today—a hickory, a larch, a maple, an oak, a plum, a sycamore, and a walnut. Each tree must be planted on exactly one of three lots—1, 2, or 3—in conformity with the following requirements: The trees planted on one lot are the hickory, the oak, and exactly one other tree. The maple is not planted on the same lot as the walnut. Either the larch or the walnut, but not both, is planted on lot 1. Either the maple or the oak, but not both, is planted on lot 2. More trees are planted on lot 3 than on lot 1.",
    "question": "Which one of the following could be the list of the trees that the landscaper plants on each of the lots today?",
    "answer": "D",
    "options": [
      "A) lot 1: the larch, the maple lot 2: the hickory, the oak lot 3: the plum, the sycamore, the walnut",
      "B) lot 1: the larch, the maple lot 2: the hickory, the oak, the walnut lot 3: the plum, the sycamore",
      "C) lot 1: the maple lot 2: the hickory, the larch, the oak lot 3: the plum, the sycamore, the walnut",
      "D) lot 1: the sycamore, the walnut lot 2: the larch, the maple lot 3: the hickory, the oak, the plum",
      "E) lot 1: the walnut lot 2: the plum, the sycamore lot 3: the hickory, the maple, the oak"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA landscaper will plant exactly seven trees today—a hickory, a larch, a maple, an oak, a plum, a sycamore, and a walnut. Each tree must be planted on exactly one of three lots—1, 2, or 3—in conformity with the following requirements: The trees planted on one lot are the hickory, the oak, and exactly one other tree. The maple is not planted on the same lot as the walnut. Either the larch or the walnut, but not both, is planted on lot 1. Either the maple or the oak, but not both, is planted on lot 2. More trees are planted on lot 3 than on lot 1.\nQuestion:\nWhich one of the following could be the list of the trees that the landscaper plants on each of the lots today?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ntrees = EnumSort([hickory, larch, maple, oak, plum, sycamore, walnut])\nlots = EnumSort([1, 2, 3])\nplant = Function([trees, lots] -> [bool])\n\n# Constraints\nForAll([t:trees], Count([l:lots], plant(t, l)) >= 1) ::: each tree is planted on exactly one of the three lots\nAnd(plant(hickory, 1), plant(oak, 1) && plant(maple, 2)) ::: The hickory and oak are planted on the same lot, and the maple is planted on a different lot\nAnd(plant(maple, 1), plant(oak, 2) && plant(plum, 3)) ::: The maple is planted on lot 1, and the oak is planted on lot 2\nAnd(plant(plum, 1), plant(sycamore, 2) && plant(walnut, 3)) ::: The plum is planted on lot 1, and the sycamore is planted on lot 2\nOr(plant(larch, 1), plant(walnut, 2) && plant(sycamore, 3)) ::: Either the larch or the walnut is planted on lot 1, and the sycamore is planted on lot 3\n\n# Options\nQuestion ::: Which one of the following could be the list of the trees that the landscaper plants on each of the lots today?\nis_valid(ForAll([t:trees], plant(t, 1) == [hickory, oak, maple])) ::: (A)\nis_valid(ForAll([t:trees], plant(t, 1) == [hickory, oak, plum])) ::: (B)\nis_valid(ForAll([t:trees], plant(t, 1) == [hickory, oak, sycamore])) ::: (C)\nis_valid(ForAll([t:trees], plant(t, 1) == [hickory, walnut, sycamore])) ::: (D)\nis_valid(ForAll([t:trees], plant(t, 1) == [larch, oak, walnut])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_2_8",
    "context": "A landscaper will plant exactly seven trees today—a hickory, a larch, a maple, an oak, a plum, a sycamore, and a walnut. Each tree must be planted on exactly one of three lots—1, 2, or 3—in conformity with the following requirements: The trees planted on one lot are the hickory, the oak, and exactly one other tree. The maple is not planted on the same lot as the walnut. Either the larch or the walnut, but not both, is planted on lot 1. Either the maple or the oak, but not both, is planted on lot 2. More trees are planted on lot 3 than on lot 1.",
    "question": "If the hickory is planted on lot 2, then which one of the following trees must be planted on lot 3?",
    "answer": "B",
    "options": [
      "A) the larch",
      "B) the maple",
      "C) the plum",
      "D) the sycamore",
      "E) the walnut"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA landscaper will plant exactly seven trees today—a hickory, a larch, a maple, an oak, a plum, a sycamore, and a walnut. Each tree must be planted on exactly one of three lots—1, 2, or 3—in conformity with the following requirements: The trees planted on one lot are the hickory, the oak, and exactly one other tree. The maple is not planted on the same lot as the walnut. Either the larch or the walnut, but not both, is planted on lot 1. Either the maple or the oak, but not both, is planted on lot 2. More trees are planted on lot 3 than on lot 1.\nQuestion:\nIf the hickory is planted on lot 2, then which one of the following trees must be planted on lot 3?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ntrees = EnumSort([hickory, larch, maple, oak, plum, sycamore, walnut])\nlots = EnumSort([1, 2, 3])\nplant = Function([trees, lots] -> [bool])\n\n# Constraints\nForAll([t:trees], Count([l:lots], plant(t, l)) >= 1) ::: each tree is planted on exactly one of the three lots\nAnd(plant(hickory, 2), Count([t:trees], And(t != hickory, plant(t, 3))) == 2) ::: The hickory is planted on lot 2\nOr(plant(larch, 1), plant(walnut, 3)) ::: Either the larch or the walnut, but not both, is planted on lot 1\nOr(plant(maple, 2), plant(oak, 3)) ::: Either the maple or the oak, but not both, is planted on lot 2\nMore(t:trees, plant(t, 3)) ::: More trees are planted on lot 3 than on lot 1\n\n# Options\nQuestion ::: Which one of the following trees must be planted on lot 3 if the hickory is planted on lot 2?\nis_valid(Exists([t:trees], plant(t, 3) == maple)) ::: (A)\nis_valid(Exists([t:trees], plant(t, 3) == oak)) ::: (B)\nis_valid(Exists([t:trees], plant(t, 3) == plum)) ::: (C)\nis_valid(Exists([t:trees], plant(t, 3) == sycamore)) ::: (D)\nis_valid(Exists([t:trees], plant(t, 3) == walnut)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_2_9",
    "context": "A landscaper will plant exactly seven trees today—a hickory, a larch, a maple, an oak, a plum, a sycamore, and a walnut. Each tree must be planted on exactly one of three lots—1, 2, or 3—in conformity with the following requirements: The trees planted on one lot are the hickory, the oak, and exactly one other tree. The maple is not planted on the same lot as the walnut. Either the larch or the walnut, but not both, is planted on lot 1. Either the maple or the oak, but not both, is planted on lot 2. More trees are planted on lot 3 than on lot 1.",
    "question": "Which one of the following is a complete and accurate list of the trees any of which could be planted on lot 1?",
    "answer": "C",
    "options": [
      "A) the hickory, the plum, the sycamore, the walnut",
      "B) the hickory, the sycamore, the walnut",
      "C) the larch, the plum, the sycamore, the walnut",
      "D) the larch, the plum, the walnut",
      "E) the plum, the sycamore, the walnut"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA landscaper will plant exactly seven trees today—a hickory, a larch, a maple, an oak, a plum, a sycamore, and a walnut. Each tree must be planted on exactly one of three lots—1, 2, or 3—in conformity with the following requirements: The trees planted on one lot are the hickory, the oak, and exactly one other tree. The maple is not planted on the same lot as the walnut. Either the larch or the walnut, but not both, is planted on lot 1. Either the maple or the oak, but not both, is planted on lot 2. More trees are planted on lot 3 than on lot 1.\nQuestion:\nWhich one of the following is a complete and accurate list of the trees any of which could be planted on lot 1?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ntrees = EnumSort([hickory, larch, maple, oak, plum, sycamore, walnut])\nlots = EnumSort([1, 2, 3])\nplant = Function([trees, lots] -> [bool])\n\n# Constraints\nForAll([t:trees], Count([l:lots], plant(t, l)) >= 1) ::: each tree is planted on at least one of the three lots\nAnd(plant(hickory, 1), Count([t:trees], And(t != hickory, plant(t, 1))) == 2) ::: The hickory and exactly one other tree are planted on lot 1\nAnd(plant(oak, 2), Count([t:trees], And(t != oak, plant(t, 2))) == 1) ::: The oak is planted on lot 2\nForAll([l:lots], Implies(plant(walnut, l), Not(plant(maple, l)))) ::: The walnut is not planted on the same lot as the maple\nCount([t:trees], plant(t, 3)) > Count([t:trees], plant(t, 1)) ::: More trees are planted on lot 3 than on lot 1\n\n# Options\nQuestion ::: Which one of the following is a complete and accurate list of the trees any of which could be planted on lot 1?\nis_sat(ForAll([t:trees], plant(t, 1) == [hickory, maple, sycamore, walnut]))) ::: (A)\nis_sat(ForAll([t:trees], plant(t, 1) == [hickory, maple, walnut]))) ::: (B)\nis_sat(ForAll([t:trees], plant(t, 1) == [maple, oak, sycamore, walnut]))) ::: (C)\nis_sat(ForAll([t:trees], plant(t, 1) == [hickory, oak, walnut]))) ::: (D)\nis_sat(ForAll([t:trees], plant(t, 1) == [maple, sycamore, walnut]))) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, it returns `True` if the given formula is satisfiable (i.e., there exists an assignment of values to the variables that makes the formula true), and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_2_10",
    "context": "A landscaper will plant exactly seven trees today—a hickory, a larch, a maple, an oak, a plum, a sycamore, and a walnut. Each tree must be planted on exactly one of three lots—1, 2, or 3—in conformity with the following requirements: The trees planted on one lot are the hickory, the oak, and exactly one other tree. The maple is not planted on the same lot as the walnut. Either the larch or the walnut, but not both, is planted on lot 1. Either the maple or the oak, but not both, is planted on lot 2. More trees are planted on lot 3 than on lot 1.",
    "question": "If the walnut is planted on lot 3, then which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) The sycamore is planted on lot 1.",
      "B) The hickory is planted on lot 2.",
      "C) The larch is planted on lot 2.",
      "D) The plum is planted on lot 3.",
      "E) The sycamore is planted on lot 3."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA landscaper will plant exactly seven trees today—a hickory, a larch, a maple, an oak, a plum, a sycamore, and a walnut. Each tree must be planted on exactly one of three lots—1, 2, or 3—in conformity with the following requirements: The trees planted on one lot are the hickory, the oak, and exactly one other tree. The maple is not planted on the same lot as the walnut. Either the larch or the walnut, but not both, is planted on lot 1. Either the maple or the oak, but not both, is planted on lot 2. More trees are planted on lot 3 than on lot 1.\nQuestion:\nIf the walnut is planted on lot 3, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ntrees = EnumSort([hickory, larch, maple, oak, plum, sycamore, walnut])\nlots = EnumSort([1, 2, 3])\nplant = Function([trees, lots] -> [bool])\n\n# Constraints\nForAll([t:trees], Count([l:lots], plant(t, l)) >= 1) ::: each tree is planted on exactly one of the three lots\nAnd(plant(hickory, 1), plant(oak, 1) && plant(maple, 2)) ::: The trees planted on one lot are the hickory, the oak, and exactly one other tree\nAnd(plant(maple, 1), plant(walnut, 3)) ::: The maple is not planted on the same lot as the walnut\nOr(plant(larch, 1), plant(walnut, 3)) ::: Either the larch or the walnut, but not both, is planted on lot 1\nOr(plant(oak, 2), plant(maple, 2) && plant(walnut, 3)) ::: Either the oak or the maple, but not both, is planted on lot 2\nMore(plant(sycamore, 3), plant(walnut, 3)) ::: More trees are planted on lot 3 than on lot 1\n\n# Options\nQuestion ::: Which one of the following could be true if the walnut is planted on lot 3?\nis_valid(ForAll([t:trees], plant(t, 3) == true)) ::: (A)\nis_valid(ForAll([t:trees], plant(t, 1) == true)) ::: (B)\nis_valid(ForAll([t:trees], plant(t, 2) == true)) ::: (C)\nis_valid(ForAll([t:trees], plant(t, 3) == true)) ::: (D)\nis_valid(ForAll([t:trees], plant(t, 1) == true) && plant(walnut, 3)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_2_11",
    "context": "A landscaper will plant exactly seven trees today—a hickory, a larch, a maple, an oak, a plum, a sycamore, and a walnut. Each tree must be planted on exactly one of three lots—1, 2, or 3—in conformity with the following requirements: The trees planted on one lot are the hickory, the oak, and exactly one other tree. The maple is not planted on the same lot as the walnut. Either the larch or the walnut, but not both, is planted on lot 1. Either the maple or the oak, but not both, is planted on lot 2. More trees are planted on lot 3 than on lot 1.",
    "question": "Where each of the trees is planted is completely determined if which one of the following trees is planted on lot 2?",
    "answer": "A",
    "options": [
      "A) the walnut",
      "B) the sycamore",
      "C) the plum",
      "D) the maple",
      "E) the larch"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nA landscaper will plant exactly seven trees today—a hickory, a larch, a maple, an oak, a plum, a sycamore, and a walnut. Each tree must be planted on exactly one of three lots—1, 2, or 3—in conformity with the following requirements: The trees planted on one lot are the hickory, the oak, and exactly one other tree. The maple is not planted on the same lot as the walnut. Either the larch or the walnut, but not both, is planted on lot 1. Either the maple or the oak, but not both, is planted on lot 2. More trees are planted on lot 3 than on lot 1.\nQuestion:\nWhere each of the trees is planted is completely determined if which one of the following trees is planted on lot 2?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ntrees = EnumSort([hickory, larch, maple, oak, plum, sycamore, walnut])\nlots = EnumSort([1, 2, 3])\nplant = Function([trees, lots] -> [bool])\n\n# Constraints\nForAll([t:trees], Count([l:lots], plant(t, l)) >= 1) ::: each tree is planted on exactly one of the three lots\nAnd(plant(hickory, 1), Count([t:trees], And(t != hickory, plant(t, 1))) == 2) ::: The hickory is planted on one of the three lots, and exactly two other trees are planted on the same lot\nAnd(plant(oak, 2), Count([t:trees], And(t != oak, plant(t, 2))) == 1) ::: The oak is planted on lot 2, and exactly one other tree is planted on the same lot\nAnd(plant(maple, 3), Count([t:trees], And(t != maple, plant(t, 3))) > Count([t:trees], plant(t, 1))) ::: More trees are planted on lot 3 than on lot 1\nOr(plant(larch, 1) == plant(walnut, 1), plant(larch, 2) == plant(walnut, 2)) ::: Either the larch or the walnut, but not both, is planted on lot 1\nOr(plant(maple, 2) == plant(oak, 2), plant(maple, 3) == plant(oak, 3)) ::: Either the maple or the oak, but not both, is planted on lot 2\n\n# Options\nQuestion ::: Which one of the following trees is planted on lot 2?\nis_valid(Exists([t:trees], plant(t, 2))) ::: (A)\nis_valid(Exists([t:trees], plant(t, 1))) ::: (B)\nis_valid(Exists([t:trees], plant(t, 3))) ::: (C)\nis_valid(ForAll([t:trees], plant(t, 2) == plant(t, 1))) ::: (D)\nis_valid(ForAll([t:trees], plant(t, 2) == plant(t, 3))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_3_12",
    "context": "Seven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.",
    "question": "Which one of the following is an acceptable schedule for the librarians, listed in order from Monday through Saturday?",
    "answer": "A",
    "options": [
      "A) Flynn; Hill; Moore; Kitson; Zahn; Gomez and Leung",
      "B) Flynn; Moore; Hill; Leung; Kitson; Gomez and Zahn",
      "C) Hill; Kitson; Moore; Flynn; Gomez; Leung and Zahn",
      "D) Hill; Leung; Flynn; Moore; Zahn; Gomez and Kitson",
      "E) Leung; Flynn; Kitson; Moore; Hill; Gomez and Zahn"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSeven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.\nQuestion:\nWhich one of the following is an acceptable schedule for the librarians, listed in order from Monday through Saturday?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nlibrarians = EnumSort([Flynn, Gomez, Hill, Kitson, Leung, Moore, Zahn])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\nschedule = Function([librarians, days] -> [bool])\n\n# Constraints\nForAll([d:days], Count([l:librarians], schedule(l, d)) >= 1) ::: each librarian is on duty exactly one day\nAnd(schedule(Hill, Monday), schedule(Leung, Tuesday)) ::: Hill must be on desk duty earlier in the week than Leung\nAnd(schedule(Moore, Wednesday), schedule(Gomez, Thursday)) ::: Both Hill and Moore must be on desk duty earlier in the week than Gomez\nAnd(schedule(Flynn, Friday), schedule(Kitson, Saturday)) ::: Flynn must be on desk duty earlier in the week than both Kitson and Moore\nOr(schedule(Leung, Saturday), Not(schedule(Flynn, Saturday))) ::: Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn\n\n# Options\nQuestion ::: Which one of the following is an acceptable schedule for the librarians, listed in order from Monday through Saturday?\nis_sat(ForAll([d:days], schedule(Hill, d) == schedule(Leung, d))) ::: (A)\nis_sat(ForAll([d:days], schedule(Leung, d) == schedule(Flynn, d))) ::: (B)\nis_sat(ForAll([d:days], schedule(Kitson, d) == schedule(Moore, d))) ::: (C)\nis_sat(ForAll([d:days], schedule(Zahn, d) == schedule(Gomez, d))) ::: (D)\nis_sat(ForAll([d:days], schedule(Flynn, d) == schedule(Kitson, d))) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the logic programming language. It checks whether the given formula is satisfiable, i.e., whether there exists an assignment of values to the variables that makes the formula true."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_3_13",
    "context": "Seven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.",
    "question": "Which one of the following CANNOT be on desk duty on Tuesday?",
    "answer": "E",
    "options": [
      "A) Flynn",
      "B) Hill",
      "C) Kitson",
      "D) Moore",
      "E) Zahn"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSeven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.\nQuestion:\nWhich one of the following CANNOT be on desk duty on Tuesday?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nlibrarians = EnumSort([Flynn, Gomez, Hill, Kitson, Leung, Moore, Zahn])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\ndesk_duty = Function([librarians, days] -> [bool])\n\n# Constraints\nForAll([d:days], Count([l:librarians], desk_duty(l, d)) >= 1) ::: each librarian is on duty exactly one day\nAnd(desk_duty(Hill, Monday), desk_duty(Leung, Tuesday)) ::: Hill must be on desk duty earlier in the week than Leung\nAnd(desk_duty(Moore, Monday), desk_duty(Gomez, Tuesday)) ::: Both Hill and Moore must be on desk duty earlier in the week than Gomez\nForAll([d:days], Implies(desk_duty(Flynn, d), Not(desk_duty(Kitson, d)))) ::: Flynn must be on desk duty earlier in the week than Kitson\nForAll([d:days], Implies(desk_duty(Zahn, d), Not(desk_duty(Leung, d)))) ::: Zahn must be on desk duty earlier in the week than Leung\nIf(Not(desk_duty(Leung, Saturday)), desk_duty(Leung, Saturday)) ::: Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn\n\n# Options\nQuestion ::: Which one of the following CANNOT be on desk duty on Tuesday?\nis_valid(ForAll([d:days], desk_duty(Zahn, d) == False)) ::: (A)\nis_valid(ForAll([d:days], desk_duty(Hill, d) == False)) ::: (B)\nis_valid(ForAll([d:days], desk_duty(Kitson, d) == False)) ::: (C)\nis_valid(ForAll([d:days], desk_duty(Leung, d) == False)) ::: (D)\nis_valid(ForAll([d:days], desk_duty(Moore, d) == False)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_3_14",
    "context": "Seven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.",
    "question": "If Kitson is on desk duty earlier in the week than Moore, which one of the following CANNOT be true?",
    "answer": "B",
    "options": [
      "A) Flynn is on desk duty earlier in the week than Leung.",
      "B) Gomez is on desk duty earlier in the week than Kitson.",
      "C) Gomez is on desk duty earlier in the week than Zahn.",
      "D) Hill is on desk duty earlier in the week than Kitson.",
      "E) Zahn is on desk duty earlier in the week than Moore."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSeven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.\nQuestion:\nIf Kitson is on desk duty earlier in the week than Moore, which one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nlibrarians = EnumSort([Flynn, Gomez, Hill, Kitson, Leung, Moore, Zahn])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\ndesk_duty = Function([librarians, days] -> [bool])\n\n# Constraints\nForAll([d:days], Count([l:librarians], desk_duty(l, d)) >= 1) ::: each librarian is on duty exactly one day\nAnd(desk_duty(Hill, Monday), desk_duty(Leung, Monday)) ::: Hill must be on desk duty earlier in the week than Leung\nAnd(desk_duty(Moore, Tuesday), desk_duty(Gomez, Tuesday)) ::: Both Hill and Moore must be on desk duty earlier in the week than Gomez\nAnd(desk_duty(Flynn, Wednesday), desk_duty(Kitson, Wednesday)) ::: Flynn must be on desk duty earlier in the week than both Kitson and Moore\nAnd(desk_duty(Zahn, Saturday), desk_duty(Leung, Saturday)) ::: Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_valid(ForAll([d:days], desk_duty(Kitson, d) == desk_duty(Moore, d))) ::: (A)\nis_valid(ForAll([d:days], desk_duty(Kitson, d) == desk_duty(Flynn, d))) ::: (B)\nis_valid(ForAll([d:days], desk_duty(Kitson, d) == desk_duty(Leung, d))) ::: (C)\nis_valid(ForAll([d:days], desk_duty(Moore, d) == desk_duty(Flynn, d))) ::: (D)\nis_valid(ForAll([d:days], desk_duty(Leung, d) == desk_duty(Flynn, d))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_3_15",
    "context": "Seven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.",
    "question": "If Zahn is on desk duty on Thursday, which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) Flynn is on desk duty earlier in the week than Leung.",
      "B) Hill is on desk duty earlier in the week than Flynn.",
      "C) Hill is on desk duty earlier in the week than Moore.",
      "D) Hill is on desk duty earlier in the week than Zahn.",
      "E) Kitson is on desk duty earlier in the week than Moore."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSeven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.\nQuestion:\nIf Zahn is on desk duty on Thursday, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nlibrarians = EnumSort([Flynn, Gomez, Hill, Kitson, Leung, Moore, Zahn])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\ndesk_duty = Function([librarians, days] -> [bool])\n\n# Constraints\nForAll([d:days], Count([l:librarians], desk_duty(l, d)) >= 1) ::: each librarian is on duty exactly one day\nAnd(desk_duty(Hill, Monday), desk_duty(Leung, Tuesday)) ::: Hill must be on desk duty earlier in the week than Leung\nAnd(desk_duty(Moore, Wednesday), desk_duty(Gomez, Thursday)) ::: Both Hill and Moore must be on desk duty earlier in the week than Gomez\nForAll([d:days], Implies(desk_duty(Flynn, d), Not(desk_duty(Kitson, d)))) ::: Flynn must be on desk duty earlier in the week than Kitson\nForAll([d:days], Implies(desk_duty(Leung, d), Not(desk_duty(Zahn, d)))) ::: Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn\n\n# Options\nQuestion ::: Which one of the following must be true if Zahn is on desk duty on Thursday?\nis_valid(ForAll([d:days], desk_duty(Zahn, d) == True)) ::: (A)\nis_valid(ForAll([d:days], desk_duty(Zahn, d) == False)) ::: (B)\nis_valid(ForAll([d:days], desk_duty(Zahn, d) == (d == Thursday))) ::: (C)\nis_valid(ForAll([d:days], desk_duty(Zahn, d) == (d != Saturday))) ::: (D)\nis_valid(ForAll([d:days], desk_duty(Zahn, d) == (d == Wednesday))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_3_16",
    "context": "Seven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.",
    "question": "If Moore is on desk duty on Tuesday, which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) Hill is on desk duty on Thursday.",
      "B) Kitson is on desk duty on Thursday.",
      "C) Leung is on desk duty on Saturday.",
      "D) Zahn is on desk duty on Friday.",
      "E) Zahn is on desk duty on Saturday."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSeven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.\nQuestion:\nIf Moore is on desk duty on Tuesday, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nlibrarians = EnumSort([Flynn, Gomez, Hill, Kitson, Leung, Moore, Zahn])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\ndesk_duty = Function([librarians, days] -> [bool])\n\n# Constraints\nForAll([d:days], Count([l:librarians], desk_duty(l, d)) >= 1) ::: each librarian is on duty exactly one day\nAnd(desk_duty(Hill, Monday), desk_duty(Leung, Tuesday)) ::: Hill must be on desk duty earlier in the week than Leung\nAnd(desk_duty(Moore, Tuesday), desk_duty(Gomez, Wednesday)) ::: Both Hill and Moore must be on desk duty earlier in the week than Gomez\nAnd(desk_duty(Flynn, Thursday), desk_duty(Kitson, Friday)) ::: Flynn must be on desk duty earlier in the week than Kitson\nAnd(desk_duty(Zahn, Saturday), desk_duty(Leung, Saturday)) ::: Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn\n\n# Options\nQuestion ::: If Moore is on desk duty on Tuesday, which one of the following must be true?\nis_valid(ForAll([d:days], desk_duty(Moore, d) == True)) ::: (A)\nis_valid(ForAll([d:days], desk_duty(Moore, d) == False)) ::: (B)\nis_valid(ForAll([d:days], desk_duty(Moore, d) == desk_duty(Hill, d))) ::: (C)\nis_valid(ForAll([d:days], desk_duty(Moore, d) == desk_duty(Gomez, d))) ::: (D)\nis_valid(ForAll([d:days], desk_duty(Moore, d) == desk_duty(Flynn, d))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_3_17",
    "context": "Seven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.",
    "question": "If Flynn is on desk duty earlier in the week than Hill, which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Hill is on desk duty earlier in the week than Kitson.",
      "B) Hill is on desk duty earlier in the week than Zahn.",
      "C) Kitson is on desk duty earlier in the week than Moore.",
      "D) Moore is on desk duty earlier in the week than Leung.",
      "E) Moore is on desk duty earlier in the week than Zahn."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSeven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.\nQuestion:\nIf Flynn is on desk duty earlier in the week than Hill, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nlibrarians = EnumSort([Flynn, Gomez, Hill, Kitson, Leung, Moore, Zahn])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\ndesk_duty = Function([librarians, days] -> [bool])\n\n# Constraints\nForAll([d:days], Count([l:librarians], desk_duty(l, d)) >= 1) ::: each librarian is on duty exactly one day\nAnd(desk_duty(Hill, Monday), desk_duty(Leung, Tuesday)) ::: Hill must be on desk duty earlier in the week than Leung\nAnd(desk_duty(Moore, Wednesday), desk_duty(Gomez, Thursday)) ::: Both Hill and Moore must be on desk duty earlier in the week than Gomez\nForAll([d:days], Implies(desk_duty(Flynn, d), Not(desk_duty(Kitson, d)))) ::: Flynn must be on desk duty earlier in the week than Kitson\nForAll([d:days], Implies(desk_duty(Leung, d), Not(desk_duty(Zahn, d)))) ::: Leung must be on desk duty earlier in the week than Zahn\nIf desk_duty(Leung, Saturday), desk_duty(Flynn, Monday) ::: Leung must be on desk duty earlier in the week than Flynn\n\n# Options\nQuestion ::: Which one of the following must be true if Flynn is on desk duty earlier in the week than Hill?\nis_valid(ForAll([d:days], desk_duty(Flynn, d) == desk_duty(Hill, d))) ::: (A)\nis_valid(ForAll([d:days], desk_duty(Hill, d) == desk_duty(Flynn, d))) ::: (B)\nis_valid(ForAll([d:days], desk_duty(Flynn, d) == desk_duty(Kitson, d))) ::: (C)\nis_valid(ForAll([d:days], desk_duty(Kitson, d) == desk_duty(Flynn, d))) ::: (D)\nis_valid(ForAll([d:days], desk_duty(Flynn, d) == desk_duty(Zahn, d))) ::: (E)\n\n------\n\nPlease provide the code for each problem and question, and I will check if they are correct or not."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_3_18",
    "context": "Seven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.",
    "question": "Which one of the following, if substituted for the constraint that Flynn must be on desk duty earlier in the week than both Kitson and Moore, would have the same effect in determining the schedule for the librarians?",
    "answer": "C",
    "options": [
      "A) Flynn cannot be on desk duty on Thursday.",
      "B) Only Flynn or Hill can be on desk duty on Monday.",
      "C) Only Hill and Leung can be on desk duty earlier than Flynn.",
      "D) Flynn must be on desk duty earlier in the week than both Gomez and Kitson.",
      "E) Flynn must be on desk duty earlier in the week than both Moore and Zahn."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSeven librarians—Flynn, Gomez, Hill, Kitson, Leung, Moore, and Zahn—are being scheduled for desk duty for one week—Monday through Saturday. The librarians will be on duty exactly one day each. On each day except Saturday, there will be exactly one librarian on duty, with two on duty on Saturday, subject to the following constraints: Hill must be on desk duty earlier in the week than Leung. Both Hill and Moore must be on desk duty earlier in the week than Gomez. Flynn must be on desk duty earlier in the week than both Kitson and Moore. Kitson must be on desk duty earlier in the week than Zahn. Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn.\nQuestion:\nWhich one of the following, if substituted for the constraint that Flynn must be on desk duty earlier in the week than both Kitson and Moore, would have the same effect in determining the schedule for the librarians?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nlibrarians = EnumSort([Flynn, Gomez, Hill, Kitson, Leung, Moore, Zahn])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday, Saturday])\ndesk_duty = Function([librarians, days] -> [bool])\n\n# Constraints\nForAll([d:days], Count([l:librarians], desk_duty(l, d)) >= 1) ::: each librarian is on duty exactly one day\nAnd(desk_duty(Hill, Monday), desk_duty(Leung, Tuesday)) ::: Hill must be on desk duty earlier in the week than Leung\nAnd(desk_duty(Moore, Wednesday), desk_duty(Gomez, Thursday)) ::: Both Hill and Moore must be on desk duty earlier in the week than Gomez\nAnd(desk_duty(Flynn, Friday), desk_duty(Kitson, Saturday)) ::: Flynn must be on desk duty earlier in the week than both Kitson and Moore\nOr(desk_duty(Leung, Saturday), desk_duty(Flynn, Saturday)) ::: Unless Leung is on desk duty on Saturday, Leung must be on desk duty earlier in the week than Flynn\n\n# Options\nQuestion ::: Which one of the following, if substituted for the constraint that Flynn must be on desk duty earlier in the week than both Kitson and Moore, would have the same effect in determining the schedule for the librarians?\nis_sat(ForAll([d:days], desk_duty(Flynn, d) == desk_duty(Kitson, d))) ::: (A)\nis_sat(ForAll([d:days], desk_duty(Flynn, d) == desk_duty(Moore, d))) ::: (B)\nis_sat(ForAll([d:days], desk_duty(Flynn, d) == desk_duty(Hill, d))) ::: (C)\nis_sat(ForAll([d:days], desk_duty(Flynn, d) == desk_duty(Zahn, d))) ::: (D)\nis_sat(ForAll([d:days], desk_duty(Flynn, d) == desk_duty(Leung, d))) ::: (E)\n\n------\n\nPlease provide the code for each problem and question, and I will check if they are correct or not."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_4_19",
    "context": "Each issue of a business newsletter has five slots, numbered 1 through 5. The policy of the newsletter requires that there are at least three features per issue, with each feature completely occupying one or more of the slots. Each feature can be one of four types—finance, industry, marketing, or technology. Any slot not containing a feature contains a graphic. The newsletters policy further requires that each issue be structured as follows: Any feature occupying more than one slot must occupy consecutively numbered slots. If an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1. An issue can have at most one industry feature.",
    "question": "Which one of the following is an allowable structure for an issue of the newsletter?",
    "answer": "D",
    "options": [
      "A) slot 1: a finance feature; slot 2: an industry feature; slot 3: a second industry feature; slot 4: a graphic; slot 5: a graphic",
      "B) slot 1: a graphic; slot 2: a technology feature; slot 3: a second technology feature; slot 4: a graphic; slot 5: a third technology feature",
      "C) slots 1 and 2: a single industry feature; slots 3 and 4: a single marketing feature; slot 5: a finance feature",
      "D) slot 1: a technology feature; slots 2 and 3: a single industry feature; slot 4: a finance feature; slot 5: a graphic",
      "E) slot 1: a technology feature; slots 2 and 4: a single marketing feature; slot 3: an industry feature; slot 5: a graphic"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach issue of a business newsletter has five slots, numbered 1 through 5. The policy of the newsletter requires that there are at least three features per issue, with each feature completely occupying one or more of the slots. Each feature can be one of four types—finance, industry, marketing, or technology. Any slot not containing a feature contains a graphic. The newsletters policy further requires that each issue be structured as follows: Any feature occupying more than one slot must occupy consecutively numbered slots. If an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1. An issue can have at most one industry feature.\nQuestion:\nWhich one of the following is an allowable structure for an issue of the newsletter?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nslots = EnumSort([1, 2, 3, 4, 5])\nfeatures = EnumSort([finance, industry, marketing, technology])\noccupies = Function([slots, features] -> [bool])\n\n# Constraints\nForAll([s:slots], Count([f:features], occupies(s, f)) >= 3) ::: each issue has at least three features\nAnd(occupies(s, finance) -> (occupies(s, technology) or occupies(s, industry))) ::: if an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1\nOr(occupies(s, industry) -> (occupies(s, marketing) or occupies(s, technology))) ::: an issue can have at most one industry feature\n\n# Options\nQuestion ::: Which one of the following is an allowable structure for an issue of the newsletter?\nis_valid(Exists([s:slots], ForAll([f:features], occupies(s, f) == [finance, marketing, technology]))) ::: (A)\nis_valid(Exists([s:slots], ForAll([f:features], occupies(s, f) == [finance, industry, marketing]))) ::: (B)\nis_valid(Exists([s:slots], ForAll([f:features], occupies(s, f) == [finance, technology, marketing]))) ::: (C)\nis_valid(Exists([s:slots], ForAll([f:features], occupies(s, f) == [finance, industry, technology]))) ::: (D)\nis_valid(Exists([s:slots], ForAll([f:features], occupies(s, f) == [finance, marketing, technology]))) ::: (E)\n\n------\n\nNote: The above code is just an example, and you may need to adjust it according to the specific problem you are trying to solve."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_4_20",
    "context": "Each issue of a business newsletter has five slots, numbered 1 through 5. The policy of the newsletter requires that there are at least three features per issue, with each feature completely occupying one or more of the slots. Each feature can be one of four types—finance, industry, marketing, or technology. Any slot not containing a feature contains a graphic. The newsletters policy further requires that each issue be structured as follows: Any feature occupying more than one slot must occupy consecutively numbered slots. If an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1. An issue can have at most one industry feature.",
    "question": "If an issue of the newsletter has no technology feature and if there is a finance feature that occupies both slots 4 and 5, then which one of the following is required for that issue?",
    "answer": "A",
    "options": [
      "A) A finance feature occupies slot 1.",
      "B) A finance feature occupies slot 2 or slot 3 or both.",
      "C) A marketing feature occupies slot 2.",
      "D) An industry feature or a marketing feature occupies slot 2.",
      "E) An industry feature or a marketing feature occupies slot 3."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach issue of a business newsletter has five slots, numbered 1 through 5. The policy of the newsletter requires that there are at least three features per issue, with each feature completely occupying one or more of the slots. Each feature can be one of four types—finance, industry, marketing, or technology. Any slot not containing a feature contains a graphic. The newsletters policy further requires that each issue be structured as follows: Any feature occupying more than one slot must occupy consecutively numbered slots. If an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1. An issue can have at most one industry feature.\nQuestion:\nIf an issue of the newsletter has no technology feature and if there is a finance feature that occupies both slots 4 and 5, then which one of the following is required for that issue?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nnewsletter = EnumSort([1, 2, 3, 4, 5])\nslots = EnumSort([1, 2, 3, 4, 5])\nfeatures = EnumSort([finance, industry, marketing, technology])\noccupies = Function([slots, features] -> [bool])\n\n# Constraints\nForAll([s:slots], Count([f:features], occupies(s, f)) >= 3) ::: each issue has at least three features\nAnd(occupies(4, finance), Count([f:features], And(f != finance, occupies(f, 4))) == 1) ::: if an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1\nOr(occupies(4, industry), occupies(5, industry)) ::: an issue can have at most one industry feature\nForAll([f:features], Implies(occupies(5, f), Not(occupies(4, f)))) ::: if a feature occupies slot 5, then it does not occupy slot 4\n\n# Options\nQuestion ::: Which one of the following is required for that issue?\nis_valid(Exists([s:slots], ForAll([f:features], occupies(s, f) == (f == marketing)))) ::: (A)\nis_valid(Exists([s:slots], ForAll([f:features], occupies(s, f) == (f == technology)))) ::: (B)\nis_valid(Exists([s:slots], ForAll([f:features], occupies(s, f) == (f == industry)))) ::: (C)\nis_valid(Exists([s:slots], ForAll([f:features], occupies(s, f) == (f == finance)))) ::: (D)\nis_valid(Exists([s:slots], ForAll([f:features], occupies(s, f) == (f == marketing or f == technology)))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_4_21",
    "context": "Each issue of a business newsletter has five slots, numbered 1 through 5. The policy of the newsletter requires that there are at least three features per issue, with each feature completely occupying one or more of the slots. Each feature can be one of four types—finance, industry, marketing, or technology. Any slot not containing a feature contains a graphic. The newsletters policy further requires that each issue be structured as follows: Any feature occupying more than one slot must occupy consecutively numbered slots. If an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1. An issue can have at most one industry feature.",
    "question": "Which one of the following is NOT allowed for an issue of the newsletter?",
    "answer": "E",
    "options": [
      "A) There is exactly one industry feature, and it occupies slot 1.",
      "B) There is exactly one finance feature, and it occupies slot 2.",
      "C) There is exactly one technology feature, and it occupies slot 3.",
      "D) Each feature except the feature occupying slot 1 is either a finance feature or a marketing feature.",
      "E) Each feature except the feature occupying slot 5 is either an industry feature or a marketing feature."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach issue of a business newsletter has five slots, numbered 1 through 5. The policy of the newsletter requires that there are at least three features per issue, with each feature completely occupying one or more of the slots. Each feature can be one of four types—finance, industry, marketing, or technology. Any slot not containing a feature contains a graphic. The newsletters policy further requires that each issue be structured as follows: Any feature occupying more than one slot must occupy consecutively numbered slots. If an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1. An issue can have at most one industry feature.\nQuestion:\nWhich one of the following is NOT allowed for an issue of the newsletter?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfeatures = EnumSort([finance, industry, marketing, technology])\nslots = EnumSort([1, 2, 3, 4, 5])\nissue = Function([slots] -> [features])\n\n# Constraints\nForAll([s:slots], Count([f:features], And(issue(s) == f)) >= 3) ::: each issue has at least three features\nForAll([f:features], Implies(issue(s) == f, And(s[1] == f, s[2] == f))) ::: any feature occupying more than one slot must occupy consecutively numbered slots\nForAll([f:features], Implies(issue(s) == f, And(s[3] == f, s[4] == f))) ::: if an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1\nForAll([f:features], Implies(issue(s) == f, Not(And(s[4] == f, s[5] == f)))) ::: an issue can have at most one industry feature\n\n# Options\nQuestion ::: Which one of the following is NOT allowed for an issue of the newsletter?\nis_valid(Exists([s:slots], issue(s) == [finance, marketing, technology])) ::: (A)\nis_valid(Exists([s:slots], issue(s) == [industry, marketing, technology])) ::: (B)\nis_valid(Exists([s:slots], issue(s) == [finance, industry, technology])) ::: (C)\nis_valid(Exists([s:slots], issue(s) == [finance, marketing, industry])) ::: (D)\nis_valid(Exists([s:slots], issue(s) == [finance, marketing, technology, industry])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_4_22",
    "context": "Each issue of a business newsletter has five slots, numbered 1 through 5. The policy of the newsletter requires that there are at least three features per issue, with each feature completely occupying one or more of the slots. Each feature can be one of four types—finance, industry, marketing, or technology. Any slot not containing a feature contains a graphic. The newsletters policy further requires that each issue be structured as follows: Any feature occupying more than one slot must occupy consecutively numbered slots. If an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1. An issue can have at most one industry feature.",
    "question": "If, in a particular issue of the newsletter, slot 1 is occupied by the only industry feature in that issue, then which one of the following is required for that issue?",
    "answer": "D",
    "options": [
      "A) There is an industry feature that occupies slots 1 and 2, and only those slots.",
      "B) There is an industry feature that occupies slots 1, 2, and 3, and only those slots.",
      "C) There is a marketing feature that occupies slot 2 or slot 3 or both.",
      "D) There is a marketing feature that occupies one or more of slots 2, 3, and 4.",
      "E) There is a marketing feature that occupies slot 3 or slot 5 or both."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach issue of a business newsletter has five slots, numbered 1 through 5. The policy of the newsletter requires that there are at least three features per issue, with each feature completely occupying one or more of the slots. Each feature can be one of four types—finance, industry, marketing, or technology. Any slot not containing a feature contains a graphic. The newsletters policy further requires that each issue be structured as follows: Any feature occupying more than one slot must occupy consecutively numbered slots. If an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1. An issue can have at most one industry feature.\nQuestion:\nIf, in a particular issue of the newsletter, slot 1 is occupied by the only industry feature in that issue, then which one of the following is required for that issue?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nslots = EnumSort([1, 2, 3, 4, 5])\nfeatures = EnumSort([finance, industry, marketing, technology])\nslot_features = Function([slot:slots, feature:features] -> [feature])\n\n# Constraints\nForAll([s:slots], Count([f:features], slot_features(s, f)) >= 3) ::: each issue has at least three features\nAnd(slot_features(1, industry), Count([f:features], And(f != industry, slot_features(s, f))) == 1) ::: slot 1 is occupied by the only industry feature in that issue\nOr(slot_features(1, finance), slot_features(1, technology)) ::: if an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1\nCount([f:features], And(f != industry, slot_features(s, f))) <= 1 ::: an issue can have at most one industry feature\n\n# Options\nQuestion ::: Which one of the following is required for that issue?\nis_valid(Exists([s:slots], slot_features(s, industry) == true)) ::: (A)\nis_valid(Exists([s:slots], slot_features(s, marketing) == true)) ::: (B)\nis_valid(Exists([s:slots], slot_features(s, technology) == true)) ::: (C)\nis_valid(Exists([s:slots], slot_features(s, finance) == true)) ::: (D)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201506_4-G_4_23",
    "context": "Each issue of a business newsletter has five slots, numbered 1 through 5. The policy of the newsletter requires that there are at least three features per issue, with each feature completely occupying one or more of the slots. Each feature can be one of four types—finance, industry, marketing, or technology. Any slot not containing a feature contains a graphic. The newsletters policy further requires that each issue be structured as follows: Any feature occupying more than one slot must occupy consecutively numbered slots. If an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1. An issue can have at most one industry feature.",
    "question": "Any of the following is allowed for an issue of the newsletter EXCEPT:",
    "answer": "D",
    "options": [
      "A) There is exactly one finance feature and no industry or marketing feature.",
      "B) There is exactly one industry feature and no finance or marketing feature.",
      "C) There is exactly one industry feature and no marketing or technology feature.",
      "D) There is exactly one marketing feature and no finance or technology feature.",
      "E) There is exactly one marketing feature and no industry or technology feature."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nEach issue of a business newsletter has five slots, numbered 1 through 5. The policy of the newsletter requires that there are at least three features per issue, with each feature completely occupying one or more of the slots. Each feature can be one of four types—finance, industry, marketing, or technology. Any slot not containing a feature contains a graphic. The newsletters policy further requires that each issue be structured as follows: Any feature occupying more than one slot must occupy consecutively numbered slots. If an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1. An issue can have at most one industry feature.\nQuestion:\nAny of the following is allowed for an issue of the newsletter EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\nfeatures = EnumSort([finance, industry, marketing, technology])\nslots = EnumSort([1, 2, 3, 4, 5])\nissue = EnumSort([1, 2, 3, 4, 5])\noccupies = Function([features, slots] -> [bool])\n\n# Constraints\nForAll([f:features], ForAll([s:slots], And(occupies(f, s), Count([i:issue], occupies(f, i)) >= 3))) ::: Each feature occupies at least one slot\nAnd(occupies(finance, 1), Count([i:issue], occupies(finance, i)) == 1) ::: If an issue has any finance or technology feature, then a finance or technology feature must occupy slot 1\nOr(occupies(industry, 1), occupies(industry, 2)) ::: An issue can have at most one industry feature\nForAll([i:issue], Implies(occupies(finance, i), occupies(technology, i))) ::: Any slot not containing a feature contains a graphic\n\n# Options\nQuestion ::: Any of the following is allowed for an issue of the newsletter EXCEPT:\nis_valid(Exists([i:issue], occupies(finance, i) == [1, 2, 3])) ::: (A)\nis_valid(Exists([i:issue], occupies(industry, i) == [1, 2, 3])) ::: (B)\nis_valid(Exists([i:issue], occupies(marketing, i) == [1, 2, 3])) ::: (C)\nis_valid(Exists([i:issue], occupies(technology, i) == [1, 2, 3])) ::: (D)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_1_1",
    "context": "Six entertainers—Robinson, Shahpari, Tigay, Wu, Yeaton, and Zane—are being scheduled for the six performances on the opening day of a community festival. Each entertainer will perform at one of six times—in the morning at 9:00 A.M., 10:00 A.M., or 11:00 A.M., or in the afternoon at 2:00 P.M., 3:00 P.M., or 4:00 P.M.—with no two entertainers performing at the same scheduled time. The order in which the entertainers perform is subject to the following constraints: Robinson must perform at some time before Zane. Yeaton's performance must be the next performance after Wu's. Tigay must perform in the afternoon. Zane must perform in the morning.",
    "question": "Which one of the following could be the order, from first to last, in which the entertainers are scheduled to perform?",
    "answer": "A",
    "options": [
      "A) Robinson, Shahpari, Zane, Tigay, Wu, Yeaton",
      "B) Robinson, Wu, Yeaton, Zane, Shahpari, Tigay",
      "C) Robinson, Zane, Tigay, Shahpari, Wu, Yeaton",
      "D) Shahpari, Robinson, Zane, Wu, Tigay, Yeaton",
      "E) Wu, Yeaton, Zane, Shahpari, Tigay, Robinson"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix entertainers—Robinson, Shahpari, Tigay, Wu, Yeaton, and Zane—are being scheduled for the six performances on the opening day of a community festival. Each entertainer will perform at one of six times—in the morning at 9:00 A.M., 10:00 A.M., or 11:00 A.M., or in the afternoon at 2:00 P.M., 3:00 P.M., or 4:00 P.M.—with no two entertainers performing at the same scheduled time. The order in which the entertainers perform is subject to the following constraints: Robinson must perform at some time before Zane. Yeaton's performance must be the next performance after Wu's. Tigay must perform in the afternoon. Zane must perform in the morning.\nQuestion:\nWhich one of the following could be the order, from first to last, in which the entertainers are scheduled to perform?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nentertainers = EnumSort([Robinson, Shahpari, Tigay, Wu, Yeaton, Zane])\ntimes = EnumSort([9:00, 10:00, 11:00, 2:00, 3:00, 4:00])\nschedule = Function([entertainers, times] -> [bool])\n\n# Constraints\nForAll([t:times], Count([e:entertainers], schedule(e, t)) >= 1) ::: each time has at least one entertainer scheduled\nAnd(schedule(Robinson, 9:00), schedule(Shahpari, 10:00), schedule(Tigay, 11:00)) ::: Robinson must perform at some time before Zane\nAnd(schedule(Wu, 2:00), schedule(Yeaton, 3:00), schedule(Zane, 4:00)) ::: Yeaton's performance must be the next performance after Wu's\nschedule(Tigay, afternoon) ::: Tigay must perform in the afternoon\nschedule(Zane, morning) ::: Zane must perform in the morning\n\n# Options\nQuestion ::: Which one of the following could be the order, from first to last, in which the entertainers are scheduled to perform?\nis_sat(ForAll([t:times], schedule(Robinson, t) == schedule(Shahpari, t))) ::: (A)\nis_sat(ForAll([t:times], schedule(Shahpari, t) == schedule(Yeaton, t))) ::: (B)\nis_sat(ForAll([t:times], schedule(Shahpari, t) == schedule(Tigay, t))) ::: (C)\nis_sat(ForAll([t:times], schedule(Wu, t) == schedule(Yeaton, t))) ::: (D)\nis_sat(ForAll([t:times], schedule(Tigay, t) == schedule(Zane, t))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_1_2",
    "context": "Six entertainers—Robinson, Shahpari, Tigay, Wu, Yeaton, and Zane—are being scheduled for the six performances on the opening day of a community festival. Each entertainer will perform at one of six times—in the morning at 9:00 A.M., 10:00 A.M., or 11:00 A.M., or in the afternoon at 2:00 P.M., 3:00 P.M., or 4:00 P.M.—with no two entertainers performing at the same scheduled time. The order in which the entertainers perform is subject to the following constraints: Robinson must perform at some time before Zane. Yeaton's performance must be the next performance after Wu's. Tigay must perform in the afternoon. Zane must perform in the morning.",
    "question": "If Wu is scheduled to perform in the morning, then which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) Robinson is scheduled to perform at 10:00 A.M.",
      "B) Shahpari is scheduled to perform at 3:00 P.M.",
      "C) Tigay is scheduled to perform at 2:00 P.M.",
      "D) Yeaton is scheduled to perform at 3:00 P.M.",
      "E) Zane is scheduled to perform at 11:00 A.M."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix entertainers—Robinson, Shahpari, Tigay, Wu, Yeaton, and Zane—are being scheduled for the six performances on the opening day of a community festival. Each entertainer will perform at one of six times—in the morning at 9:00 A.M., 10:00 A.M., or 11:00 A.M., or in the afternoon at 2:00 P.M., 3:00 P.M., or 4:00 P.M.—with no two entertainers performing at the same scheduled time. The order in which the entertainers perform is subject to the following constraints: Robinson must perform at some time before Zane. Yeaton's performance must be the next performance after Wu's. Tigay must perform in the afternoon. Zane must perform in the morning.\nQuestion:\nIf Wu is scheduled to perform in the morning, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nentertainers = EnumSort([Robinson, Shahpari, Tigay, Wu, Yeaton, Zane])\ntimes = EnumSort([9:00, 10:00, 11:00, 2:00, 3:00, 4:00])\nschedule = Function([entertainers, times] -> [bool])\n\n# Constraints\nForAll([t:times], Count([e:entertainers], schedule(e, t)) >= 1) ::: each entertainer performs at least one time\nAnd(schedule(Robinson, 9:00), schedule(Zane, 9:00)) ::: Robinson must perform at some time before Zane\nForAll([e:entertainers], Implies(schedule(e, 10:00), schedule(e, 9:00))) ::: each entertainer's performance must be the next performance after their previous performance\nForAll([e:entertainers], Implies(schedule(e, 11:00), schedule(e, 10:00))) ::: Yeaton's performance must be the next performance after Wu's\nschedule(Tigay, afternoon) ::: Tigay must perform in the afternoon\nschedule(Zane, morning) ::: Zane must perform in the morning\n\n# Options\nQuestion ::: Which one of the following could be true if Wu is scheduled to perform in the morning?\nis_valid(ForAll([t:times], schedule(Wu, t) == schedule(Yeaton, t))) ::: (A)\nis_valid(ForAll([t:times], schedule(Wu, t) == schedule(Tigay, t))) ::: (B)\nis_valid(ForAll([t:times], schedule(Wu, t) == schedule(Zane, t))) ::: (C)\nis_valid(ForAll([t:times], schedule(Wu, t) == schedule(Robinson, t))) ::: (D)\nis_valid(ForAll([t:times], schedule(Wu, t) == schedule(Yeaton, t))) ::: (E)\n\n------\nNote: The above code is just an example, and the actual code may vary based on the specific problem description and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_1_3",
    "context": "Six entertainers—Robinson, Shahpari, Tigay, Wu, Yeaton, and Zane—are being scheduled for the six performances on the opening day of a community festival. Each entertainer will perform at one of six times—in the morning at 9:00 A.M., 10:00 A.M., or 11:00 A.M., or in the afternoon at 2:00 P.M., 3:00 P.M., or 4:00 P.M.—with no two entertainers performing at the same scheduled time. The order in which the entertainers perform is subject to the following constraints: Robinson must perform at some time before Zane. Yeaton's performance must be the next performance after Wu's. Tigay must perform in the afternoon. Zane must perform in the morning.",
    "question": "Shahpari CANNOT be scheduled to perform at which one of the following times?",
    "answer": "D",
    "options": [
      "A) 9:00 A.M.",
      "B) 10:00 A.M.",
      "C) 11:00 A.M.",
      "D) 2:00 P.M.",
      "E) 3:00 P.M."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix entertainers—Robinson, Shahpari, Tigay, Wu, Yeaton, and Zane—are being scheduled for the six performances on the opening day of a community festival. Each entertainer will perform at one of six times—in the morning at 9:00 A.M., 10:00 A.M., or 11:00 A.M., or in the afternoon at 2:00 P.M., 3:00 P.M., or 4:00 P.M.—with no two entertainers performing at the same scheduled time. The order in which the entertainers perform is subject to the following constraints: Robinson must perform at some time before Zane. Yeaton's performance must be the next performance after Wu's. Tigay must perform in the afternoon. Zane must perform in the morning.\nQuestion:\nShahpari CANNOT be scheduled to perform at which one of the following times?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nentertainer = EnumSort([Robinson, Shahpari, Tigay, Wu, Yeaton, Zane])\nperformance = EnumSort([morning, afternoon])\nschedule = Function([entertainer, performance])\n\n# Constraints\nForAll([e:entertainer], Count([p:performance], schedule(e, p)) >= 1) ::: each entertainer is scheduled at least once\nAnd(schedule(Robinson, morning), ForAll([e:entertainer], Not(schedule(e, morning)) == schedule(e, afternoon))) ::: Robinson must perform at some time before Zane\nAnd(schedule(Wu, afternoon), schedule(Yeaton, next_performance(Wu))) ::: Yeaton's performance must be the next performance after Wu's\nOr(schedule(Tigay, afternoon), schedule(Tigay, next_performance(Wu))) ::: Tigay must perform in the afternoon\nschedule(Zane, morning) ::: Zane must perform in the morning\n\n# Options\nQuestion ::: Shahpari CANNOT be scheduled to perform at which one of the following times?\nis_valid(Exists([p:performance], schedule(Shahpari, p) == 2)) ::: (A)\nis_valid(Exists([p:performance], schedule(Shahpari, p) == 3)) ::: (B)\nis_valid(Exists([p:performance], schedule(Shahpari, p) == 4)) ::: (C)\nis_valid(Exists([p:performance], schedule(Shahpari, p) == 5)) ::: (D)\nis_valid(Exists([p:performance], schedule(Shahpari, p) == 6)) ::: (E)\n\n------\n\nNote: The `is_valid` function is used to check whether the given option is valid, i.e., whether it satisfies the constraints of the problem. If the option is valid, the `is_valid` function returns `True`, otherwise it returns `False`."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_1_4",
    "context": "Six entertainers—Robinson, Shahpari, Tigay, Wu, Yeaton, and Zane—are being scheduled for the six performances on the opening day of a community festival. Each entertainer will perform at one of six times—in the morning at 9:00 A.M., 10:00 A.M., or 11:00 A.M., or in the afternoon at 2:00 P.M., 3:00 P.M., or 4:00 P.M.—with no two entertainers performing at the same scheduled time. The order in which the entertainers perform is subject to the following constraints: Robinson must perform at some time before Zane. Yeaton's performance must be the next performance after Wu's. Tigay must perform in the afternoon. Zane must perform in the morning.",
    "question": "What is the earliest time that Wu could be scheduled to perform?",
    "answer": "C",
    "options": [
      "A) 9:00 A.M.",
      "B) 10:00 A.M.",
      "C) 11:00 A.M.",
      "D) 2:00 P.M.",
      "E) 3:00 P.M."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix entertainers—Robinson, Shahpari, Tigay, Wu, Yeaton, and Zane—are being scheduled for the six performances on the opening day of a community festival. Each entertainer will perform at one of six times—in the morning at 9:00 A.M., 10:00 A.M., or 11:00 A.M., or in the afternoon at 2:00 P.M., 3:00 P.M., or 4:00 P.M.—with no two entertainers performing at the same scheduled time. The order in which the entertainers perform is subject to the following constraints: Robinson must perform at some time before Zane. Yeaton's performance must be the next performance after Wu's. Tigay must perform in the afternoon. Zane must perform in the morning.\nQuestion:\nWhat is the earliest time that Wu could be scheduled to perform?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nentertainer = EnumSort([Robinson, Shahpari, Tigay, Wu, Yeaton, Zane])\nperformance = EnumSort([morning, afternoon])\nschedule = Function([entertainer, performance]) -> [time]\n\n# Constraints\nForAll([e:entertainer], Count([p:performance], schedule(e, p)) >= 1) ::: each entertainer has at least one scheduled performance\nAnd(schedule(Robinson, morning) -> Some(time)) ::: Robinson must perform at some time before Zane\nForAll([e:entertainer], Implies(schedule(e, afternoon), schedule(Wu, afternoon))) ::: Yeaton's performance must be the next performance after Wu's\nschedule(Tigay, afternoon) ::: Tigay must perform in the afternoon\nschedule(Zane, morning) ::: Zane must perform in the morning\n\n# Options\nQuestion ::: What is the earliest time that Wu could be scheduled to perform?\nis_valid(Exists([p:performance], schedule(Wu, p) == 9:00 A.M.)) ::: (A)\nis_valid(Exists([p:performance], schedule(Wu, p) == 10:00 A.M.)) ::: (B)\nis_valid(Exists([p:performance], schedule(Wu, p) == 11:00 A.M.)) ::: (C)\nis_valid(Exists([p:performance], schedule(Wu, p) == 2:00 P.M.)) ::: (D)\nis_valid(Exists([p:performance], schedule(Wu, p) == 3:00 P.M.)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_1_5",
    "context": "Six entertainers—Robinson, Shahpari, Tigay, Wu, Yeaton, and Zane—are being scheduled for the six performances on the opening day of a community festival. Each entertainer will perform at one of six times—in the morning at 9:00 A.M., 10:00 A.M., or 11:00 A.M., or in the afternoon at 2:00 P.M., 3:00 P.M., or 4:00 P.M.—with no two entertainers performing at the same scheduled time. The order in which the entertainers perform is subject to the following constraints: Robinson must perform at some time before Zane. Yeaton's performance must be the next performance after Wu's. Tigay must perform in the afternoon. Zane must perform in the morning.",
    "question": "Which one of the following is a complete and accurate list of the entertainers who must be scheduled to perform in the afternoon?",
    "answer": "C",
    "options": [
      "A) Tigay",
      "B) Tigay, Wu",
      "C) Tigay, Yeaton",
      "D) Tigay, Wu, Yeaton",
      "E) Tigay, Shahpari, Yeaton"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix entertainers—Robinson, Shahpari, Tigay, Wu, Yeaton, and Zane—are being scheduled for the six performances on the opening day of a community festival. Each entertainer will perform at one of six times—in the morning at 9:00 A.M., 10:00 A.M., or 11:00 A.M., or in the afternoon at 2:00 P.M., 3:00 P.M., or 4:00 P.M.—with no two entertainers performing at the same scheduled time. The order in which the entertainers perform is subject to the following constraints: Robinson must perform at some time before Zane. Yeaton's performance must be the next performance after Wu's. Tigay must perform in the afternoon. Zane must perform in the morning.\nQuestion:\nWhich one of the following is a complete and accurate list of the entertainers who must be scheduled to perform in the afternoon?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nentertainers = EnumSort([Robinson, Shahpari, Tigay, Wu, Yeaton, Zane])\ntimes = EnumSort([9:00, 10:00, 11:00, 2:00, 3:00, 4:00])\nschedule = Function([entertainers, times] -> [bool])\n\n# Constraints\nForAll([t:times], Count([e:entertainers], schedule(e, t)) >= 1) ::: each entertainer performs at least one time\nAnd(schedule(Robinson, 9:00), schedule(Robinson, 10:00)) ::: Robinson must perform at some time before Zane\nAnd(schedule(Wu, 3:00), schedule(Yeaton, 4:00)) ::: Yeaton's performance must be the next performance after Wu's\nOr(schedule(Tigay, 2:00), schedule(Tigay, 3:00)) ::: Tigay must perform in the afternoon\nschedule(Zane, 11:00) ::: Zane must perform in the morning\n\n# Options\nQuestion ::: Which one of the following is a complete and accurate list of the entertainers who must be scheduled to perform in the afternoon?\nis_sat(ForAll([t:times], schedule(entertainers, t) == [tigay, wu])) ::: (A)\nis_sat(ForAll([t:times], schedule(entertainers, t) == [yeaton, wu])) ::: (B)\nis_sat(ForAll([t:times], schedule(entertainers, t) == [tigay, yeaton])) ::: (C)\nis_sat(ForAll([t:times], schedule(entertainers, t) == [zane, wu])) ::: (D)\nis_sat(ForAll([t:times], schedule(entertainers, t) == [yeaton, zane])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_2_6",
    "context": "Exactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.",
    "question": "Which one of the following could be the display of bowls, listed by potters name, in order from position 1 through position 6?",
    "answer": "E",
    "options": [
      "A) Larsen, Mills, Serra, Park, Olivera, Reigel",
      "B) Larsen, Neiman, Olivera, Park, Serra, Vance",
      "C) Mills, Olivera, Park, Serra, Reigel, Vance",
      "D) Reigel, Park, Serra, Olivera, Neiman, Mills",
      "E) Serra, Park, Olivera, Vance, Larsen, Reigel"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.\nQuestion:\nWhich one of the following could be the display of bowls, listed by potters name, in order from position 1 through position 6?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npotters = EnumSort([Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, Vance])\nbowls = EnumSort([1, 2, 3, 4, 5, 6])\ndisplay = Function([potters, bowls] -> [bool])\n\n# Constraints\nForAll([p:potters], Count([b:bowls], display(p, b)) >= 1) ::: each potter crafts at least one bowl\nAnd(display(Larsen, 1), Not(display(Mills, 1))) ::: Larsen's bowl is displayed, Mills's bowl cannot be displayed\nAnd(display(Park, 2), And(display(Olivera, 3), display(Serra, 4))) ::: Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl\nForAll([b:bowls], Implies(display(Reigel, b), display(Vance, b))) ::: Reigel's bowl can be displayed only in either position 1 or position 6\nForAll([b:bowls], Implies(display(Neiman, b), Not(display(Serra, b)))) ::: Serra's bowl cannot be displayed in either position 2 or position 4\nCount([b:bowls], display(Serra, b)) == 1 ::: Serra's bowl cannot be displayed in either position 2 or position 4\n\n# Options\nQuestion ::: Which one of the following could be the display of bowls, listed by potters name, in order from position 1 through position 6?\nis_sat(ForAll([b:bowls], display(Larsen, b) == display(Neiman, b))) ::: (A)\nis_sat(ForAll([b:bowls], display(Neiman, b) == display(Olivera, b))) ::: (B)\nis_sat(ForAll([b:bowls], display(Olivera, b) == display(Serra, b))) ::: (C)\nis_sat(ForAll([b:bowls], display(Serra, b) == display(Vance, b))) ::: (D)\nis_sat(ForAll([b:bowls], display(Vance, b) == display(Mills, b))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_2_7",
    "context": "Exactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.",
    "question": "If Neiman's bowl and Park's bowl are both displayed, which one of the following is a potter whose bowl could be displayed in position 1?",
    "answer": "D",
    "options": [
      "A) Larsen",
      "B) Park",
      "C) Reigel",
      "D) Serra",
      "E) Vance"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.\nQuestion:\nIf Neiman's bowl and Park's bowl are both displayed, which one of the following is a potter whose bowl could be displayed in position 1?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npotters = EnumSort([Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, Vance])\nbowls = EnumSort([1, 2, 3, 4, 5, 6])\ndisplayed = Function([potters, bowls] -> [bool])\n\n# Constraints\nForAll([p:potters], Count([b:bowls], displayed(p, b)) >= 1) ::: each potter crafts at least one bowl that will be displayed\nAnd(displayed(Larsen, 1), Not(displayed(Mills, 1))) ::: Larsen's bowl is displayed, Mills's bowl cannot be displayed\nAnd(displayed(Park, b) -> (b = 1 or b = 6), (Park == Olivera) or (Park == Serra)) ::: Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl\nForAll([b:bowls], Implies(displayed(Reigel, b), (b = 1 or b = 6))) ::: Reigel's bowl can be displayed only in either position 1 or position 6\nForAll([b:bowls], Implies(displayed(Serra, b), (b = 2 or b = 4))) ::: Serra's bowl cannot be displayed in either position 2 or position 4\nForAll([b:bowls], Implies(displayed(Neiman, b), (b = 5))) ::: Neiman's bowl can be displayed only in position 5\n\n# Options\nQuestion ::: Which one of the following is a potter whose bowl could be displayed in position 1?\nis_sat(ForAll([b:bowls], displayed(Neiman, b) == displayed(Park, b))) ::: (A)\nis_sat(ForAll([b:bowls], displayed(Park, b) == displayed(Olivera, b))) ::: (B)\nis_sat(ForAll([b:bowls], displayed(Park, b) == displayed(Serra, b))) ::: (C)\nis_sat(ForAll([b:bowls], displayed(Neiman, b) == displayed(Vance, b))) ::: (D)\nis_sat(ForAll([b:bowls], displayed(Neiman, b) == displayed(Mills, b))) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the Prolog engine, which checks whether the given formula is satisfiable (i.e., whether it is possible to assign values to the variables that make the formula true)."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_2_8",
    "context": "Exactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.",
    "question": "If Larsen's bowl is displayed in position 6 and Olivera's bowl is displayed in position 2, which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) Mills's bowl is displayed in position 3.",
      "B) Serra's bowl is displayed in position 1.",
      "C) Serra's bowl is displayed in position 3.",
      "D) Vance's bowl is displayed in position 1.",
      "E) Vance's bowl is displayed in position 3."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.\nQuestion:\nIf Larsen's bowl is displayed in position 6 and Olivera's bowl is displayed in position 2, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npotters = EnumSort([Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, Vance])\nbowls = EnumSort([1, 2, 3, 4, 5, 6])\npositions = EnumSort([1, 2, 3, 4, 5, 6])\ndisplayed = Function([potters, positions] -> [bool])\n\n# Constraints\nForAll([p:potters], Count([b:bowls], displayed(p, b)) >= 1) ::: each potter crafts at least one bowl\nAnd(displayed(Larsen, 6), Not(displayed(Mills, 6))) ::: Larsen's bowl is displayed in position 6, and Mills's bowl is not displayed in position 6\nAnd(displayed(Park, 2), (displayed(Olivera, 2) And displayed(Serra, 4))) ::: Park's bowl is displayed in position 2, and Olivera's bowl is displayed in position 2 and Serra's bowl is not displayed in position 4\nForAll([p:potters], Implies(displayed(p, 1), Not(displayed(Reigel, 1)))) ::: Reigel's bowl can be displayed only in either position 1 or position 6\nCount([p:potters], displayed(p, 5)) == 1 ::: Neiman's bowl can be displayed only in position 5\n\n# Options\nQuestion ::: Which one of the following must be true if Larsen's bowl is displayed in position 6 and Olivera's bowl is displayed in position 2?\nis_valid(ForAll([p:potters], (displayed(p, 6) And displayed(Olivera, 2)) Implies (Neiman's bowl is displayed in position 5))) ::: (A)\nis_valid(ForAll([p:potters], (displayed(p, 6) And displayed(Olivera, 2)) Implies (Serra's bowl is displayed in position 4))) ::: (B)\nis_valid(ForAll([p:potters], (displayed(p, 6) And displayed(Olivera, 2)) Implies (Vance's bowl is displayed in position 3))) ::: (C)\nis_valid(ForAll([p:potters], (displayed(p, 6) And displayed(Olivera, 2)) Implies (Reigel's bowl is displayed in position 1))) ::: (D)\nis_valid(ForAll([p:potters], (displayed(p, 6) And displayed(Olivera, 2)) Implies (Mills's bowl is displayed in position 6))) ::: (E)\n\n------\n\nPlease provide the code for each problem and question, along with the desired output for each option."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_2_9",
    "context": "Exactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.",
    "question": "If Park's bowl is displayed in position 4, then the bowl displayed in position 2 must be",
    "answer": "A",
    "options": [
      "A) Larsen's, Mills's, or Vance's",
      "B) Larsen's, Neiman's, or Vance's",
      "C) Larsen's, Serra's, or Vance's",
      "D) Mills's, Reigel's, or Vance's",
      "E) Mills's, Serra's, or Vance's"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.\nQuestion:\nIf Park's bowl is displayed in position 4, then the bowl displayed in position 2 must be\nChoices:\n[[CHOICES]]\n###\n# Declarations\npotters = EnumSort([Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, Vance])\nbowls = EnumSort([1, 2, 3, 4, 5, 6])\npositions = EnumSort([1, 2, 3, 4, 5, 6])\ndisplayed = Function([potters, positions] -> [bool])\n\n# Constraints\nForAll([p:potters], ForAll([p:positions], displayed(p, p) == true)) ::: each potter crafts exactly one bowl\nAnd(displayed(Larsen, 1), Not(displayed(Mills, 1))) ::: Larsen's bowl is displayed in position 1, Mills's bowl cannot be displayed in position 1\nAnd(displayed(Park, 4), Implies(displayed(Park, 2), (displayed(Olivera, 3) && displayed(Serra, 6)))) ::: Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl\nAnd(displayed(Reigel, 1) || displayed(Reigel, 6)) ::: Reigel's bowl can be displayed only in either position 1 or position 6\nAnd(displayed(Neiman, 5) || displayed(Neiman, 6)) ::: Neiman's bowl can be displayed only in position 5\n\n# Options\nQuestion ::: If Park's bowl is displayed in position 4, then the bowl displayed in position 2 must be\nis_valid(ForAll([p:potters], ForAll([p:positions], displayed(p, p) == true) implies displayed(p, 2) == Neiman's bowl)) ::: (A)\nis_valid(ForAll([p:potters], ForAll([p:positions], displayed(p, p) == true) implies displayed(p, 2) == Olivera's bowl)) ::: (B)\nis_valid(ForAll([p:potters], ForAll([p:positions], displayed(p, p) == true) implies displayed(p, 2) == Vance's bowl)) ::: (C)\nis_valid(ForAll([p:potters], ForAll([p:positions], displayed(p, p) == true) implies displayed(p, 2) == Serra's bowl)) ::: (D)\nis_valid(ForAll([p:potters], ForAll([p:positions], displayed(p, p) == true) implies displayed(p, 2) == Neiman's bowl)) ::: (E)\n\n------\n\nPlease provide the code for each problem and question, along with the desired output for each option."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_2_10",
    "context": "Exactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.",
    "question": "If Larsen's bowl is displayed in position 1 and Olivera's bowl is displayed in position 4, which one of the following is a potter whose bowl CANNOT be displayed?",
    "answer": "B",
    "options": [
      "A) Neiman",
      "B) Park",
      "C) Reigel",
      "D) Serra",
      "E) Vance"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.\nQuestion:\nIf Larsen's bowl is displayed in position 1 and Olivera's bowl is displayed in position 4, which one of the following is a potter whose bowl CANNOT be displayed?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npotters = EnumSort([Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, Vance])\nbowls = EnumSort([1, 2, 3, 4, 5, 6])\ndisplayed = Function([potters, bowls] -> [bool])\n\n# Constraints\nForAll([p:potters], Count([b:bowls], displayed(p, b)) >= 1) ::: each potter crafts at least one bowl\nImplies(displayed(Larsen, 1), Not(displayed(Mills, 1))) ::: Larsen's bowl is displayed in position 1, Mills's bowl cannot be displayed\nImplies(displayed(Park, 4), (displayed(Olivera, 4) And displayed(Serra, 4))) ::: Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl\nImplies(displayed(Reigel, 1 Or displayed(Reigel, 6)), Not(displayed(Neiman, 5))) ::: Reigel's bowl can be displayed only in either position 1 or position 6\nImplies(displayed(Serra, 2 Or displayed(Serra, 4)), Not(displayed(Neiman, 5))) ::: Serra's bowl cannot be displayed in either position 2 or position 4\nImplies(displayed(Neiman, 5), Not(displayed(Vance, 5))) ::: Neiman's bowl can be displayed only in position 5\n\n# Options\nQuestion ::: Which one of the following is a potter whose bowl CANNOT be displayed?\nis_valid(Exists([b:bowls], displayed(Vance, b) == False)) ::: (A)\nis_valid(Exists([b:bowls], displayed(Neiman, b) == False)) ::: (B)\nis_valid(Exists([b:bowls], displayed(Olivera, b) == False)) ::: (C)\nis_valid(Exists([b:bowls], displayed(Serra, b) == False)) ::: (D)\nis_valid(Exists([b:bowls], displayed(Vance, b) == True)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_2_11",
    "context": "Exactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.",
    "question": "Which one of the following is a potter whose bowl must be displayed?",
    "answer": "B",
    "options": [
      "A) Neiman",
      "B) Olivera",
      "C) Park",
      "D) Reigel",
      "E) Vance"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.\nQuestion:\nWhich one of the following is a potter whose bowl must be displayed?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npotters = EnumSort([Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, Vance])\nbowls = EnumSort([1, 2, 3, 4, 5, 6])\ndisplayed = Function([potters, bowls] -> [bool])\n\n# Constraints\nForAll([p:potters], Count([b:bowls], displayed(p, b)) >= 1) ::: each potter crafts at least one bowl that will be displayed\nImplies(displayed(Larsen, 1), Not(displayed(Mills, 1))) ::: Larsen's bowl is displayed, Mills's bowl cannot be displayed\nImplies(displayed(Park, 3), And(displayed(Olivera, 3), displayed(Serra, 3))) ::: Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl\nImplies(displayed(Reigel, 5), Or(displayed(Neiman, 5), displayed(Reigel, 6))) ::: Reigel's bowl can be displayed only in either position 1 or position 6\nImplies(displayed(Serra, 2), Not(displayed(Neiman, 5))) ::: Serra's bowl cannot be displayed in either position 2 or position 4\n\n# Options\nQuestion ::: Which one of the following is a potter whose bowl must be displayed?\nis_valid(Exists([b:bowls], displayed(Neiman, b))) ::: (A)\nis_valid(Exists([b:bowls], displayed(Olivera, b))) ::: (B)\nis_valid(Exists([b:bowls], displayed(Park, b))) ::: (C)\nis_valid(Exists([b:bowls], displayed(Reigel, b))) ::: (D)\nis_valid(Exists([b:bowls], displayed(Serra, b))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_2_12",
    "context": "Exactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.",
    "question": "If Neiman's bowl, Park's bowl, and Reigel's bowl are all displayed, which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) Neiman's bowl is displayed next to Reigel's bowl.",
      "B) Neiman's bowl is displayed next to Vance's bowl.",
      "C) Olivera's bowl is displayed next to Reigel's bowl.",
      "D) Olivera's bowl is displayed next to Vance's bowl.",
      "E) Serra's bowl is displayed next to Vance's bowl."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly six of eight ceramic bowls, each crafted by exactly one of eight potters—Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, and Vance—will be displayed in a row in positions consecutively numbered 1 through 6, one bowl per position. The display is subject to the following conditions: If Larsen's bowl is displayed, Mills's bowl cannot be displayed. Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl. Reigel's bowl can be displayed only in either position 1 or position 6. Serra's bowl cannot be displayed in either position 2 or position 4. Neiman's bowl can be displayed only in position 5.\nQuestion:\nIf Neiman's bowl, Park's bowl, and Reigel's bowl are all displayed, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npotters = EnumSort([Larsen, Mills, Neiman, Olivera, Park, Reigel, Serra, Vance])\nbowls = EnumSort([1, 2, 3, 4, 5, 6])\ndisplayed = Function([potters, bowls] -> [bool])\n\n# Constraints\nForAll([p:potters], Count([b:bowls], displayed(p, b)) >= 1) ::: each potter crafts at least one bowl\nAnd(displayed(Larsen, 1), Not(displayed(Mills, 1))) ::: Larsen's bowl is displayed, Mills's bowl cannot be displayed\nAnd(displayed(Park, b) for b in [2, 4, 6]) ::: Park's bowl can be displayed only if it is next to Olivera's bowl and next to Serra's bowl\nAnd(displayed(Reigel, 1) or displayed(Reigel, 6)) ::: Reigel's bowl can be displayed only in either position 1 or position 6\nNot(displayed(Serra, 2) or displayed(Serra, 4)) ::: Serra's bowl cannot be displayed in either position 2 or position 4\nForAll([b:bowls], Implies(displayed(Neiman, b), Not(displayed(Olivera, b)) or displayed(Serra, b))) ::: Neiman's bowl can be displayed only in position 5\n\n# Options\nQuestion ::: Which one of the following must be true if Neiman's bowl, Park's bowl, and Reigel's bowl are all displayed?\nis_valid(ForAll([b:bowls], displayed(Neiman, b) == displayed(Park, b))) ::: (A)\nis_valid(ForAll([b:bowls], displayed(Neiman, b) == displayed(Reigel, b))) ::: (B)\nis_valid(ForAll([b:bowls], displayed(Park, b) == displayed(Reigel, b))) ::: (C)\nis_valid(ForAll([b:bowls], displayed(Neiman, b) == displayed(Olivera, b))) ::: (D)\nis_valid(ForAll([b:bowls], displayed(Park, b) == displayed(Olivera, b))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_3_13",
    "context": "Four employees—Jackson, Larabee, Paulson, and Torillo—are to select from among four offices—W, X, Y, and Z. The order in which they select, from first to fourth, is to be decided by a random drawing. Each employee has ranked the offices from first (highest) to fourth (lowest) as follows: Jackson: Y, X, Z, W Larabee: X, Z, W, Y Paulson: Y, Z, X, W Torillo: X, Y, Z, W The following restrictions must apply: Each employee selects an office that has not been selected previously. Each employee selects only one office. Each employee selects the office that he or she ranks highest among the unselected offices.",
    "question": "Which one of the following is a possible matching of employees with the offices they select?",
    "answer": "B",
    "options": [
      "A) Jackson: W; Larabee: Y; Paulson: X; Torillo: Z",
      "B) Jackson: Z; Larabee: X; Paulson: W; Torillo: Y",
      "C) Jackson: X; Larabee: W; Paulson: Z; Torillo: Y",
      "D) Jackson: Y; Larabee: W; Paulson: X; Torillo: Z",
      "E) Jackson: Y; Larabee: Z; Paulson: X; Torillo: W"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFour employees—Jackson, Larabee, Paulson, and Torillo—are to select from among four offices—W, X, Y, and Z. The order in which they select, from first to fourth, is to be decided by a random drawing. Each employee has ranked the offices from first (highest) to fourth (lowest) as follows: Jackson: Y, X, Z, W Larabee: X, Z, W, Y Paulson: Y, Z, X, W Torillo: X, Y, Z, W The following restrictions must apply: Each employee selects an office that has not been selected previously. Each employee selects only one office. Each employee selects the office that he or she ranks highest among the unselected offices.\nQuestion:\nWhich one of the following is a possible matching of employees with the offices they select?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nemployees = EnumSort([Jackson, Larabee, Paulson, Torillo])\noffices = EnumSort([W, X, Y, Z])\nrankings = Function([employees, offices] -> [int])\n\n# Constraints\nForAll([e:employees], ForAll([o:offices], Not(e.rankings(o) == e.rankings(o))))) ::: Each employee selects an office that has not been selected previously\nForAll([e:employees], ForAll([o:offices], e.rankings(o) == e.rankings(unselected_offices(e))))) ::: Each employee selects only one office\nForAll([e:employees], ForAll([o:offices], e.rankings(o) == max(e.rankings(unselected_offices(e)), default=0))) ::: Each employee selects the office that he or she ranks highest among the unselected offices\n\n# Options\nQuestion ::: Which one of the following is a possible matching of employees with the offices they select?\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o) == 1))) ::: (A)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o) == 2))) ::: (B)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o) == 3))) ::: (C)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o) == 4))) ::: (D)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o) == 5))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_3_14",
    "context": "Four employees—Jackson, Larabee, Paulson, and Torillo—are to select from among four offices—W, X, Y, and Z. The order in which they select, from first to fourth, is to be decided by a random drawing. Each employee has ranked the offices from first (highest) to fourth (lowest) as follows: Jackson: Y, X, Z, W Larabee: X, Z, W, Y Paulson: Y, Z, X, W Torillo: X, Y, Z, W The following restrictions must apply: Each employee selects an office that has not been selected previously. Each employee selects only one office. Each employee selects the office that he or she ranks highest among the unselected offices.",
    "question": "Which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) At most one of the employees selects the office he or she ranks first.",
      "B) At most one of the employees selects the office he or she ranks second.",
      "C) At least one of the employees selects the office he or she ranks first.",
      "D) At least one of the employees selects the office he or she ranks second.",
      "E) At least one of the employees selects the office he or she ranks third."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFour employees—Jackson, Larabee, Paulson, and Torillo—are to select from among four offices—W, X, Y, and Z. The order in which they select, from first to fourth, is to be decided by a random drawing. Each employee has ranked the offices from first (highest) to fourth (lowest) as follows: Jackson: Y, X, Z, W Larabee: X, Z, W, Y Paulson: Y, Z, X, W Torillo: X, Y, Z, W The following restrictions must apply: Each employee selects an office that has not been selected previously. Each employee selects only one office. Each employee selects the office that he or she ranks highest among the unselected offices.\nQuestion:\nWhich one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nemployees = EnumSort([Jackson, Larabee, Paulson, Torillo])\noffices = EnumSort([W, X, Y, Z])\nrankings = Function([employees, offices] -> [int])\n\n# Constraints\nForAll([e:employees], ForAll([o:offices], Not(e.rankings(o, e.rankings(o, -1))))) ::: Each employee selects an office that has not been selected previously\nForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) != e.rankings(o, -1))) ::: Each employee selects only one office\nForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == e.rankings(unselected_offices, e.rankings(unselected_offices, -1)))) ::: Each employee selects the office that he or she ranks highest among the unselected offices\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 1))) ::: (A)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 2))) ::: (B)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 3))) ::: (C)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 4))) ::: (D)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == -1))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_3_15",
    "context": "Four employees—Jackson, Larabee, Paulson, and Torillo—are to select from among four offices—W, X, Y, and Z. The order in which they select, from first to fourth, is to be decided by a random drawing. Each employee has ranked the offices from first (highest) to fourth (lowest) as follows: Jackson: Y, X, Z, W Larabee: X, Z, W, Y Paulson: Y, Z, X, W Torillo: X, Y, Z, W The following restrictions must apply: Each employee selects an office that has not been selected previously. Each employee selects only one office. Each employee selects the office that he or she ranks highest among the unselected offices.",
    "question": "Which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) Exactly two of the employees each selects the office he or she ranks third.",
      "B) Exactly two of the employees each selects the office he or she ranks fourth.",
      "C) Exactly three of the employees each selects the office he or she ranks second.",
      "D) Exactly three of the employees each selects the office he or she ranks third.",
      "E) Exactly three of the employees each selects the office he or she ranks fourth."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFour employees—Jackson, Larabee, Paulson, and Torillo—are to select from among four offices—W, X, Y, and Z. The order in which they select, from first to fourth, is to be decided by a random drawing. Each employee has ranked the offices from first (highest) to fourth (lowest) as follows: Jackson: Y, X, Z, W Larabee: X, Z, W, Y Paulson: Y, Z, X, W Torillo: X, Y, Z, W The following restrictions must apply: Each employee selects an office that has not been selected previously. Each employee selects only one office. Each employee selects the office that he or she ranks highest among the unselected offices.\nQuestion:\nWhich one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nemployees = EnumSort([Jackson, Larabee, Paulson, Torillo])\noffices = EnumSort([W, X, Y, Z])\nrankings = Function([employees, offices] -> [int])\n\n# Constraints\nForAll([e:employees], ForAll([o:offices], Not(e.rankings(o, e.rankings(o, -1))))) ::: Each employee selects an office that has not been selected previously\nForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == e.rankings(o, -1))) ::: Each employee selects only one office\nForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == e.rankings(unselected_offices, e.rankings(o, -1)))) ::: Each employee selects the office that he or she ranks highest among the unselected offices\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 1))) ::: (A)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 2))) ::: (B)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 3))) ::: (C)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 4))) ::: (D)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 5))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_3_16",
    "context": "Four employees—Jackson, Larabee, Paulson, and Torillo—are to select from among four offices—W, X, Y, and Z. The order in which they select, from first to fourth, is to be decided by a random drawing. Each employee has ranked the offices from first (highest) to fourth (lowest) as follows: Jackson: Y, X, Z, W Larabee: X, Z, W, Y Paulson: Y, Z, X, W Torillo: X, Y, Z, W The following restrictions must apply: Each employee selects an office that has not been selected previously. Each employee selects only one office. Each employee selects the office that he or she ranks highest among the unselected offices.",
    "question": "If Paulson selects office W, then which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Exactly two of the employees each selects the office he or she ranks second.",
      "B) Exactly two of the employees each selects the office he or she ranks third.",
      "C) Exactly three of the employees each selects the office he or she ranks first.",
      "D) Jackson selects office X.",
      "E) Larabee selects office Z."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFour employees—Jackson, Larabee, Paulson, and Torillo—are to select from among four offices—W, X, Y, and Z. The order in which they select, from first to fourth, is to be decided by a random drawing. Each employee has ranked the offices from first (highest) to fourth (lowest) as follows: Jackson: Y, X, Z, W Larabee: X, Z, W, Y Paulson: Y, Z, X, W Torillo: X, Y, Z, W The following restrictions must apply: Each employee selects an office that has not been selected previously. Each employee selects only one office. Each employee selects the office that he or she ranks highest among the unselected offices.\nQuestion:\nIf Paulson selects office W, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nemployees = EnumSort([Jackson, Larabee, Paulson, Torillo])\noffices = EnumSort([W, X, Y, Z])\nrankings = Function([employees, offices] -> [int])\n\n# Constraints\nForAll([e:employees], ForAll([o:offices], Implies(e.rankings(o), Not(e.rankings(o'))))) ::: Each employee ranks offices in a consistent order\nForAll([e:employees], Implies(e.rankings(W), e.rankings(X) != e.rankings(Y))) ::: Each employee ranks W higher than X and Y\nForAll([e:employees], Implies(e.rankings(X), e.rankings(Y) != e.rankings(Z))) ::: Each employee ranks X higher than Y and Z\nForAll([e:employees], Implies(e.rankings(Y), e.rankings(Z) != e.rankings(W))) ::: Each employee ranks Y higher than Z and W\nForAll([e:employees], Implies(e.rankings(Z), e.rankings(W) != e.rankings(X))) ::: Each employee ranks Z higher than W and X\n\n# Options\nQuestion ::: Which one of the following could be true if Paulson selects office W?\nis_valid(ForAll([e:employees], Implies(e.rankings(W), e.rankings(X) == e.rankings(Y))))) ::: (A)\nis_valid(ForAll([e:employees], Implies(e.rankings(W), e.rankings(X) == e.rankings(Z))))) ::: (B)\nis_valid(ForAll([e:employees], Implies(e.rankings(W), e.rankings(Y) == e.rankings(Z))))) ::: (C)\nis_valid(ForAll([e:employees], Implies(e.rankings(W), e.rankings(X) == e.rankings(Y))))) ::: (D)\nis_valid(ForAll([e:employees], Implies(e.rankings(W), e.rankings(Z) == e.rankings(X))))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_3_17",
    "context": "Four employees—Jackson, Larabee, Paulson, and Torillo—are to select from among four offices—W, X, Y, and Z. The order in which they select, from first to fourth, is to be decided by a random drawing. Each employee has ranked the offices from first (highest) to fourth (lowest) as follows: Jackson: Y, X, Z, W Larabee: X, Z, W, Y Paulson: Y, Z, X, W Torillo: X, Y, Z, W The following restrictions must apply: Each employee selects an office that has not been selected previously. Each employee selects only one office. Each employee selects the office that he or she ranks highest among the unselected offices.",
    "question": "Which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) Jackson does not select office X.",
      "B) Larabee does not select office W.",
      "C) Larabee does not select office Z.",
      "D) Torillo does not select office X.",
      "E) Paulson does not select office X."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nFour employees—Jackson, Larabee, Paulson, and Torillo—are to select from among four offices—W, X, Y, and Z. The order in which they select, from first to fourth, is to be decided by a random drawing. Each employee has ranked the offices from first (highest) to fourth (lowest) as follows: Jackson: Y, X, Z, W Larabee: X, Z, W, Y Paulson: Y, Z, X, W Torillo: X, Y, Z, W The following restrictions must apply: Each employee selects an office that has not been selected previously. Each employee selects only one office. Each employee selects the office that he or she ranks highest among the unselected offices.\nQuestion:\nWhich one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nemployees = EnumSort([Jackson, Larabee, Paulson, Torillo])\noffices = EnumSort([W, X, Y, Z])\nrankings = Function([employees, offices] -> [int])\n\n# Constraints\nForAll([e:employees], ForAll([o:offices], Not(e.rankings(o, e.rankings(o, -1))))) ::: Each employee selects an office that has not been selected previously\nForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) != e.rankings(o, -1))) ::: Each employee selects only one office\nForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == e.rankings(unselected_offices, e.rankings(unselected_offices, -1)))) ::: Each employee selects the office that he or she ranks highest among the unselected offices\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 1))) ::: (A)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 2))) ::: (B)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 3))) ::: (C)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == 4))) ::: (D)\nis_valid(ForAll([e:employees], ForAll([o:offices], e.rankings(o, e.rankings(o, -1)) == -1))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_4_18",
    "context": "Exactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.",
    "question": "Which one of the following could be the assignment of volunteers to Z?",
    "answer": "E",
    "options": [
      "A) leader: Haddad; secretary: Molina; treasurer: Joslin",
      "B) leader: Joslin; secretary: Haddad; treasurer: Molina",
      "C) leader: Kwon; secretary: Haddad; treasurer: Molina",
      "D) leader: Molina; secretary: Nash; treasurer: Haddad",
      "E) leader: Nash; secretary: Molina; treasurer: Haddad"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.\nQuestion:\nWhich one of the following could be the assignment of volunteers to Z?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvolunteers = EnumSort([Haddad, Joslin, Kwon, Molina, Nash])\ncommittees = EnumSort([X, Y, Z])\npositions = EnumSort([leader, secretary, treasurer])\nassign = Function([volunteers, committees] -> [bool])\n\n# Constraints\nForAll([v:volunteers], Count([c:committees], assign(v, c)) >= 1) ::: each volunteer is assigned to at least one committee\nAnd(assign(Nash, Z), Nash == leader(Z)) ::: Nash is the leader of Z\nAnd(assign(Molina, X), Count([v:volunteers], And(v != Molina, assign(v, X))) == 1) ::: Molina is assigned to exactly one committee\nAnd(assign(Kwon, Y), Kwon != treasurer(Y)) ::: Kwon is not the treasurer of Y\nAnd(assign(Joslin, Y), Joslin == secretary(Y)) ::: Joslin is the secretary of Y\n\n# Options\nQuestion ::: Which one of the following could be the assignment of volunteers to Z?\nis_valid(Exists([c:committees], assign(Haddad, c))) ::: (A)\nis_valid(Exists([c:committees], assign(Joslin, c))) ::: (B)\nis_valid(Exists([c:committees], assign(Kwon, c))) ::: (C)\nis_valid(Exists([c:committees], assign(Molina, c))) ::: (D)\nis_valid(Exists([c:committees], assign(Nash, c))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_4_19",
    "context": "Exactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.",
    "question": "If Kwon is assigned to be treasurer for exactly two of the committees, then any of the following could be true EXCEPT:",
    "answer": "C",
    "options": [
      "A) Haddad is assigned to be leader for Y.",
      "B) Haddad is assigned to be secretary for Z.",
      "C) Haddad is assigned to be treasurer for X.",
      "D) Molina is assigned to be treasurer for Z.",
      "E) Nash is assigned to be leader for Y."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.\nQuestion:\nIf Kwon is assigned to be treasurer for exactly two of the committees, then any of the following could be true EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvolunteers = EnumSort([Haddad, Joslin, Kwon, Molina, Nash])\ncommittees = EnumSort([X, Y, Z])\npositions = EnumSort([leader, secretary, treasurer])\nassign = Function([volunteers, committees] -> [bool])\n\n# Constraints\nForAll([t:volunteers], Count([c:committees], assign(t, c)) >= 1) ::: each volunteer is assigned to at least one committee\nAnd(assign(Nash, X), assign(Nash, Y) == leader) ::: Nash is the leader for both committees\nAnd(assign(Molina, X), assign(Molina, Y) == secretary) ::: Molina is the secretary for exactly one committee\nForAll([c:committees], Implies(assign(Kwon, c), Not(assign(Joslin, c)))) ::: Kwon is assigned to Y but cannot be assigned to Z\nForAll([c:committees], Implies(assign(Kwon, c), Not(assign(Joslin, c)))) ::: Joslin is the secretary for Y but cannot be assigned to X or Z\nForAll([c:committees], Implies(assign(Kwon, c), assign(Kwon, c) == treasurer)) ::: Kwon is assigned to exactly two of the committees\n\n# Options\nQuestion ::: ::: If Kwon is assigned to be treasurer for exactly two of the committees, then any of the following could be true EXCEPT:\nis_sat(ForAll([c:committees], assign(Kwon, c) == treasurer)) ::: (A)\nis_sat(ForAll([c:committees], assign(Kwon, c) == leader)) ::: (B)\nis_sat(ForAll([c:committees], assign(Kwon, c) == secretary)) ::: (C)\nis_sat(ForAll([c:committees], assign(Kwon, c) == member)) ::: (D)\nis_sat(ForAll([c:committees], assign(Kwon, c) == non_member)) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, it returns `True` if the given formula is satisfiable (i.e., can be made true) and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_4_20",
    "context": "Exactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.",
    "question": "Each of the following must be true EXCEPT:",
    "answer": "B",
    "options": [
      "A) Haddad is assigned to X.",
      "B) Haddad is assigned to Y.",
      "C) Kwon is assigned to X.",
      "D) Molina is assigned to Z.",
      "E) Nash is assigned to X."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.\nQuestion:\nEach of the following must be true EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvolunteers = EnumSort([Haddad, Joslin, Kwon, Molina, Nash])\ncommittees = EnumSort([X, Y, Z])\npositions = EnumSort([leader, secretary, treasurer])\nassign = Function([volunteers, committees] -> [bool])\n\n# Constraints\nForAll([v:volunteers], Count([c:committees], assign(v, c)) >= 1) ::: each volunteer is assigned to at least one committee\nAnd(assign(Nash, X), Nash.leader) ::: Nash is the leader for X\nAnd(assign(Molina, committee), Not(assign(Molina, Z))) ::: Molina is assigned to exactly one committee\nForAll([c:committees], Implies(assign(Joslin, c), Not(assign(Joslin, X)))) ::: Joslin is the secretary for Y but cannot be assigned to X or Z\nForAll([v:volunteers], Implies(assign(v, Y), Not(assign(v, Z)))) ::: Kwon must be assigned to Y but cannot be assigned to Z\n\n# Options\nQuestion ::: Each of the following must be true EXCEPT:\nis_sat(ForAll([v:volunteers], assign(v, Y) == assign(v, Z))) ::: (A)\nis_sat(ForAll([v:volunteers], assign(v, X) == assign(v, Y))) ::: (B)\nis_sat(ForAll([v:volunteers], assign(v, X) == assign(v, Z))) ::: (C)\nis_sat(ForAll([v:volunteers], assign(v, Y) == assign(v, Z))) ::: (D)\nis_sat(ForAll([v:volunteers], assign(v, X) == assign(v, Y))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_4_21",
    "context": "Exactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.",
    "question": "If Kwon is assigned to be leader for exactly one of the committees, then for which of the committees is the assignment of volunteers to positions fully determined?",
    "answer": "B",
    "options": [
      "A) X only",
      "B) Y only",
      "C) X and Y, but not Z",
      "D) Y and Z, but not X",
      "E) X and Z, but not Y"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.\nQuestion:\nIf Kwon is assigned to be leader for exactly one of the committees, then for which of the committees is the assignment of volunteers to positions fully determined?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvolunteers = EnumSort([Haddad, Joslin, Kwon, Molina, Nash])\ncommittees = EnumSort([X, Y, Z])\npositions = EnumSort([leader, secretary, treasurer])\nassign = Function([volunteers, committees] -> [positions])\n\n# Constraints\nForAll([v:volunteers], Count([c:committees], assign(v, c)) >= 1) ::: each volunteer is assigned to at least one committee\nAnd(assign(Nash, X), assign(Nash, Y) == leader) ::: Nash is assigned to a committee and is the leader for that committee\nAnd(assign(Molina, X), assign(Molina, Y) == secretary) ::: Molina is assigned to exactly one committee\nForAll([c:committees], Implies(assign(Kwon, c), Not(assign(Joslin, c)))) ::: Kwon is assigned to Y but cannot be assigned to Z\nImplies(assign(Kwon, X), Not(assign(Joslin, X))) ::: Joslin is the secretary for Y but cannot be assigned to X or Z\n\n# Options\nQuestion ::: Which of the following committees is the assignment of volunteers to positions fully determined if Kwon is assigned to be leader for exactly one of the committees?\nis_sat(ForAll([c:committees], assign(Kwon, c) == positions(leader))) ::: (A)\nis_sat(ForAll([c:committees], assign(Kwon, c) == positions(secretary))) ::: (B)\nis_sat(ForAll([c:committees], assign(Kwon, c) == positions(treasurer))) ::: (C)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_4_22",
    "context": "Exactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.",
    "question": "The assignment of volunteers to committees and positions is fully determined if which one of the following is true?",
    "answer": "C",
    "options": [
      "A) Haddad is assigned to be leader for exactly one of the committees.",
      "B) Haddad is assigned to be secretary for exactly two of the committees.",
      "C) Haddad is assigned to be treasurer for all three of the committees.",
      "D) Kwon is assigned to be treasurer for exactly two of the committees.",
      "E) Nash is assigned to be leader for all three of the committees."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.\nQuestion:\nThe assignment of volunteers to committees and positions is fully determined if which one of the following is true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvolunteers = EnumSort([Haddad, Joslin, Kwon, Molina, Nash])\ncommittees = EnumSort([X, Y, Z])\npositions = EnumSort([leader, secretary, treasurer])\nassign = Function([volunteers, committees] -> [positions])\n\n# Constraints\nForAll([v:volunteers], ForAll([c:committees], assign(v, c) != assign(v, c))) ::: Each volunteer is assigned to a different committee\nAnd(assign(Nash, X), assign(Nash, Y) == leader) ::: Nash is the leader for X and Y\nAnd(assign(Molina, X), assign(Molina, Y) == secretary) ::: Molina is the secretary for X and Y\nAnd(assign(Kwon, Y), assign(Kwon, Z) != treasurer) ::: Kwon is assigned to Y but cannot be assigned to Z\nForAll([v:volunteers], Implies(assign(v, Y), Not(assign(v, X) or assign(v, Z)))) ::: Joslin is the secretary for Y but cannot be assigned to X or Z\n\n# Options\nQuestion ::: The assignment of volunteers to committees and positions is fully determined if which one of the following is true?\nis_sat(ForAll([v:volunteers], ForAll([c:committees], assign(v, c) == positions(v, c)))) ::: (A)\nis_sat(ForAll([v:volunteers], ForAll([c:committees], assign(v, c) == positions(v, c) && assign(Nash, X) == leader))) ::: (B)\nis_sat(ForAll([v:volunteers], ForAll([c:committees], assign(v, c) == positions(v, c) && assign(Molina, X) == secretary))) ::: (C)\nis_sat(ForAll([v:volunteers], ForAll([c:committees], assign(v, c) == positions(v, c) && assign(Kwon, Y) == treasurer))) ::: (D)\nis_sat(ForAll([v:volunteers], ForAll([c:committees], assign(v, c) == positions(v, c) && assign(Joslin, Y) == secretary))) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, it returns `True` if the given formula is satisfiable (i.e., can be made true) and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201512_3-G_4_23",
    "context": "Exactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.",
    "question": "Which one of the following, if substituted for the condition that Molina must be assigned to exactly one committee, would have the same effect in determining the assignment of volunteers to committees?",
    "answer": "C",
    "options": [
      "A) Haddad must be assigned to more committees than Molina.",
      "B) Joslin must be assigned to more committees than Molina.",
      "C) Kwon must be assigned to more committees than Molina.",
      "D) Molina must be assigned to more committees than Haddad.",
      "E) Nash must be assigned to more committees than Molina."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nExactly five volunteers—Haddad, Joslin, Kwon, Molina, and Nash—are being assigned to three community committees—X, Y, and Z. Each committee will have three volunteers assigned to it, with each volunteer on a committee holding exactly one of three positions—leader, secretary, or treasurer. The following conditions apply: If Nash is assigned to a committee, Nash must be the leader for that committee. Molina must be assigned to exactly one committee. Kwon must be assigned to Y but cannot be assigned to Z. Joslin must be the secretary for Y but cannot be assigned to X or Z.\nQuestion:\nWhich one of the following, if substituted for the condition that Molina must be assigned to exactly one committee, would have the same effect in determining the assignment of volunteers to committees?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nvolunteers = EnumSort([Haddad, Joslin, Kwon, Molina, Nash])\ncommittees = EnumSort([X, Y, Z])\npositions = EnumSort([leader, secretary, treasurer])\nassign = Function([volunteers, committees] -> [bool])\n\n# Constraints\nForAll([v:volunteers], Count([c:committees], assign(v, c)) >= 1) ::: each volunteer is assigned to at least one committee\nAnd(assign(Nash, X), assign(Nash, Y) == leader) ::: Nash is the leader for X and Y\nAnd(assign(Molina, committee) == (Molina == committee == Y)) ::: Molina must be assigned to exactly one committee\nOr(assign(Kwon, committee) == (Kwon == committee == Y), assign(Kwon, Z) == secretary) ::: Kwon must be assigned to Y but cannot be assigned to Z\nOr(assign(Joslin, committee) == (Joslin == committee == Y), assign(Joslin, X) == secretary) ::: Joslin must be the secretary for Y but cannot be assigned to X or Z\n\n# Options\nQuestion ::: Which one of the following, if substituted for the condition that Molina must be assigned to exactly one committee, would have the same effect in determining the assignment of volunteers to committees?\nis_sat(ForAll([v:volunteers], assign(v, X) == assign(v, Y))) ::: (A)\nis_sat(ForAll([v:volunteers], assign(v, Y) == assign(v, Z))) ::: (B)\nis_sat(ForAll([v:volunteers], assign(v, Y) == assign(v, X))) ::: (C)\nis_sat(ForAll([v:volunteers], assign(v, X) == assign(v, Z))) ::: (D)\nis_sat(ForAll([v:volunteers], assign(v, X) == assign(v, Y))) ::: (E)\n\n------\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_1_1",
    "context": "In one week—Monday through Friday—a library's bookmobile will visit five of the following six neighborhoods—Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, and Sunnyside. Exactly one neighborhood will be visited on each of the five days, and none of the neighborhoods will be visited on more than one day. The bookmobile's schedule must conform to the following conditions: Hidden Hills is visited, but not on Friday. If Oldtown is visited, then it is visited on the day immediately before Hidden Hills is visited. If Lakeville is visited, then it is visited on Wednesday. Nottingham and Sunnyside are both visited, but not on consecutive days.",
    "question": "The five neighborhoods visited by the bookmobile, listed in order from Monday through Friday, could be",
    "answer": "B",
    "options": [
      "A) Nottingham, Lakeville, Oldtown, Hidden Hills, and Sunnyside",
      "B) Nottingham, Oldtown, Hidden Hills, Sunnyside, and Park Plaza",
      "C) Oldtown, Hidden Hills, Lakeville, Nottingham, and Sunnyside",
      "D) Sunnyside, Oldtown, Lakeville, Hidden Hills, and Nottingham",
      "E) Sunnyside, Park Plaza, Nottingham, Oldtown, and Hidden Hills"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nIn one week—Monday through Friday—a library's bookmobile will visit five of the following six neighborhoods—Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, and Sunnyside. Exactly one neighborhood will be visited on each of the five days, and none of the neighborhoods will be visited on more than one day. The bookmobile's schedule must conform to the following conditions: Hidden Hills is visited, but not on Friday. If Oldtown is visited, then it is visited on the day immediately before Hidden Hills is visited. If Lakeville is visited, then it is visited on Wednesday. Nottingham and Sunnyside are both visited, but not on consecutive days.\nQuestion:\nThe five neighborhoods visited by the bookmobile, listed in order from Monday through Friday, could be\nChoices:\n[[CHOICES]]\n###\n# Declarations\nneighborhoods = EnumSort([Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, Sunnyside])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nvisits = Function([days, neighborhoods] -> [bool])\n\n# Constraints\nForAll([d:days], ForAll([n:neighborhoods], visits(d, n))) ::: each neighborhood is visited exactly once during the week\nAnd(visits(Monday, Hidden Hills), visits(Tuesday, Nottingham)) ::: Hidden Hills is visited, but not on Friday\nAnd(visits(Wednesday, Lakeville), visits(Thursday, Oldtown)) ::: If Oldtown is visited, then it is visited on the day immediately before Hidden Hills is visited\nAnd(visits(Wednesday, Lakeville), visits(Thursday, Sunnyside)) ::: Nottingham and Sunnyside are both visited, but not on consecutive days\n\n# Options\nQuestion ::: The five neighborhoods visited by the bookmobile, listed in order from Monday through Friday, could be\nis_valid(Exists([d:days], visits(d, Hidden Hills))) ::: (A)\nis_valid(Exists([d:days], visits(d, Nottingham))) ::: (B)\nis_valid(Exists([d:days], visits(d, Oldtown))) ::: (C)\nis_valid(Exists([d:days], visits(d, Park Plaza))) ::: (D)\nis_valid(Exists([d:days], visits(d, Sunnyside))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_1_2",
    "context": "In one week—Monday through Friday—a library's bookmobile will visit five of the following six neighborhoods—Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, and Sunnyside. Exactly one neighborhood will be visited on each of the five days, and none of the neighborhoods will be visited on more than one day. The bookmobile's schedule must conform to the following conditions: Hidden Hills is visited, but not on Friday. If Oldtown is visited, then it is visited on the day immediately before Hidden Hills is visited. If Lakeville is visited, then it is visited on Wednesday. Nottingham and Sunnyside are both visited, but not on consecutive days.",
    "question": "Which one of the following neighborhoods CANNOT be visited on Thursday?",
    "answer": "C",
    "options": [
      "A) Hidden Hills",
      "B) Nottingham",
      "C) Oldtown",
      "D) Park Plaza",
      "E) Sunnyside"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nIn one week—Monday through Friday—a library's bookmobile will visit five of the following six neighborhoods—Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, and Sunnyside. Exactly one neighborhood will be visited on each of the five days, and none of the neighborhoods will be visited on more than one day. The bookmobile's schedule must conform to the following conditions: Hidden Hills is visited, but not on Friday. If Oldtown is visited, then it is visited on the day immediately before Hidden Hills is visited. If Lakeville is visited, then it is visited on Wednesday. Nottingham and Sunnyside are both visited, but not on consecutive days.\nQuestion:\nWhich one of the following neighborhoods CANNOT be visited on Thursday?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nneighborhoods = EnumSort([Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, Sunnyside])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nvisits = Function([days, neighborhoods] -> [bool])\n\n# Constraints\nForAll([d:days], ForAll([n:neighborhoods], visits(d, n))) ::: each neighborhood is visited exactly once during the week\nAnd(visits(Monday, Hidden Hills), visits(Tuesday, Nottingham)) ::: Hidden Hills is visited, but not on Friday\nAnd(visits(Wednesday, Lakeville), visits(Thursday, Oldtown)) ::: Lakeville is visited on Wednesday\nAnd(visits(Thursday, Sunnyside), visits(Friday, Nottingham)) ::: Sunnyside is visited on Thursday\n\n# Options\nQuestion ::: Which one of the following neighborhoods CANNOT be visited on Thursday?\nis_valid(ForAll([n:neighborhoods], visits(Thursday, n) == False)) ::: (A)\nis_valid(ForAll([n:neighborhoods], visits(Thursday, n) == True)) ::: (B)\nis_valid(ForAll([n:neighborhoods], visits(Thursday, n) == False) Or visits(Thursday, n) == True) ::: (C)\nis_valid(ForAll([n:neighborhoods], visits(Thursday, n) == False) And visits(Thursday, n) == True) ::: (D)\nis_valid(ForAll([n:neighborhoods], visits(Thursday, n) == False) Or visits(Thursday, n) == False) ::: (E)\n\n------\n\nNote: The problem and question statements are given in a logical form, which is a standard way of representing problems in logic programming. The goal is to write the problem and question in a way that can be solved using logical reasoning and inference. The three parts of a logic program are:\n\n1. Declarations: This section defines the variables and functions that are used in the problem and question.\n2. Constraints: This section specifies the constraints that must be satisfied by the solution to the problem.\n3. Options: This section defines the possible solutions to the question.\n\nIn each part, we use logical operators such as `ForAll`, `And`, `Implies`, and `Or` to define the constraints and options. The `is_valid` function is used to check whether a given solution satisfies the constraints and options."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_1_3",
    "context": "In one week—Monday through Friday—a library's bookmobile will visit five of the following six neighborhoods—Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, and Sunnyside. Exactly one neighborhood will be visited on each of the five days, and none of the neighborhoods will be visited on more than one day. The bookmobile's schedule must conform to the following conditions: Hidden Hills is visited, but not on Friday. If Oldtown is visited, then it is visited on the day immediately before Hidden Hills is visited. If Lakeville is visited, then it is visited on Wednesday. Nottingham and Sunnyside are both visited, but not on consecutive days.",
    "question": "If Hidden Hills is visited on Monday, which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) Lakeville is visited on Wednesday.",
      "B) Nottingham is visited on Tuesday.",
      "C) Park Plaza is visited on Thursday.",
      "D) Sunnyside is visited on Tuesday.",
      "E) Sunnyside is visited on Friday"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nIn one week—Monday through Friday—a library's bookmobile will visit five of the following six neighborhoods—Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, and Sunnyside. Exactly one neighborhood will be visited on each of the five days, and none of the neighborhoods will be visited on more than one day. The bookmobile's schedule must conform to the following conditions: Hidden Hills is visited, but not on Friday. If Oldtown is visited, then it is visited on the day immediately before Hidden Hills is visited. If Lakeville is visited, then it is visited on Wednesday. Nottingham and Sunnyside are both visited, but not on consecutive days.\nQuestion:\nIf Hidden Hills is visited on Monday, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nneighborhoods = EnumSort([Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, Sunnyside])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nvisits = Function([days, neighborhoods] -> [bool])\n\n# Constraints\nForAll([d:days], ForAll([n:neighborhoods], visits(d, n))) ::: each neighborhood is visited exactly once during the week\nAnd(visits(Monday, Hidden Hills), Not(visits(Friday, Hidden Hills))) ::: Hidden Hills is visited on Monday but not on Friday\nOr(visits(Wednesday, Lakeville), visits(Thursday, Nottingham)) ::: Lakeville is visited on Wednesday or Nottingham is visited on Thursday\nOr(visits(Tuesday, Nottingham), visits(Wednesday, Sunnyside)) ::: Nottingham is visited on Tuesday or Sunnyside is visited on Wednesday\n\n# Options\nQuestion ::: Which one of the following must be true if Hidden Hills is visited on Monday?\nis_valid(ForAll([d:days], visits(d, Hidden Hills) == True)) ::: (A)\nis_valid(ForAll([d:days], visits(d, Hidden Hills) == False)) ::: (B)\nis_valid(ForAll([d:days], visits(d, Nottingham) == True)) ::: (C)\nis_valid(ForAll([d:days], visits(d, Sunnyside) == True)) ::: (D)\nis_valid(ForAll([d:days], visits(d, Oldtown) == True)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_1_4",
    "context": "In one week—Monday through Friday—a library's bookmobile will visit five of the following six neighborhoods—Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, and Sunnyside. Exactly one neighborhood will be visited on each of the five days, and none of the neighborhoods will be visited on more than one day. The bookmobile's schedule must conform to the following conditions: Hidden Hills is visited, but not on Friday. If Oldtown is visited, then it is visited on the day immediately before Hidden Hills is visited. If Lakeville is visited, then it is visited on Wednesday. Nottingham and Sunnyside are both visited, but not on consecutive days.",
    "question": "If Hidden Hills is visited on Wednesday, which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) Nottingham is visited on Monday.",
      "B) Oldtown is visited on Tuesday.",
      "C) Park Plaza is visited on Friday.",
      "D) Sunnyside is visited on Monday.",
      "E) Sunnyside is visited on Thursday"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nIn one week—Monday through Friday—a library's bookmobile will visit five of the following six neighborhoods—Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, and Sunnyside. Exactly one neighborhood will be visited on each of the five days, and none of the neighborhoods will be visited on more than one day. The bookmobile's schedule must conform to the following conditions: Hidden Hills is visited, but not on Friday. If Oldtown is visited, then it is visited on the day immediately before Hidden Hills is visited. If Lakeville is visited, then it is visited on Wednesday. Nottingham and Sunnyside are both visited, but not on consecutive days.\nQuestion:\nIf Hidden Hills is visited on Wednesday, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nneighborhoods = EnumSort([Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, Sunnyside])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nvisits = Function([days, neighborhoods] -> [bool])\n\n# Constraints\nForAll([d:days], ForAll([n:neighborhoods], visits(d, n))) ::: each neighborhood is visited exactly once during the week\nAnd(visits(Monday, Hidden Hills), visits(Tuesday, Nottingham)) ::: Hidden Hills is visited on Wednesday\nAnd(visits(Wednesday, Lakeville), visits(Thursday, Oldtown)) ::: Lakeville is visited on Wednesday\nAnd(visits(Thursday, Sunnyside), visits(Friday, Park Plaza)) ::: Sunnyside is visited on Thursday\n\n# Options\nQuestion ::: If Hidden Hills is visited on Wednesday, which one of the following must be true?\nis_valid(ForAll([d:days], visits(d, Hidden Hills) == visits(d, Nottingham))) ::: (A)\nis_valid(ForAll([d:days], visits(d, Hidden Hills) == visits(d, Oldtown))) ::: (B)\nis_valid(ForAll([d:days], visits(d, Hidden Hills) == visits(d, Sunnyside))) ::: (C)\nis_valid(ForAll([d:days], visits(d, Hidden Hills) == visits(d, Lakeville))) ::: (D)\nis_valid(ForAll([d:days], visits(d, Hidden Hills) == visits(d, Park Plaza))) ::: (E)\n\n------\n\nNote: The problem and question are given in a logical form, which is a standard way of representing problems in logic programming. The problem is defined using three parts: Declarations, Constraints, and Options. The Declarations part defines the variables and functions used in the problem, the Constraints part defines the constraints that must be satisfied, and the Options part defines the possible options for the problem. The question is then formulated as a logical formula, which is a statement that must be true or false depending on the values of the variables and the satisfaction of the constraints."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_1_5",
    "context": "In one week—Monday through Friday—a library's bookmobile will visit five of the following six neighborhoods—Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, and Sunnyside. Exactly one neighborhood will be visited on each of the five days, and none of the neighborhoods will be visited on more than one day. The bookmobile's schedule must conform to the following conditions: Hidden Hills is visited, but not on Friday. If Oldtown is visited, then it is visited on the day immediately before Hidden Hills is visited. If Lakeville is visited, then it is visited on Wednesday. Nottingham and Sunnyside are both visited, but not on consecutive days.",
    "question": "If Nottingham is visited on Thursday, which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Hidden Hills is visited on Wednesday.",
      "B) Lakeville is visited on Wednesday.",
      "C) Oldtown is visited on Monday.",
      "D) Park Plaza is visited on Friday.",
      "E) Sunnyside is visited on Tuesday."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nIn one week—Monday through Friday—a library's bookmobile will visit five of the following six neighborhoods—Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, and Sunnyside. Exactly one neighborhood will be visited on each of the five days, and none of the neighborhoods will be visited on more than one day. The bookmobile's schedule must conform to the following conditions: Hidden Hills is visited, but not on Friday. If Oldtown is visited, then it is visited on the day immediately before Hidden Hills is visited. If Lakeville is visited, then it is visited on Wednesday. Nottingham and Sunnyside are both visited, but not on consecutive days.\nQuestion:\nIf Nottingham is visited on Thursday, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nneighborhoods = EnumSort([Hidden Hills, Lakeville, Nottingham, Oldtown, Park Plaza, Sunnyside])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nvisits = Function([days, neighborhoods] -> [bool])\n\n# Constraints\nForAll([d:days], ForAll([n:neighborhoods], visits(d, n))) ::: each neighborhood is visited exactly once during the week\nAnd(visits(Monday, Hidden Hills), visits(Tuesday, Nottingham)) ::: Hidden Hills is visited, but not on Friday\nAnd(visits(Wednesday, Lakeville), visits(Thursday, Oldtown)) ::: Lakeville is visited on Wednesday\nAnd(visits(Thursday, Nottingham), visits(Friday, Sunnyside)) ::: Nottingham is visited on Thursday\n\n# Options\nQuestion ::: If Nottingham is visited on Thursday, which one of the following must be true?\nis_valid(ForAll([d:days], visits(d, Nottingham) == True)) ::: (A)\nis_valid(ForAll([d:days], visits(d, Nottingham) == False)) ::: (B)\nis_valid(ForAll([d:days], visits(d, Oldtown) == True)) ::: (C)\nis_valid(ForAll([d:days], visits(d, Oldtown) == False)) ::: (D)\nis_valid(ForAll([d:days], visits(d, Park Plaza) == True)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_2_6",
    "context": "Six park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.",
    "question": "Which one of the following is a permissible assignment of rangers to park areas?",
    "answer": "E",
    "options": [
      "A) area 1: Jefferson, Koguchi; area 2: Larson, Olsen; area 3: Mendez, Pruitt",
      "B) area 1: Koguchi, Larson; area 2: Olsen, Pruitt; area 3: Jefferson, Mendez",
      "C) area 1: Koguchi, Pruitt; area 2: Jefferson; area 3: Larson, Mendez, Olsen",
      "D) area 1: Jefferson, Koguchi, Larson; area 2: Mendez, Olsen; area 3: Pruitt",
      "E) area 1: Jefferson, Koguchi, Larson; area 2: Olsen, Pruitt; area 3: Mendez"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.\nQuestion:\nWhich one of the following is a permissible assignment of rangers to park areas?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nrangers = EnumSort([Jefferson, Koguchi, Larson, Mendez, Olsen, Pruitt])\nareas = EnumSort([area_1, area_2, area_3])\nassignment = Function([rangers, areas] -> [bool])\n\n# Constraints\nForAll([r:rangers], Count([a:areas], assignment(r, a)) >= 1) ::: each ranger monitors at least one area\nAnd(assignment(Mendez, area_3), Count([r:rangers], And(r != Mendez, assignment(r, area_3))) == 1) ::: Mendez is assigned to area 3\nForAll([r:rangers], Implies(assignment(Olsen, area_2), Not(assignment(Jefferson, area_1)))) ::: if Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi\nForAll([r:rangers], Implies(assignment(Olsen, area_2), assignment(Jefferson, area_1) == assignment(Koguchi, area_2))) ::: if Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi\n\n# Options\nQuestion ::: Which one of the following is a permissible assignment of rangers to park areas?\nis_sat(ForAll([r:rangers], assignment(r, area_1) == assignment(Koguchi, area_1))) ::: (A)\nis_sat(ForAll([r:rangers], assignment(r, area_2) == assignment(Olsen, area_2))) ::: (B)\nis_sat(ForAll([r:rangers], assignment(r, area_3) == assignment(Mendez, area_3))) ::: (C)\nis_sat(ForAll([r:rangers], assignment(r, area_1) == assignment(Jefferson, area_1))) ::: (D)\nis_sat(ForAll([r:rangers], assignment(r, area_2) == assignment(Pruitt, area_2))) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, it returns `True` if the given formula is satisfiable (i.e., there exists an assignment of values that makes the formula true), and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_2_7",
    "context": "Six park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.",
    "question": "If Olsen is the sole ranger assigned to area 2, then which one of the following could be the complete assignment of rangers to area 3?",
    "answer": "C",
    "options": [
      "A) Mendez",
      "B) Larson, Mendez",
      "C) Mendez, Pruitt",
      "D) Jefferson, Koguchi, Mendez",
      "E) Jefferson, Mendez, Pruitt"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.\nQuestion:\nIf Olsen is the sole ranger assigned to area 2, then which one of the following could be the complete assignment of rangers to area 3?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nrangers = EnumSort([Jefferson, Koguchi, Larson, Mendez, Olsen, Pruitt])\nareas = EnumSort([area_1, area_2, area_3])\nassignment = Function([rangers, areas] -> [Set])\n\n# Constraints\nForAll([r:rangers], Count([a:areas], r.assigned(a)) >= 1) ::: each ranger is assigned to at least one area\nAnd(Count([a:areas], r.assigned(a)) <= 3) ::: at most three rangers are assigned to each area\nMendez.assigned(area_3) ::: Mendez is assigned to area 3\nNeither(Olsen, Pruitt).assigned(area_1) ::: neither Olsen nor Pruitt is assigned to area 1\nForAll([r:rangers], Implies(r.assigned(area_2), (Jefferson.assigned(area_1) if Olsen.assigned(area_2) else Jefferson.assigned(area_2)))) ::: Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both\nIf(Olsen.assigned(area_2), Jefferson.assigned(area_1) if Koguchi.assigned(area_2) else Jefferson.assigned(area_3)), ::: Jefferson is assigned to the same area as Koguchi if Olsen is assigned to area 2\n\n# Options\nQuestion ::: Which one of the following could be the complete assignment of rangers to area 3?\nis_valid(Exists([r:rangers], assignment(r, area_3) == [[Jefferson, Koguchi, Mendez]])) ::: (A)\nis_valid(Exists([r:rangers], assignment(r, area_3) == [[Koguchi, Mendez, Olsen]])) ::: (B)\nis_valid(Exists([r:rangers], assignment(r, area_3) == [[Mendez, Olsen, Pruitt]])) ::: (C)\nis_valid(Exists([r:rangers], assignment(r, area_3) == [[Jefferson, Larson, Mendez]])) ::: (D)\nis_valid(Exists([r:rangers], assignment(r, area_3) == [[Koguchi, Larson, Olsen]])) ::: (E)\n\n------\n\nNote: The problem and question statements are given in a logical form, which means that they are written in a formal language that can be processed by a logic solver. The logic solver will be able to determine the validity of the problem and the options based on the constraints and the logic formulas."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_2_8",
    "context": "Six park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.",
    "question": "If exactly one ranger is assigned to area 1, then which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Jefferson is assigned to area 1.",
      "B) Koguchi is assigned to area 2.",
      "C) Larson is assigned to area 3.",
      "D) Olsen is assigned to area 3.",
      "E) Pruitt is assigned to area 2."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.\nQuestion:\nIf exactly one ranger is assigned to area 1, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nrangers = EnumSort([Jefferson, Koguchi, Larson, Mendez, Olsen, Pruitt])\nareas = EnumSort([area_1, area_2, area_3])\nassignment = Function([rangers, areas] -> [bool])\n\n# Constraints\nForAll([r:rangers], Count([a:areas], assignment(r, a)) >= 1) ::: each ranger monitors at least one area\nAnd(assignment(Mendez, area_3), Count([r:rangers], And(r != Mendez, assignment(r, area_3))) == 1) ::: Mendez is assigned to area 3\nForAll([r:rangers], Implies(assignment(Olsen, area_2), Not(assignment(Jefferson, area_1)))) ::: if Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi\n\n# Options\nQuestion ::: Which one of the following must be true if exactly one ranger is assigned to area 1?\nis_valid(ForAll([r:rangers], assignment(r, area_1) == assignment(Koguchi, area_1))) ::: (A)\nis_valid(ForAll([r:rangers], assignment(r, area_1) == assignment(Mendez, area_3))) ::: (B)\nis_valid(ForAll([r:rangers], assignment(r, area_1) == assignment(Olsen, area_2))) ::: (C)\nis_valid(ForAll([r:rangers], assignment(r, area_1) == assignment(Pruitt, area_3))) ::: (D)\nis_valid(ForAll([r:rangers], assignment(r, area_1) == assignment(Larson, area_2))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_2_9",
    "context": "Six park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.",
    "question": "Which one of the following rangers CANNOT be assigned to area 3?",
    "answer": "D",
    "options": [
      "A) Pruitt",
      "B) Olsen",
      "C) Larson",
      "D) Koguchi",
      "E) Jefferson"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.\nQuestion:\nWhich one of the following rangers CANNOT be assigned to area 3?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nrangers = EnumSort([Jefferson, Koguchi, Larson, Mendez, Olsen, Pruitt])\nareas = EnumSort([area_1, area_2, area_3])\nassignment = Function([rangers, areas] -> [bool])\n\n# Constraints\nForAll([r:rangers], Count([a:areas], assignment(r, a)) >= 1) ::: each ranger monitors at least one area\nAnd(assignment(Mendez, area_3), Count([r:rangers], And(r != Mendez, assignment(r, area_3))) == 1) ::: Mendez is assigned to area 3\nForAll([r:rangers], Implies(assignment(Olsen, area_2), Not(assignment(Jefferson, area_1)))) ::: if Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi\n\n# Options\nQuestion ::: Which one of the following rangers CANNOT be assigned to area 3?\nis_valid(Exists([r:rangers], assignment(r, area_3) == False)) ::: (A)\nis_valid(Exists([r:rangers], assignment(r, area_3) == True)) ::: (B)\nis_valid(Exists([r:rangers], assignment(r, area_3) == Jefferson)) ::: (C)\nis_valid(Exists([r:rangers], assignment(r, area_3) == Koguchi)) ::: (D)\nis_valid(Exists([r:rangers], assignment(r, area_3) == Pruitt)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_2_10",
    "context": "Six park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.",
    "question": "If Koguchi is assigned to area 2, then which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Jefferson is assigned to area 2.",
      "B) Jefferson is assigned to area 3.",
      "C) Larson is assigned to area 1.",
      "D) Olsen is assigned to area 2.",
      "E) Pruitt is assigned to area 3"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.\nQuestion:\nIf Koguchi is assigned to area 2, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nrangers = EnumSort([Jefferson, Koguchi, Larson, Mendez, Olsen, Pruitt])\nareas = EnumSort([area_1, area_2, area_3])\nassignment = Function([rangers, areas] -> [bool])\n\n# Constraints\nForAll([r:rangers], Count([a:areas], assignment(r, a)) >= 1) ::: each ranger monitors at least one area\nAnd(assignment(Mendez, area_3), Count([r:rangers], And(r != Mendez, assignment(r, area_3))) == 1) ::: Mendez is assigned to area 3\nForAll([r:rangers], Implies(assignment(Olsen, area_2), Not(assignment(Jefferson, area_2)))) ::: if Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi\nForAll([r:rangers], Implies(assignment(Pruitt, area_1), Not(assignment(Koguchi, area_1)))) ::: if Pruitt is assigned to area 1, then Koguchi is assigned to a different area than Pruitt\n\n# Options\nQuestion ::: Which one of the following could be true if Koguchi is assigned to area 2?\nis_sat(ForAll([r:rangers], assignment(Koguchi, area_2) == assignment(Larson, area_2))) ::: (A)\nis_sat(ForAll([r:rangers], assignment(Koguchi, area_2) == assignment(Mendez, area_3))) ::: (B)\nis_sat(ForAll([r:rangers], assignment(Koguchi, area_2) == assignment(Olsen, area_2))) ::: (C)\nis_sat(ForAll([r:rangers], assignment(Koguchi, area_2) == assignment(Pruitt, area_1))) ::: (D)\nis_sat(ForAll([r:rangers], assignment(Koguchi, area_2) == assignment(Jefferson, area_1))) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, it returns `True` if the given formula is satisfiable (i.e., can be made true) and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_2_11",
    "context": "Six park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.",
    "question": "If Larson and Olsen are assigned to the same area, then which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) Jefferson is assigned to area 3.",
      "B) Koguchi is assigned to area 2.",
      "C) Larson is assigned to area 1.",
      "D) Olsen is assigned to area 2.",
      "E) Pruitt is assigned to area 3"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.\nQuestion:\nIf Larson and Olsen are assigned to the same area, then which one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nrangers = EnumSort([Jefferson, Koguchi, Larson, Mendez, Olsen, Pruitt])\nareas = EnumSort([area_1, area_2, area_3])\nassignment = Function([rangers, areas] -> [bool])\n\n# Constraints\nForAll([r:rangers], Count([a:areas], assignment(r, a)) >= 1) ::: each ranger monitors at least one area\nAnd(assignment(Mendez, area_3), Count([r:rangers], And(r != Mendez, assignment(r, area_3))) == 1) ::: Mendez is assigned to area 3\nForAll([r:rangers], Implies(assignment(Olsen, area_2), Not(assignment(Jefferson, area_1)))) ::: if Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi\n\n# Options\nQuestion ::: If Larson and Olsen are assigned to the same area, then which one of the following could be true?\nis_valid(Exists([a:areas], assignment(Larson, a) == assignment(Olsen, a))) ::: (A)\nis_valid(Exists([a:areas], assignment(Olsen, a) == assignment(Mendez, a))) ::: (B)\nis_valid(Exists([a:areas], assignment(Larson, a) == assignment(Koguchi, a))) ::: (C)\nis_valid(Exists([a:areas], assignment(Olsen, a) == assignment(Jefferson, a))) ::: (D)\nis_valid(Exists([a:areas], assignment(Larson, a) == assignment(Pruitt, a))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_2_12",
    "context": "Six park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.",
    "question": "If Jefferson is assigned to area 2, then which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) Koguchi is assigned to area 1.",
      "B) Larson is assigned to area 1.",
      "C) Olsen is assigned to area 2.",
      "D) Pruitt is assigned to area 2.",
      "E) Pruitt is assigned to area 3"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nSix park rangers—Jefferson, Koguchi, Larson, Mendez, Olsen, and Pruitt—are each to be assigned to monitor one of three areas—area 1, area 2, and area 3—in a national park. At least one ranger, but no more than three, is assigned to each area. The assignment must conform to the following conditions: Mendez is assigned to area 3. Neither Olsen nor Pruitt is assigned to area 1. Larson is assigned to the same area as either Koguchi or Mendez but not to the same area as both. If Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi; otherwise, Jefferson is assigned to a different area than Koguchi.\nQuestion:\nIf Jefferson is assigned to area 2, then which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\nrangers = EnumSort([Jefferson, Koguchi, Larson, Mendez, Olsen, Pruitt])\nareas = EnumSort([area_1, area_2, area_3])\nassignment = Function([rangers, areas] -> [bool])\n\n# Constraints\nForAll([r:rangers], Count([a:areas], assignment(r, a)) >= 1) ::: each ranger monitors at least one area\nAnd(assignment(Mendez, area_3), Count([r:rangers], And(r != Mendez, assignment(r, area_3))) == 1) ::: Mendez is assigned to area 3\nForAll([r:rangers], Implies(assignment(Olsen, area_2), Not(assignment(Jefferson, area_1)))) ::: if Olsen is assigned to area 2, then Jefferson is assigned to the same area as Koguchi\nForAll([r:rangers], Implies(assignment(Jefferson, area_2), Not(assignment(Koguchi, area_1)))) ::: otherwise, Jefferson is assigned to a different area than Koguchi\n\n# Options\nQuestion ::: ::: If Jefferson is assigned to area 2, then which one of the following must be true?\nis_sat(ForAll([r:rangers], assignment(Jefferson, area_2) == assignment(Koguchi, area_1))) ::: (A)\nis_sat(ForAll([r:rangers], assignment(Koguchi, area_1) == assignment(Mendez, area_3))) ::: (B)\nis_sat(ForAll([r:rangers], assignment(Koguchi, area_1) == assignment(Olsen, area_2))) ::: (C)\nis_sat(ForAll([r:rangers], assignment(Mendez, area_3) == assignment(Olsen, area_2))) ::: (D)\nis_sat(ForAll([r:rangers], assignment(Olsen, area_2) == assignment(Pruitt, area_3))) ::: (E)\n\n------\n\nNote: The `is_sat` function is a built-in Satisfiability checker in the solver, it returns `True` if the given formula is satisfiable (i.e., can be made true) and `False` otherwise."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_3_13",
    "context": "An economics department is assigning six teaching assistants—Ramos, Smith, Taj, Vogel, Yi, and Zane—to three courses—Labor, Markets, and Pricing. Each assistant will be assigned to exactly one course, and each course will have at least one assistant assigned to it. The assignment of assistants to courses is subject to the following conditions: Markets must have exactly two assistants assigned to it. Smith and Taj must be assigned to the same course as each other. Vogel and Yi cannot be assigned to the same course as each other. Yi and Zane must both be assigned to Pricing if either one of them is.",
    "question": "Which one of the following could be the complete assignment of assistants to Pricing?",
    "answer": "A",
    "options": [
      "A) Ramos, Yi, and Zane",
      "B) Smith, Taj, and Yi",
      "C) Smith, Taj, Yi, and Zane",
      "D) Taj, Yi, and Zane",
      "E) Vogel, Yi, and Zane"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAn economics department is assigning six teaching assistants—Ramos, Smith, Taj, Vogel, Yi, and Zane—to three courses—Labor, Markets, and Pricing. Each assistant will be assigned to exactly one course, and each course will have at least one assistant assigned to it. The assignment of assistants to courses is subject to the following conditions: Markets must have exactly two assistants assigned to it. Smith and Taj must be assigned to the same course as each other. Vogel and Yi cannot be assigned to the same course as each other. Yi and Zane must both be assigned to Pricing if either one of them is.\nQuestion:\nWhich one of the following could be the complete assignment of assistants to Pricing?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Ramos, Smith, Taj, Vogel, Yi, Zane])\ncourses = EnumSort([Labor, Markets, Pricing])\nassign = Function([people, courses] -> [bool])\n\n# Constraints\nForAll([p:people], Count([c:courses], assign(p, c)) >= 1) ::: each person is assigned to at least one course\nAnd(Count([c:courses], assign(Markets, c)) >= 2) ::: Markets must have exactly two assistants assigned to it\nForAll([p:people], Implies(assign(p, Labor), assign(Smith, Labor))) ::: Smith and Taj must be assigned to the same course as each other\nForAll([p:people], Implies(assign(Vogel, Markets), assign(Yi, Markets))) ::: Vogel and Yi cannot be assigned to the same course as each other\nForAll([p:people], Or(assign(Yi, Pricing), assign(Zane, Pricing))) ::: Yi and Zane must both be assigned to Pricing if either one of them is\n\n# Options\nQuestion ::: Which one of the following could be the complete assignment of assistants to Pricing?\nis_valid(Exists([p:people], assign(p, Pricing))) ::: (A)\nis_valid(Exists([p:people], assign(Taj, Pricing))) ::: (B)\nis_valid(Exists([p:people], assign(Vogel, Pricing))) ::: (C)\nis_valid(Exists([p:people], assign(Yi, Pricing))) ::: (D)\nis_valid(Exists([p:people], assign(Zane, Pricing))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_3_14",
    "context": "An economics department is assigning six teaching assistants—Ramos, Smith, Taj, Vogel, Yi, and Zane—to three courses—Labor, Markets, and Pricing. Each assistant will be assigned to exactly one course, and each course will have at least one assistant assigned to it. The assignment of assistants to courses is subject to the following conditions: Markets must have exactly two assistants assigned to it. Smith and Taj must be assigned to the same course as each other. Vogel and Yi cannot be assigned to the same course as each other. Yi and Zane must both be assigned to Pricing if either one of them is.",
    "question": "Which one of the following CANNOT be the complete assignment of assistants to Labor?",
    "answer": "B",
    "options": [
      "A) Ramos, Vogel",
      "B) Ramos, Zane",
      "C) Smith, Taj",
      "D) Vogel, Zane",
      "E) Yi, Zane"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAn economics department is assigning six teaching assistants—Ramos, Smith, Taj, Vogel, Yi, and Zane—to three courses—Labor, Markets, and Pricing. Each assistant will be assigned to exactly one course, and each course will have at least one assistant assigned to it. The assignment of assistants to courses is subject to the following conditions: Markets must have exactly two assistants assigned to it. Smith and Taj must be assigned to the same course as each other. Vogel and Yi cannot be assigned to the same course as each other. Yi and Zane must both be assigned to Pricing if either one of them is.\nQuestion:\nWhich one of the following CANNOT be the complete assignment of assistants to Labor?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Ramos, Smith, Taj, Vogel, Yi, Zane])\ncourses = EnumSort([Labor, Markets, Pricing])\nassign = Function([people, courses] -> [bool])\n\n# Constraints\nForAll([p:people], Count([c:courses], assign(p, c)) >= 1) ::: each person is assigned to at least one course\nAnd(Count([c:courses], assign(Markets, c)) >= 2) ::: Markets must have exactly two assistants assigned to it\nForAll([p:people], Implies(assign(p, Labor), Not(assign(Smith, Labor)))) ::: Smith and Taj must be assigned to the same course as each other\nForAll([p:people], Implies(assign(Vogel, Labor), Not(assign(Yi, Labor)))) ::: Vogel and Yi cannot be assigned to the same course as each other\nForAll([p:people], Or(assign(Yi, Pricing), assign(Zane, Pricing))) ::: Yi and Zane must both be assigned to Pricing if either one of them is\n\n# Options\nQuestion ::: Which one of the following CANNOT be the complete assignment of assistants to Labor?\nis_valid(ForAll([p:people], assign(p, Labor) == True)) ::: (A)\nis_valid(ForAll([p:people], assign(p, Labor) == False)) ::: (B)\nis_valid(ForAll([p:people], assign(p, Labor) == assign(Smith, Labor))) ::: (C)\nis_valid(ForAll([p:people], assign(p, Labor) == assign(Vogel, Labor))) ::: (D)\nis_valid(ForAll([p:people], assign(p, Labor) == assign(Yi, Labor))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_3_15",
    "context": "An economics department is assigning six teaching assistants—Ramos, Smith, Taj, Vogel, Yi, and Zane—to three courses—Labor, Markets, and Pricing. Each assistant will be assigned to exactly one course, and each course will have at least one assistant assigned to it. The assignment of assistants to courses is subject to the following conditions: Markets must have exactly two assistants assigned to it. Smith and Taj must be assigned to the same course as each other. Vogel and Yi cannot be assigned to the same course as each other. Yi and Zane must both be assigned to Pricing if either one of them is.",
    "question": "Which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) Ramos and Vogel are both assigned to Markets.",
      "B) Ramos and Taj are both assigned to Markets.",
      "C) Smith and Vogel are both assigned to Markets.",
      "D) Smith and Zane are both assigned to Pricing.",
      "E) Vogel and Zane are both assigned to Pricing."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAn economics department is assigning six teaching assistants—Ramos, Smith, Taj, Vogel, Yi, and Zane—to three courses—Labor, Markets, and Pricing. Each assistant will be assigned to exactly one course, and each course will have at least one assistant assigned to it. The assignment of assistants to courses is subject to the following conditions: Markets must have exactly two assistants assigned to it. Smith and Taj must be assigned to the same course as each other. Vogel and Yi cannot be assigned to the same course as each other. Yi and Zane must both be assigned to Pricing if either one of them is.\nQuestion:\nWhich one of the following could be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Ramos, Smith, Taj, Vogel, Yi, Zane])\ncourses = EnumSort([Labor, Markets, Pricing])\nassigned = Function([people, courses] -> [bool])\n\n# Constraints\nForAll([p:people], Count([c:courses], assigned(p, c)) >= 1) ::: each person is assigned to at least one course\nAnd(Count([c:courses], assigned(Markets, c)) == 2) ::: Markets must have exactly two assistants assigned to it\nForAll([p:people], Implies(assigned(p, Taj), assigned(p, Smith))) ::: Smith and Taj must be assigned to the same course as each other\nForAll([p:people], Implies(assigned(Vogel, Pricing), Not(assigned(Yi, Pricing)))) ::: Vogel and Yi cannot be assigned to the same course as each other\nForAll([p:people], Implies(assigned(Yi, Pricing), assigned(Zane, Pricing))) ::: Yi and Zane must both be assigned to Pricing if either one of them is\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_valid(Exists([c:courses], assigned(Ramos, c))) ::: (A)\nis_valid(Exists([c:courses], assigned(Smith, c))) ::: (B)\nis_valid(Exists([c:courses], assigned(Taj, c))) ::: (C)\nis_valid(Exists([c:courses], assigned(Vogel, c))) ::: (D)\nis_valid(Exists([c:courses], assigned(Yi, c))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_3_16",
    "context": "An economics department is assigning six teaching assistants—Ramos, Smith, Taj, Vogel, Yi, and Zane—to three courses—Labor, Markets, and Pricing. Each assistant will be assigned to exactly one course, and each course will have at least one assistant assigned to it. The assignment of assistants to courses is subject to the following conditions: Markets must have exactly two assistants assigned to it. Smith and Taj must be assigned to the same course as each other. Vogel and Yi cannot be assigned to the same course as each other. Yi and Zane must both be assigned to Pricing if either one of them is.",
    "question": "If Vogel is assigned to the same course as Zane, which one of the following CANNOT be true?",
    "answer": "C",
    "options": [
      "A) Ramos is assigned to Labor.",
      "B) Smith is assigned to Labor.",
      "C) Taj is assigned to Markets.",
      "D) Ramos is assigned to Pricing.",
      "E) Smith is assigned to Pricing."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAn economics department is assigning six teaching assistants—Ramos, Smith, Taj, Vogel, Yi, and Zane—to three courses—Labor, Markets, and Pricing. Each assistant will be assigned to exactly one course, and each course will have at least one assistant assigned to it. The assignment of assistants to courses is subject to the following conditions: Markets must have exactly two assistants assigned to it. Smith and Taj must be assigned to the same course as each other. Vogel and Yi cannot be assigned to the same course as each other. Yi and Zane must both be assigned to Pricing if either one of them is.\nQuestion:\nIf Vogel is assigned to the same course as Zane, which one of the following CANNOT be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Ramos, Smith, Taj, Vogel, Yi, Zane])\ncourses = EnumSort([Labor, Markets, Pricing])\nassigned = Function([people, courses] -> [bool])\n\n# Constraints\nForAll([p:people], Count([c:courses], assigned(p, c)) >= 1) ::: each person is assigned to at least one course\nAnd(assigned(Markets, [p:people]), Count([t:people], And(t != p, assigned(t, Markets))) == 2) ::: Markets must have exactly two assistants assigned to it\nForAll([p:people], And(assigned(p, Taj), assigned(Taj, p))) ::: Smith and Taj must be assigned to the same course as each other\nForAll([p:people], And(assigned(p, Vogel), assigned(Vogel, p))) ::: Vogel and Yi cannot be assigned to the same course as each other\nForAll([p:people], Or(assigned(p, Yi), assigned(p, Zane))) ::: Yi and Zane must both be assigned to Pricing if either one of them is\n\n# Options\nQuestion ::: Which one of the following CANNOT be true if Vogel is assigned to the same course as Zane?\nis_valid(ForAll([p:people], assigned(p, Pricing) == assigned(Zane, Pricing))) ::: (A)\nis_valid(ForAll([p:people], assigned(p, Markets) == assigned(Vogel, Markets))) ::: (B)\nis_valid(ForAll([p:people], assigned(p, Labor) == assigned(Yi, Labor))) ::: (C)\nis_valid(ForAll([p:people], assigned(p, Pricing) == assigned(Yi, Pricing))) ::: (D)\nis_valid(ForAll([p:people], assigned(p, Markets) == assigned(Zane, Markets))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_3_17",
    "context": "An economics department is assigning six teaching assistants—Ramos, Smith, Taj, Vogel, Yi, and Zane—to three courses—Labor, Markets, and Pricing. Each assistant will be assigned to exactly one course, and each course will have at least one assistant assigned to it. The assignment of assistants to courses is subject to the following conditions: Markets must have exactly two assistants assigned to it. Smith and Taj must be assigned to the same course as each other. Vogel and Yi cannot be assigned to the same course as each other. Yi and Zane must both be assigned to Pricing if either one of them is.",
    "question": "If no other assistant is assigned to the same course as Ramos, which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Taj is assigned to Labor.",
      "B) Vogel is assigned to Labor.",
      "C) Yi is assigned to Markets.",
      "D) Zane is assigned to Markets.",
      "E) Smith is assigned to Pricing"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nAn economics department is assigning six teaching assistants—Ramos, Smith, Taj, Vogel, Yi, and Zane—to three courses—Labor, Markets, and Pricing. Each assistant will be assigned to exactly one course, and each course will have at least one assistant assigned to it. The assignment of assistants to courses is subject to the following conditions: Markets must have exactly two assistants assigned to it. Smith and Taj must be assigned to the same course as each other. Vogel and Yi cannot be assigned to the same course as each other. Yi and Zane must both be assigned to Pricing if either one of them is.\nQuestion:\nIf no other assistant is assigned to the same course as Ramos, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\npeople = EnumSort([Ramos, Smith, Taj, Vogel, Yi, Zane])\ncourses = EnumSort([Labor, Markets, Pricing])\nassigned = Function([people, courses] -> [bool])\n\n# Constraints\nForAll([p:people], Count([c:courses], assigned(p, c)) >= 1) ::: each person is assigned to at least one course\nAnd(Count([c:courses], assigned(Markets, c)) == 2) ::: Markets must have exactly two assistants assigned to it\nForAll([p:people], Implies(assigned(p, Labor), Not(assigned(Smith, Labor)))) ::: Smith and Taj must be assigned to the same course as each other\nForAll([p:people], Implies(assigned(Vogel, Pricing), Not(assigned(Yi, Pricing)))) ::: Vogel and Yi cannot be assigned to the same course as each other\nForAll([p:people], Implies(assigned(Yi, Pricing), assigned(Zane, Pricing))) ::: Yi and Zane must both be assigned to Pricing if either one of them is\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(Exists([c:courses], assigned(Ramos, c) == true)) ::: (A)\nis_valid(Exists([c:courses], assigned(Ramos, c) == false)) ::: (B)\nis_valid(Exists([c:courses], assigned(Ramos, c) == assigned(Smith, c))) ::: (C)\nis_valid(Exists([c:courses], assigned(Ramos, c) == assigned(Taj, c))) ::: (D)\nis_valid(Exists([c:courses], assigned(Ramos, c) == assigned(Vogel, c))) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_4_18",
    "context": "There are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.",
    "question": "One possible route of the virus from the first computer in the network infected to Q is",
    "answer": "D",
    "options": [
      "A) from R to P to T to Q",
      "B) from T to S to R to Q",
      "C) from T to S to U to Q",
      "D) from U to P to R to Q",
      "E) from U to T to P to R to Q"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nThere are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.\nQuestion:\nOne possible route of the virus from the first computer in the network infected to Q is\nChoices:\n[[CHOICES]]\n###\n# Declarations\ncomputers = EnumSort([P, Q, R, S, T, U])\nvirus = EnumSort([infected])\ntransmitted = Function([computers] -> [computers])\n\n# Constraints\nForAll([c:computers], Count([t:computers], transmitted(t, c)) >= 1) ::: each computer transmitted the virus to at least one other computer\nAnd(transmitted(S, R), Count([t:computers], And(t != S, transmitted(t, R))) == 1) ::: S transmitted the virus to exactly one other computer on the network\nAnd(transmitted(R, Q), Count([t:computers], And(t != R, transmitted(t, Q))) == 1) ::: either R or T transmitted the virus to Q\nAnd(transmitted(T, P), Count([t:computers], And(t != T, transmitted(t, P))) == 1) ::: either T or U transmitted the virus to P\n\n# Options\nQuestion ::: One possible route of the virus from the first computer in the network infected to Q is\nis_valid(Exists([c:computers], transmitted(c, Q) == [P, T])) ::: (A)\nis_valid(Exists([c:computers], transmitted(c, Q) == [S, T])) ::: (B)\nis_valid(Exists([c:computers], transmitted(c, Q) == [R, U])) ::: (C)\nis_valid(Exists([c:computers], transmitted(c, Q) == [P, R])) ::: (D)\nis_valid(Exists([c:computers], transmitted(c, Q) == [T, R])) ::: (E)\n\n------\nNote: The above code is just an example, and the actual code may vary depending on the specific problem."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_4_19",
    "context": "There are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.",
    "question": "Which one of the following could be the computer that was infected from outside the network?",
    "answer": "E",
    "options": [
      "A) P",
      "B) Q",
      "C) R",
      "D) S",
      "E) T"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nThere are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.\nQuestion:\nWhich one of the following could be the computer that was infected from outside the network?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ncomputers = EnumSort([P, Q, R, S, T, U])\nvirus = EnumSort([infected])\ntransmitted = Function([computers] -> [computers])\n\n# Constraints\nForAll([c:computers], Count([v:virus], c in transmitted(v)) >= 1) ::: each computer received the virus exactly once\nAnd(Count([c:computers], And(c == S, transmitted(S)) == 1), Count([c:computers], And(c != S, transmitted(c)) == 2)) ::: S transmitted the virus to exactly one other computer on the network\nAnd(Count([c:computers], And(c == R, transmitted(R)) == 1), Count([c:computers], And(c != R, transmitted(c)) == 1)) ::: The computer that transmitted the virus to R also transmitted it to S\nOr(Count([c:computers], And(c == T, transmitted(T)) == 1), Count([c:computers], And(c != T, transmitted(c)) == 1)) ::: Either T or U transmitted the virus to P\nOr(Count([c:computers], And(c == U, transmitted(U)) == 1), Count([c:computers], And(c != U, transmitted(c)) == 1)) ::: Either T or U transmitted the virus to P\n\n# Options\nQuestion ::: Which one of the following could be the computer that was infected from outside the network?\nis_valid(Exists([c:computers], And(c == P, transmitted(P)) == 1)) ::: (A)\nis_valid(Exists([c:computers], And(c == Q, transmitted(Q)) == 1)) ::: (B)\nis_valid(Exists([c:computers], And(c == R, transmitted(R)) == 1)) ::: (C)\nis_valid(Exists([c:computers], And(c == S, transmitted(S)) == 1)) ::: (D)\nis_valid(Exists([c:computers], And(c == T, transmitted(T)) == 1)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary based on the specific problem and question."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_4_20",
    "context": "There are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.",
    "question": "If T did not transmit the virus to any other computer on the network, which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) P transmitted the virus to S.",
      "B) Q transmitted the virus to R.",
      "C) U transmitted the virus to S.",
      "D) P did not transmit the virus to any other computer on the network.",
      "E) R did not transmit the virus to any other computer on the network."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nThere are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.\nQuestion:\nIf T did not transmit the virus to any other computer on the network, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ncomputers = EnumSort([P, Q, R, S, T, U])\nvirus = EnumSort([infected])\ntransmitted = Function([computers] -> [bool])\n\n# Constraints\nForAll([c:computers], Count([v:virus], transmitted(c) == v) >= 1) ::: each computer received the virus exactly once\nAnd(transmitted(S), Count([c:computers], And(c == S, transmitted(c))) == 1) ::: S transmitted the virus to exactly one other computer on the network\nOr(transmitted(R), transmitted(T)) ::: The computer that transmitted the virus to R also transmitted it to T\nOr(transmitted(Q), transmitted(T)) ::: Either R or T transmitted the virus to Q\nOr(transmitted(P), transmitted(U)) ::: Either T or U transmitted the virus to P\n\n# Options\nQuestion ::: Which one of the following must be true if T did not transmit the virus to any other computer on the network?\nis_valid(ForAll([c:computers], transmitted(c) == infected))) ::: (A)\nis_valid(ForAll([c:computers], transmitted(c) == not_infected))) ::: (B)\nis_valid(ForAll([c:computers], transmitted(c) == infected) Implies transmitted(T) == False)) ::: (C)\nis_valid(ForAll([c:computers], transmitted(c) == infected) Implies transmitted(U) == False)) ::: (D)\nis_valid(ForAll([c:computers], transmitted(c) == infected) Implies transmitted(S) == False)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and the language used to represent it."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_4_21",
    "context": "There are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.",
    "question": "Any of the following computers could have transmitted the virus to two other computers on the network EXCEPT:",
    "answer": "C",
    "options": [
      "A) P",
      "B) Q",
      "C) R",
      "D) T",
      "E) U"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nThere are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.\nQuestion:\nAny of the following computers could have transmitted the virus to two other computers on the network EXCEPT:\nChoices:\n[[CHOICES]]\n###\n# Declarations\ncomputers = EnumSort([P, Q, R, S, T, U])\nvirus = EnumSort([infected])\ntransmitted = Function([computers] -> [computers])\n\n# Constraints\nForAll([c:computers], Count([v:virus], c in transmitted(v)) >= 1) ::: each computer received the virus exactly once\nAnd(transmitted(S), Count([c:computers], And(c == S, transmitted(c))) == 1) ::: S transmitted the virus to exactly one other computer on the network\nAnd(transmitted(R), Count([c:computers], And(c == R, transmitted(c))) == 1) ::: The computer that transmitted the virus to R also transmitted it to S\nOr(transmitted(Q), transmitted(T)) ::: Either R or T transmitted the virus to Q\nOr(transmitted(U), transmitted(P)) ::: Either T or U transmitted the virus to P\n\n# Options\nQuestion ::: Any of the following computers could have transmitted the virus to two other computers on the network EXCEPT:\nis_valid(Exists([c:computers], transmitted(c) == [P, Q, R, T, U])) ::: (A)\nis_valid(Exists([c:computers], transmitted(c) == [P, Q, R, T])) ::: (B)\nis_valid(Exists([c:computers], transmitted(c) == [P, Q, U, T])) ::: (C)\nis_valid(Exists([c:computers], transmitted(c) == [R, T, P, Q])) ::: (D)\nis_valid(Exists([c:computers], transmitted(c) == [R, T, U, P])) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and the language used to represent it."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_4_22",
    "context": "There are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.",
    "question": "The spread of the virus among the computers is completely determined if which one of the following is true?",
    "answer": "C",
    "options": [
      "A) R transmitted the virus to Q.",
      "B) T transmitted the virus to Q.",
      "C) T transmitted the virus to S.",
      "D) U transmitted the virus to P.",
      "E) U transmitted the virus to R"
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nThere are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.\nQuestion:\nThe spread of the virus among the computers is completely determined if which one of the following is true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ncomputers = EnumSort([P, Q, R, S, T, U])\nvirus = EnumSort([infected])\ntransmitted = Function([computers] -> [bool])\n\n# Constraints\nForAll([c:computers], Count([v:virus], transmitted(c) == v) >= 1) ::: each computer receives the virus exactly once\nAnd(transmitted(S), Count([c:computers], And(c == S, transmitted(c))) == 1) ::: S transmitted the virus to exactly one other computer on the network\nOr(transmitted(R), transmitted(T)) ::: Either R or T transmitted the virus to Q\nOr(transmitted(T), transmitted(U)) ::: Either T or U transmitted the virus to P\n\n# Options\nQuestion ::: Which one of the following is true?\nis_valid(ForAll([c:computers], transmitted(c) == infected)) ::: (A)\nis_valid(ForAll([c:computers], transmitted(c) == not_infected)) ::: (B)\nis_valid(ForAll([c:computers], transmitted(c) == infected) Implies transmitted(R) == transmitted(T)) ::: (C)\nis_valid(ForAll([c:computers], transmitted(c) == infected) Implies transmitted(T) == transmitted(U)) ::: (D)\nis_valid(ForAll([c:computers], transmitted(c) == infected) Implies transmitted(U) == transmitted(S)) ::: (E)\n\n------\n\nNote: The problem and question statements are given in a logical form, which means that they are written in a formal language that can be processed by a logic solver. The problem statements describe the problem domain and the variables involved, while the question statements ask for a logical conclusion that can be drawn from the given information. The options provided are the possible answers to the question, which can be selected using the logic solver."
    ]
  },
  {
    "id": "ar_lsat_201609_3-G_4_23",
    "context": "There are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.",
    "question": "If P is the only computer that transmitted the virus to two other computers on the network, which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) S transmitted the virus to T.",
      "B) T transmitted the virus to P.",
      "C) Q did not transmit the virus to any other computer on the network.",
      "D) R did not transmit the virus to any other computer on the network.",
      "E) U did not transmit the virus to any other computer on the network."
    ],
    "raw_logic_programs": [
      "Given a problem description and a question. The task is to formulate the problem as a logic program, consisting three parts: Declarations, Constraints, and Options.\nDeclarations: Declare the variables and functions.\nConstraints: Write the constraints in the problem description as logic formulas.\nOptions: Write the options in the question as logic formulas.\n------\nProblem:\nOn Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\nQuestion:\nVladimir must eat which one of the following foods?\nChoices:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs\n###\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m) != eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n------\nProblem:\nIn a repair facility there are exactly six technicians: Stacy, Urma, Wim, Xena, Yolanda, and Zane. Each technician repairs machines of at least one of the following three types—radios, televisions, and VCRs—and no other types. The following conditions apply: Xena and exactly three other technicians repair radios. Yolanda repairs both televisions and VCRs. Stacy does not repair any type of machine that Yolanda repairs. Zane repairs more types of machines than Yolanda repairs. Wim does not repair any type of machine that Stacy repairs. Urma repairs exactly two types of machines.\nQuestion:\nWhich one of the following pairs of technicians could repair all and only the same types of machines as each other?\nChoices:\n(A) Stacy and Urma\n(B) Urma and Yolanda\n(C) Urma and Xena\n(D) Wim and Xena\n(E) Xena and Yolanda\n###\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t != Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat(ForAll([m:machines], repairs(Wim, m) == repairs(Xena, m))) ::: (D)\nis_sat(ForAll([m:machines], repairs(Xena, m) == repairs(Yolanda, m))) ::: (E)\n\n------\nProblem:\nThere are exactly six computers—P, Q, R, S, T, and U—on a small network. Exactly one of those computers was infected by a virus from outside the network, and that virus was then transmitted between computers on the network. Each computer received the virus exactly once. The following pieces of information concerning the spread of the virus have been established: No computer transmitted the virus to more than two other computers on the network. S transmitted the virus to exactly one other computer on the network. The computer that transmitted the virus to R also transmitted it to S. Either R or T transmitted the virus to Q. Either T or U transmitted the virus to P.\nQuestion:\nIf P is the only computer that transmitted the virus to two other computers on the network, which one of the following must be true?\nChoices:\n[[CHOICES]]\n###\n# Declarations\ncomputers = EnumSort([P, Q, R, S, T, U])\nvirus = EnumSort([infected])\ntransmitted = Function([computers] -> [bool])\n\n# Constraints\nForAll([c:computers], Count([v:virus], transmitted(c) == v) >= 1) ::: each computer receives the virus exactly once\nAnd(transmitted(S), Count([c:computers], And(c != S, transmitted(c))) == 1) ::: S transmitted the virus to exactly one other computer on the network\nOr(transmitted(R), transmitted(T)) ::: Either R or T transmitted the virus to Q\nOr(transmitted(T), transmitted(U)) ::: Either T or U transmitted the virus to P\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(ForAll([c:computers], transmitted(c) == infected)) ::: (A)\nis_valid(ForAll([c:computers], transmitted(c) == R)) ::: (B)\nis_valid(ForAll([c:computers], transmitted(c) == T)) ::: (C)\nis_valid(ForAll([c:computers], transmitted(c) == U)) ::: (D)\nis_valid(ForAll([c:computers], transmitted(c) == Q)) ::: (E)\n\n------\n\nNote: The above code is just an example, and the actual code may vary depending on the specific problem and question."
    ]
  }
]